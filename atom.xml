<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SugarGood</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-06-09T06:15:17.212Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java并发</title>
    <link href="http://example.com/2023/06/09/Java%E5%B9%B6%E5%8F%91/"/>
    <id>http://example.com/2023/06/09/Java%E5%B9%B6%E5%8F%91/</id>
    <published>2023-06-09T06:04:22.420Z</published>
    <updated>2023-06-09T06:15:17.212Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><a name="GJCOp"></a># disruptor<a name="v7F26"></a># A进程和线程<a name="AoAR9"></a>## 进程我们编写的代码只是⼀个存储在硬盘的静态⽂件，通过编译后就会⽣成⼆进制可执行文件，当我们运⾏这个可执⾏⽂件后，它会被装载到内存中，接着 CPU 会执⾏程序中的每⼀条指令，那么这个运⾏中的程序，<br />就被称为「进程」（Process）。<p><a name="QBqrX"></a></p><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652014692593-7cc7e2f5-2051-4120-b45f-a72e9983d1dc.png#averageHue=%23f9f5ef&clientId=u34a44d6d-2b13-4&from=paste&height=238&id=uf1046b14&originHeight=392&originWidth=1104&originalType=binary&ratio=1&rotation=0&showTitle=false&size=82991&status=done&style=none&taskId=u2344707a-b4f7-4790-82a7-5bc483989c0&title=&width=669.0908704184983" alt="image.png"></p><ul><li>NULL -&gt; 创建状态：⼀个新进程被创建时的第⼀个状态；</li><li>创建状态 -&gt; 就绪状态：当进程被创建完成并初始化后，⼀切就绪准备运⾏时，变为就绪状态，这个过程是很快的；</li><li>就绪态 -&gt; 运⾏状态：处于就绪状态的进程被操作系统的进程调度器选中后，就分配给 CPU 正式运⾏该进程；</li><li>运⾏状态 -&gt; 结束状态：当进程已经运⾏完成或出错时，会被操作系统作结束状态处理；</li><li>运⾏状态 -&gt; 就绪状态：处于运⾏状态的进程在运⾏过程中，由于分配给它的运⾏时间⽚⽤完，操作系统会把该进程变为就绪态，接着从就绪态选中另外⼀个进程运⾏；</li><li>运⾏状态 -&gt; 阻塞状态：当进程请求某个事件且必须等待时，例如请求 I&#x2F;O 事件；</li><li>阻塞状态 -&gt; 就绪状态：当进程要等待的事件完成时，它从阻塞状态变到就绪状态；</li></ul><p>如果有⼤量处于阻塞状态的进程，进程可能会占⽤着物理内存空间，显然不是我们所希望的，毕竟物理内<br />存空间是有限的，被阻塞状态的进程占⽤着物理内存就⼀种浪费物理内存的⾏为。<br />所以，在虚拟内存管理的操作系统中，通常会把阻塞状态的进程的物理内存空间换出到硬盘，等需要再次<br />运⾏ 的时候，再从硬盘换⼊到物理内存。</p><p>那么，就需要⼀个新的状态，来描述进程没有占⽤实际的物理内存空间的情况，这个状态就是挂起状态。<br />这跟阻塞状态是不⼀样，阻塞状态是等待某个事件的返回。<br />另外，挂起状态可以分为两种：</p><ul><li>阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；</li><li>就绪挂起状态：进程在外存（硬盘），但只要进⼊内存，即刻⽴刻运⾏</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652014844389-9ffe9951-d05d-4fe7-9d9d-e8c62341358d.png#averageHue=%23faf9f8&clientId=u34a44d6d-2b13-4&from=paste&height=425&id=u29e48f40&originHeight=701&originWidth=1151&originalType=binary&ratio=1&rotation=0&showTitle=false&size=136033&status=done&style=none&taskId=u1ed509a8-e34a-47d3-afc5-4148bcec457&title=&width=697.575717256967" alt="image.png"><br />导致进程挂起的原因不只是因为进程所使⽤的内存空间不在物理内存，还包括如下情况：</p><ul><li>通过 sleep 让进程间歇性挂起，其⼯作原理是设置⼀个定时器，到期后唤醒进程。</li><li>⽤户希望挂起⼀个程序的执⾏，⽐如在 Linux 中⽤ Ctrl+Z 挂起进程；</li></ul><p><a name="gYkQ4"></a></p><h3 id="进程的控制结构"><a href="#进程的控制结构" class="headerlink" title="进程的控制结构"></a>进程的控制结构</h3><p>在操作系统中，是⽤进程控制块（process control block，PCB）数据结构来描述进程的。</p><p>PCB 是进程存在的唯⼀标识，这意味着⼀个进程的存在，必然会有⼀个 PCB，如果进程消失了，那么<br />PCB 也会随之消失。</p><p><strong>PCB包含的信息:</strong></p><ul><li>进程描述信息：<ul><li>进程标识符：标识各个进程，每个进程都有⼀个并且唯⼀的标识符；</li><li>⽤户标识符：进程归属的⽤户，⽤户标识符主要为共享和保护服务；</li></ul></li><li>进程控制和管理信息：<ul><li>进程当前状态，如 new、ready、running、waiting 或 blocked 等；</li><li>进程优先级：进程抢占 CPU 时的优先级；</li></ul></li><li>资源分配清单：<ul><li>有关内存地址空间或虚拟地址空间的信息，所打开⽂件的列表和所使⽤的 I&#x2F;O 设备信息。</li></ul></li><li>CPU 相关信息：<ul><li>CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程</li><li>重新执⾏时，能从断点处继续执⾏。</li></ul></li></ul><p><strong>PCB的组织形式</strong><br />通常是通过链表的⽅式进⾏组织，把具有相同状态的进程链在⼀起，组成各种队列。⽐如：</p><ul><li>将所有处于就绪状态的进程链在⼀起，称为就绪队列；</li><li>把所有因等待某事件⽽处于等待状态的进程链在⼀起就组成各种阻塞队列；</li><li>另外，对于运⾏队列在单核 CPU 系统中则只有⼀个运⾏指针了，因为单核 CPU 在某个时间，只能运</li></ul><p>⾏⼀个程序。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652015066182-c65fb80f-8de5-4e33-9413-021c9d29151a.png#averageHue=%23f9f8f8&clientId=u34a44d6d-2b13-4&from=paste&height=364&id=ufaadf455&originHeight=601&originWidth=1139&originalType=binary&ratio=1&rotation=0&showTitle=false&size=52809&status=done&style=none&taskId=ubd32928e-852d-4117-a3d9-15f1712c0a6&title=&width=690.3029904045919" alt="image.png"><br />除了链接的组织⽅式，还有索引⽅式，它的⼯作原理：将同⼀状态的进程组织在⼀个索引表中，索引表项<br />指向相应的 PCB，不同状态对应不同的索引表。<br />⼀般会选择链表，因为可能⾯临进程创建，销毁等调度导致进程状态发⽣变化，所以链表能够更加灵活的<br />插⼊和删除。</p><p><a name="aP68n"></a></p><h3 id="线程操作"><a href="#线程操作" class="headerlink" title="线程操作"></a>线程操作</h3><p><a name="G99FL"></a></p><h4 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h4><p>操作系统允许⼀个进程创建另⼀个进程，⽽且允许⼦进程继承⽗进程所拥有的资源，当⼦进程被终⽌时，<br />其在⽗进程处继承的资源应当还给⽗进程。同时，终⽌⽗进程时同时也会终⽌其所有的⼦进程。</p><p>创建进程的过程如下：</p><ul><li>为新进程分配⼀个唯⼀的进程标识号，并申请⼀个空⽩的 PCB，PCB 是有限的，若申请失败则创建</li></ul><p>失败；</p><ul><li>为进程分配资源，此处如果资源不⾜，进程就会进⼊等待状态，以等待资源；</li><li>初始化 PCB；</li><li>如果进程的调度队列能够接纳新进程，那就将进程插⼊到就绪队列，等待被调度运⾏。</li></ul><p><a name="JVltY"></a></p><h4 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h4><p>进程可以有 3 种终⽌⽅式：正常结束、异常结束以及外界⼲预（信号 kill 掉）。<br />终⽌进程的过程如下：</p><ul><li>查找需要终⽌的进程的 PCB；</li><li>如果处于执⾏状态，则⽴即终⽌该进程的执⾏，然后将 CPU 资源分配给其他进程；</li><li>如果其还有⼦进程，则应将其所有⼦进程终⽌；</li><li>将该进程所拥有的全部资源都归还给⽗进程或操作系统；</li><li>将其从 PCB 所在队列中删除。</li></ul><p><a name="RXJlY"></a></p><h4 id="阻塞进程"><a href="#阻塞进程" class="headerlink" title="阻塞进程"></a>阻塞进程</h4><p>当进程需要等待某⼀事件完成时，它可以调⽤阻塞语句把⾃⼰阻塞等待。⽽⼀旦被阻塞等待，它只能由另<br />⼀个进程唤醒。<br />阻塞进程的过程如下：</p><ul><li>找到将要被阻塞进程标识号对应的 PCB；</li><li>如果该进程为运⾏状态，则保护其现场，将其状态转为阻塞状态，停⽌运⾏；</li><li>将该 PCB 插⼊到阻塞队列中去。</li></ul><p><a name="i0Xl0"></a></p><h4 id="唤醒进程"><a href="#唤醒进程" class="headerlink" title="唤醒进程"></a>唤醒进程</h4><p>进程由「运⾏」转变为「阻塞」状态是由于进程必须等待某⼀事件的完成，所以处于阻塞状态的进程是绝<br />对不可能叫醒⾃⼰的。<br />如果某进程正在等待 I&#x2F;O 事件，需由别的进程发消息给它，则只有当该进程所期待的事件出现时，才由发<br />现者进程⽤唤醒语句叫醒它。<br />唤醒进程的过程如下：</p><ul><li>在该事件的阻塞队列中找到相应进程的 PCB；</li><li>将其从阻塞队列中移出，并置其状态为就绪状态；</li><li>把该 PCB 插⼊到就绪队列中，等待调度程序调度；</li><li>进程的阻塞和唤醒是⼀对功能相反的语句，<strong>如果某个进程调用了阻塞语句，则必有⼀个与之对应的唤醒语</strong></li></ul><p><strong>句</strong>。</p><p><a name="iQYbW"></a></p><h3 id="进程的上下文切换"><a href="#进程的上下文切换" class="headerlink" title="进程的上下文切换"></a>进程的上下文切换</h3><p>各个进程之间是共享 CPU 资源的，在不同的时候进程之间需要切换，让不同的进程可以在 CPU 执⾏，那<br />么这个⼀个进程切换到另⼀个进程运⾏，称为进程的上下⽂切换。</p><p>大多数操作系统都是多任务，通常⽀持⼤于 CPU 数量的任务同时运⾏。实际上，这些任务并不是同时运行的，只是因为系统在很短的时间内，让各个任务分别在 CPU 运行，于是就造成同时运⾏的错觉。</p><p>任务是交给 CPU 运⾏的，那么在每个任务运⾏前，CPU 需要知道任务从哪⾥加载，⼜从哪⾥开始运⾏。</p><p>所以，操作系统需要事先帮 CPU 设置好 CPU 寄存器和程序计数器。</p><p>程序计数器则是⽤来存储 CPU 正在执⾏的指令位置、或者即将执⾏的下⼀条指令位置。</p><p>CPU 寄存器和程序计数是 CPU 在运⾏任何任务前，所必须依赖的环境，这些环境就叫做 CPU上下文。</p><p>CPU 上下文切换就是先把前⼀个任务的 CPU 上下⽂（CPU 寄存器和程序计数器）保存起来，然后加载新<br />任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运⾏新任务。<br />系统内核会存储保持下来的上下⽂信息，当此任务再次被分配给 CPU 运⾏时，CPU 会重新加载这些上下<br />文，这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</p><p><a name="FDiRH"></a></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是进程当中的⼀条执⾏流程。</p><p>同⼀个进程内多个线程之间可以共享代码段、数据段、打开的⽂件等资源，但每个线程各⾃都有⼀套独⽴<br />的寄存器和栈，这样可以确保线程的控制流是相对独立的。</p><p><a name="fykuV"></a></p><h3 id="线程与进程的⽐较"><a href="#线程与进程的⽐较" class="headerlink" title="线程与进程的⽐较"></a>线程与进程的⽐较</h3><ul><li>进程是资源（包括内存、打开的⽂件等）分配的单位，线程是 CPU 调度的单位；</li><li>进程拥有⼀个完整的资源平台，⽽线程只独享必不可少的资源，如寄存器和栈；</li><li>线程同样具有就绪、阻塞、执⾏三种基本状态，同样具有状态之间的转换关系；</li><li>线程能减少并发执⾏的时间和空间开销。</li></ul><p><a name="vQCEs"></a></p><h3 id="线程的上下⽂切换"><a href="#线程的上下⽂切换" class="headerlink" title="线程的上下⽂切换"></a>线程的上下⽂切换</h3><p>所谓操作系统的任务调度，实际上的调度对象是线程，⽽进程只是给线程提供了虚拟内存、全局变<br />量等资源。</p><ul><li>当两个线程不是属于同⼀个进程，则切换的过程就跟进程上下⽂切换⼀样；</li><li>当两个线程是属于同⼀个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不</li></ul><p>动，只需要切换线程的私有数据、寄存器等不共享的数据。<br><a name="RFnCM"></a></p><h3 id="创建和运行线程"><a href="#创建和运行线程" class="headerlink" title="创建和运行线程"></a>创建和运行线程</h3><p><a name="SGvVw"></a></p><h4 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法的参数是给线程指定名字，推荐</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="comment">// run 方法内实现了要执行的任务</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">t1.start();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="xjfOJ"></a></p><h4 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task2, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t2.start(); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> () -&gt; log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task2, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t2.start();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>runnable底层就是调用了thread的run方法。<br />用 Runnable 更容易与线程池等高级 API 配合<br />用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</p><p><a name="GP4S5"></a></p><h4 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;()&#123;</span><br><span class="line">    @0verride</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.debug( <span class="string">&quot;running...&quot;</span>);</span><br><span class="line">        Thread.sleep( millis: <span class="number">2000</span>);<span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task,name: <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">log.debug(<span class="string">&quot;0&quot;</span>, task.get());</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="eKLdY"></a></p><h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><p><a name="lp8vj"></a></p><h4 id="start和run"><a href="#start和run" class="headerlink" title="start和run"></a>start和run</h4><p>直接调用 run 是在主线程中执行了 run，没有启动新的线程<br />使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</p><p><a name="zls4c"></a></p><h4 id="sleep和yield"><a href="#sleep和yield" class="headerlink" title="sleep和yield"></a>sleep和yield</h4><p><strong>sleep:</strong></p><ul><li>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）</li><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li><li>睡眠结束后的线程未必会立刻得到执行</li><li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li></ul><p><strong>yield:</strong><br />1. 调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程<br />2. 具体的实现依赖于操作系统的任务调度器</p><p><a name="uFkan"></a></p><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h4><p><strong>interrupt()并不能真正的停止线程，只是更换了线程状态标志。线程还会继续执行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyThread7</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread7</span>();</span><br><span class="line"> </span><br><span class="line">thread.start();</span><br><span class="line">System.out.println(thread.getName() + <span class="string">&quot;线程的中断状态：&quot;</span> + thread.isInterrupted());</span><br><span class="line">thread.interrupt(); <span class="comment">// 由主线程中断了一个子线程</span></span><br><span class="line">System.out.println(thread.getName() + <span class="string">&quot;线程的中断状态：&quot;</span> + thread.isInterrupted());</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">Thread-<span class="number">0</span>线程的中断状态：<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">Thread-<span class="number">0</span>线程的中断状态：<span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>在Core Java中有这样一句话：&quot;没有任何语言方面的需求要求一个被中断的程序应该终止。中断一个线程只是为了引起该线程的注意，被中断线程可以决定如何应对中断 &quot;。这句话启发了我们如何正确的中断一个线程，中断一个线程的本质就是中断run()方法的执行，也就是说run()不再执行后，这个线程就结束了。所以，通过中断状态标志位来控制run()方法中逻辑代码的运行，就可以很好的保证线程的中断。</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;    </span><br><span class="line">        <span class="keyword">try</span>&#123;    </span><br><span class="line">             <span class="comment">//这里的while循环不断的检查中断状态，一旦状态转为true，</span></span><br><span class="line">             <span class="comment">//也就是执行了interrupt方法，那么逻辑代码不再执行。   </span></span><br><span class="line">             <span class="keyword">while</span>(!Thread.currentThread().isInterrupted() &amp;&amp; more work to <span class="keyword">do</span>) &#123;    </span><br><span class="line">                    <span class="comment">// do more work; </span></span><br><span class="line">             &#125;   </span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;    </span><br><span class="line">                    <span class="comment">// thread was interrupted during sleep or wait    </span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;    </span><br><span class="line">                   <span class="comment">// cleanup, if required    </span></span><br><span class="line">        &#125;    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p><strong>使用线程对象的stop()方法停止线程</strong><br />stop方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁。<br />所以一般的lock()方法 无法响应中断，而像lockInterruptibly()、tryLock()等方法就会检测线程中断状态，一旦发现线程处于旦中断状态则立即抛出** InterruptedException**</p><p>那阻塞状态的线程如果终止呢? 答案 抛出异常！</p><p>我们在sleep方法中看到过，它抛出了一个InterruptedException，当一个线程使用了sleep方法（wait、join）处于阻塞状态时，再使用interrupt就会触发sleep方法抛出InterruptedException异常（实际上是给阻塞的线程发出中断信号，阻塞线程检查到中断标识,就会抛出异常），进而导致线程中断。</p><p><strong>打断 sleep 的线程, 会清空打断状态。(将标志位改为false)</strong><br /><a href="https://blog.csdn.net/weixin_43237362/article/details/104416273"><br /></a><br><a name="UnYbh"></a></p><h5 id="interrupted-方法"><a href="#interrupted-方法" class="headerlink" title="interrupted()方法"></a>interrupted()方法</h5><p><strong>作用是测试当前线程是否已经中断，线程的中断状态也是由该方法清除</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().interrupt();</span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程的中断状态：&quot;</span> + Thread.currentThread().interrupted());</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程的中断状态：&quot;</span> + Thread.currentThread().interrupted());</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">main线程的中断状态：<span class="literal">true</span></span><br><span class="line">main线程的中断状态：<span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主线程被打断，使用interrupted()方法查看中断状态，发现标志位改为了true；再次使用interrupted()查看中断状态，发现标志位改为false。在第一次使用interrupted()方法时，它返回标志位，同时清除标志位（置为false），导致下一次的返回值变为false。所以interrupted()方法有清除标志位的功能<br /><a href="https://blog.csdn.net/weixin_43237362/article/details/104416273"><br /></a><br><a name="IXiJe"></a></p><h5 id="isInterrupted"><a href="#isInterrupted" class="headerlink" title="isInterrupted()"></a>isInterrupted()</h5><p>测试此线程是否已被中断。线程的中断状态不受此方法的影响</p><p><a name="VQNu6"></a></p><h4 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h4><p><strong>等待调用join的线程结束，才继续向下运行。</strong></p><p><a name="S6HW0"></a></p><h4 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait notify"></a>wait notify</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652338651309-4599722a-8716-4dcf-89b0-9c5b62fafe3e.png#averageHue=%23f6f8f2&clientId=uda4812d7-352a-4&from=paste&height=369&id=ud32a6d57&originHeight=554&originWidth=1396&originalType=binary&ratio=1&rotation=0&showTitle=false&size=307339&status=done&style=none&taskId=u96a5f588-6473-4540-bd82-7d7806c7c4d&title=&width=930.6666666666666" alt="image.png"></p><ul><li>Owner线程发现条件不满足，调用wait方法，即可进入WaitSet变为WAITING状态</li><li>BLOCKED和WAITING的线程都处于阻塞状态，<strong>不占用CPU时间片</strong></li><li>BLOCKED线程会在Owner线程释放锁时唤醒</li><li>WAITNG线程会在Owner线程调用notify或notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，<strong>仍需进入EntryList重新竞争</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="keyword">while</span>(条件不成立)&#123;</span><br><span class="line">        lock.wait( );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//干活</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">另一个线程</span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    lock.notifyAll( );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="OlK6D"></a></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><a name="nP6HL"></a></p><h4 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h4><ul><li>sleep是Thread方法，而wait是Object的方法</li><li>sleep不需要强制和synchronized配合使用，但wait需要和synchronized一起用</li><li>sleep在睡眠的同时，不会释放对象锁的，但wait在等待的时候会释放对象锁。</li></ul><p><a name="Rcpgi"></a></p><h4 id="park-unpark"><a href="#park-unpark" class="headerlink" title="park unpark"></a>park unpark</h4><p>它们是LockSupport类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暂停当前线程</span></span><br><span class="line">LockSupport.park( );</span><br><span class="line"><span class="comment">//恢复某个线程的运行</span></span><br><span class="line">LockSupport.unpark(暂停线程对象)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652342049662-9ec70bbc-86c6-431e-b0eb-22d78438368b.png#averageHue=%23fbfaf7&clientId=uda4812d7-352a-4&from=paste&height=407&id=Mmz8A&originHeight=610&originWidth=807&originalType=binary&ratio=1&rotation=0&showTitle=false&size=215921&status=done&style=none&taskId=u7b8a9d81-18d8-494e-9a3f-0f9a39db456&title=&width=538" alt="image.png"><br />与Object的 wait &amp; notify相比</p><ul><li>wait，notify和notifyAll必须配合Object Monitor一起使用，而park，unpark不必</li><li>park &amp; unpark是以线程为单位来【阻塞】和【唤醒】线程，而notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】</li><li>park &amp; unpark可以先unpark，而wait &amp; notify 不能先notify</li></ul><p><strong>原理:</strong><br />调用park就是要看需不需要停下来歇息</p><ul><li>如果备用干粮耗尽，那么钻进帐篷歇息</li><li>如果备用干粮充足，那么不需停留，继续前进</li></ul><p>调用unpark，就好比令干粮充足</p><ul><li>如果这时线程还在帐篷，就唤醒让他继续前进</li><li>如果这时线程还在运行，那么下次他调用park时，仅是消耗掉备用干粮，不需停留继续刖进</li><li>因为背包空间有限，多次调用unpark仅会补充一份备用干粮</li></ul><p><a name="EYNYf"></a></p><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><p><a name="dAzv2"></a></p><h4 id="不推荐的方法"><a href="#不推荐的方法" class="headerlink" title="不推荐的方法"></a>不推荐的方法</h4><p>这些方法已过时，容易破坏同步代码块，造成线程死锁</p><ul><li>stop() 停止线程运行</li><li>suspend() 挂起（暂停）线程运行</li><li>resume() 恢复线程运行</li></ul><p><a name="crgLq"></a></p><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p><p><a name="AaLjj"></a></p><h2 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h2><p>每个Java对象都可以关联一个Monitor对象，如果使用synchronized给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向Monitor对象的指针。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652099542729-3c06ed19-823d-415a-853b-1363f0c6b875.png#averageHue=%23f5f6f0&clientId=u9ed45425-92a7-4&from=paste&height=292&id=uf25da9a0&originHeight=547&originWidth=1391&originalType=binary&ratio=1&rotation=0&showTitle=false&size=281661&status=done&style=none&taskId=u4c5f7338-673d-4f92-99fe-f1fa3d791d8&title=&width=741.8666666666667" alt="image.png"></p><ul><li>刚开始Monitor中Owner为null</li><li>当Thread-2 执行synchronized(obj)就会将Monitor的所有者Owner置为Thread-2，Monitor中只能有一个Owner</li><li>在Thread-2上锁的过程中，如果Thread-3，Thread-4，Thread-5也来执行synchronized(obj)，就会进入EntryList BLOCKED</li><li>Thread-2执行完同步代码块的内容，然后唤醒EntryList 中等待的线程来竞争锁，竞争的时是非公平的</li><li>图中 WaitSet中的Thread-0，Thread-1是之前获得过锁，调用了wait()方法的线程。</li><li>一个对象对应一个monitor</li></ul><p><a name="V24EM"></a></p><h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2><p><a name="Tgg5X"></a></p><h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><p><a name="RdCCA"></a></p><h2 id="reetrantLock"><a href="#reetrantLock" class="headerlink" title="reetrantLock"></a>reetrantLock</h2><p>相对于synchronized它具备如下特点</p><ul><li>可中断</li><li>可以设置超时时间</li><li>可以设置为公平锁</li><li>支持多个条件变量</li><li>和synchronized一样，都支持可重入</li><li>不公平锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取锁</span></span><br><span class="line">reentrantLock .lock( );</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//临界区</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">reentrantLock.unlock( );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="sr4OZ"></a></p><h3 id="Condition-条件变量"><a href="#Condition-条件变量" class="headerlink" title="Condition 条件变量"></a>Condition 条件变量</h3><p>ReentrantLock的条件变量比 synchronized强大之处在于，它是支持多个条件变量的，这就好比 synchronized是那些不满足条件的线程都在一间休息室等消息，而ReentrantLock支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒。</p><p>使用流程</p><ul><li>await 前需要获得锁</li><li>await 执行后，会释放锁，进入conditionObject 等待</li><li>await的线程被唤醒（回打断、或超时）取重新竞争lock锁</li><li>竞争 lock 锁成功后，从await后继续执行</li></ul><p>对应唤醒方法 signal();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitCigaretteQueue</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitbreakfastQueue</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">hasCigrette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">hasBreakfast</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             lock.lock();</span><br><span class="line">             <span class="keyword">while</span> (!hasCigrette) &#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     waitCigaretteQueue.await();</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">                 log.debug(<span class="string">&quot;等到了它的烟&quot;</span>);</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             lock.unlock();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             lock.lock();</span><br><span class="line">             <span class="keyword">while</span> (!hasBreakfast) &#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     waitbreakfastQueue.await();</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             log.debug(<span class="string">&quot;等到了它的早餐&quot;</span>);</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             lock.unlock();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;).start();</span><br><span class="line">     sleep(<span class="number">1</span>);</span><br><span class="line">     sendBreakfast();</span><br><span class="line">     sleep(<span class="number">1</span>);</span><br><span class="line">     sendCigarette();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendCigarette</span><span class="params">()</span> &#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         log.debug(<span class="string">&quot;送烟来了&quot;</span>);</span><br><span class="line">         hasCigrette = <span class="literal">true</span>;</span><br><span class="line">         waitCigaretteQueue.signal();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendBreakfast</span><span class="params">()</span> &#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         log.debug(<span class="string">&quot;送早餐来了&quot;</span>);</span><br><span class="line">         hasBreakfast = <span class="literal">true</span>;</span><br><span class="line">         waitbreakfastQueue.signal();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="StHTV"></a></p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.n8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.log.LogDelegateFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestPool&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPool</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPool</span>(<span class="number">1</span>,</span><br><span class="line">                <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="number">1</span>, (queue, task)-&gt;&#123;</span><br><span class="line">            <span class="comment">// 1. 死等</span></span><br><span class="line"><span class="comment">//            queue.put(task);</span></span><br><span class="line">            <span class="comment">// 2) 带超时等待</span></span><br><span class="line"><span class="comment">//            queue.offer(task, 1500, TimeUnit.MILLISECONDS);</span></span><br><span class="line">            <span class="comment">// 3) 让调用者放弃任务执行</span></span><br><span class="line"><span class="comment">//            log.debug(&quot;放弃&#123;&#125;&quot;, task);</span></span><br><span class="line">            <span class="comment">// 4) 让调用者抛出异常</span></span><br><span class="line"><span class="comment">//            throw new RuntimeException(&quot;任务执行失败 &quot; + task);·</span></span><br><span class="line">            <span class="comment">// 5) 让调用者自己执行任务</span></span><br><span class="line">            task.run();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();reject</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, j);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span> <span class="comment">// 拒绝策略</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">RejectPolicy</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">(BlockingQueue&lt;T&gt; queue, T task)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.ThreadPool&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程集合</span></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> coreSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取任务时的超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        <span class="comment">// 当任务数没有超过 coreSize 时，直接交给 worker 对象执行</span></span><br><span class="line">        <span class="comment">// 如果任务数超过 coreSize 时，加入任务队列暂存</span></span><br><span class="line">        <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">            <span class="keyword">if</span>(workers.size() &lt; coreSize) &#123;</span><br><span class="line">                <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(task);</span><br><span class="line">                log.debug(<span class="string">&quot;新增 worker&#123;&#125;, &#123;&#125;&quot;</span>, worker, task);</span><br><span class="line">                workers.add(worker);</span><br><span class="line">                worker.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//                taskQueue.put(task);</span></span><br><span class="line">                <span class="comment">// 1) 死等</span></span><br><span class="line">                <span class="comment">// 2) 带超时等待</span></span><br><span class="line">                <span class="comment">// 3) 让调用者放弃任务执行</span></span><br><span class="line">                <span class="comment">// 4) 让调用者抛出异常</span></span><br><span class="line">                <span class="comment">// 5) 让调用者自己执行任务</span></span><br><span class="line">                taskQueue.tryPut(rejectPolicy, task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPool</span><span class="params">(<span class="type">int</span> coreSize, <span class="type">long</span> timeout, TimeUnit timeUnit, <span class="type">int</span> queueCapcity, RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="built_in">this</span>.timeout = timeout;</span><br><span class="line">        <span class="built_in">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="built_in">this</span>.taskQueue = <span class="keyword">new</span> <span class="title class_">BlockingQueue</span>&lt;&gt;(queueCapcity);</span><br><span class="line">        <span class="built_in">this</span>.rejectPolicy = rejectPolicy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            <span class="comment">// 1) 当 task 不为空，执行任务</span></span><br><span class="line">            <span class="comment">// 2) 当 task 执行完毕，再接着从任务队列获取任务并执行</span></span><br><span class="line"><span class="comment">//            while(task != null || (task = taskQueue.take()) != null) &#123;</span></span><br><span class="line">            <span class="keyword">while</span>(task != <span class="literal">null</span> || (task = taskQueue.poll(timeout, timeUnit)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;正在执行...&#123;&#125;&quot;</span>, task);</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;worker 被移除&#123;&#125;&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">                workers.remove(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.BlockingQueue&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockingQueue</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 1. 任务队列</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 生产者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">fullWaitSet</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 消费者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">emptyWaitSet</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capcity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlockingQueue</span><span class="params">(<span class="type">int</span> capcity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capcity = capcity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带超时阻塞获取</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将 timeout 统一转换为 纳秒</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 返回值是剩余时间</span></span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nanos = emptyWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞获取</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">take</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emptyWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(T task)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capcity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;等待加入任务队列 &#123;&#125; ...&quot;</span>, task);</span><br><span class="line">                    fullWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带超时时间阻塞添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(T task, <span class="type">long</span> timeout, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> timeUnit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capcity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    log.debug(<span class="string">&quot;等待加入任务队列 &#123;&#125; ...&quot;</span>, task);</span><br><span class="line">                    nanos = fullWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue.size();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryPut</span><span class="params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断队列是否满</span></span><br><span class="line">            <span class="keyword">if</span>(queue.size() == capcity) &#123;</span><br><span class="line">                rejectPolicy.reject(<span class="built_in">this</span>, task);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 有空闲</span></span><br><span class="line">                log.debug(<span class="string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);</span><br><span class="line">                queue.addLast(task);</span><br><span class="line">                emptyWaitSet.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="mHmgu"></a></p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p><a name="eUkjQ"></a></p><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>ThreadPoolExecutor使用int的高3位来表示状态，低29位表示线程数量<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652615305684-93eb1080-2675-4e22-a601-d6e897d8c7a0.png#averageHue=%23eeeeee&clientId=ua41d68fc-b28c-4&from=paste&height=265&id=u3b03a6ec&originHeight=398&originWidth=1487&originalType=binary&ratio=1&rotation=0&showTitle=false&size=219096&status=done&style=none&taskId=ue3616037-fcea-4a3d-8822-75377b41119&title=&width=991.3333333333334" alt="image.png"></p><p><a name="ru0jS"></a></p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, (核心线程数)</span></span><br><span class="line">                              <span class="type">int</span> maximumPoolSize, (最大线程数) </span><br><span class="line">                              <span class="type">long</span> keepAliveTime,(生存时间)</span><br><span class="line">                              TimeUnit unit,(生存时间-时间单位)</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,(阻塞队列)</span><br><span class="line">                              ThreadFactory threadFactory,(线程工厂)</span><br><span class="line">                              RejectedExecutionHandler handler) (拒绝策略)</span><br></pre></td></tr></table></figure><p>当核心线程和阻塞队列都被占满时，就会先创建救急线程来执行任务，如果救急线程都不够了，才会使用拒绝策略。<br />救急线程数&#x3D;maximumPoolSize-corePoolSize；<br />当救急线程空闲下来，存活的时间&#x3D;keepAliveTime；</p><p><strong>拒绝策略：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652618529015-3760401d-dbea-47d0-88ab-60231f945b07.png#averageHue=%23faf9f2&clientId=ua41d68fc-b28c-4&from=paste&height=159&id=u45a1a778&originHeight=238&originWidth=1423&originalType=binary&ratio=1&rotation=0&showTitle=false&size=143786&status=done&style=none&taskId=uef982398-83de-49fa-87ab-62a69a18e04&title=&width=948.6666666666666" alt="image.png"></p><ul><li>AbortPolicy让调用者抛出RejectedExecutionException异常，这是默认策略</li><li>CallerRunsPolicy让调用者运行任务</li><li>DiscardPolicy 放弃本次任务</li><li>DiscardOldestPolicy放弃队列中最早的任务，本任务取而代之。</li></ul><p><strong>其他框架拒绝策略实现</strong></p><ul><li>Dubbo的实现，在抛出RejectedExecutionException异常之前会记录日志,并dump线程栈信息，方便定位问题</li><li>Netty 的实现，是创建一个新线程来执行任务</li><li>ActiveMQ的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略 </li><li>PinPoint的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li></ul><p><a name="C23hI"></a></p><h3 id="工厂方法创建线程池"><a href="#工厂方法创建线程池" class="headerlink" title="工厂方法创建线程池"></a>工厂方法创建线程池</h3><p><a name="f6PBD"></a></p><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>,TimeUnit.MILLISECONDs,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>核心线程数&#x3D;&#x3D;最大线程数（没有救急线程被创建)，因此也无需超时时间<br />阻塞队列是无界的，可以放任意数量的任务</p><p><a name="ouVaY"></a></p><h4 id="newCacheThreadPool"><a href="#newCacheThreadPool" class="headerlink" title="newCacheThreadPool"></a>newCacheThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>,Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>,TimeUnit.SECONDs,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>核心线程数是0，最大线程数是Integer.MAX_VALUE，救急线程的空闲生存时间是60s，意味着</p><ul><li>全部都是救急线程（60s后可以回收)</li><li>救急线程可以无限创建</li></ul><p>队列采用了SynchronousQueue实现特点是，它没有容量，没有线程来取是放不进去的(一手交钱、一手交货)</p><p><a name="pgIji"></a></p><h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Executorservice <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">     (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">                             <span class="number">0L</span>,TimeUnit.MILLISECONDs,</span><br><span class="line">                             <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作</p><ul><li><p>Executors.newSingleThreadExecutor()线程个数始终为1，不能修改</p><ul><li>FinalizableDelegatedExecutorService应用的是装饰器模式，只对外暴露了ExecutorService接口，因此不能调用ThreadPoolExecutor 中特有的方法</li></ul></li><li><p>Executors.newFixedThreadPool(1)初始时为1，以后还可以修改</p><ul><li>对外暴露的是ThreadPoolExecutor对象，可以强转后调用setCorePoolSize等方法进行修改</li></ul></li></ul><p><a name="QrC4d"></a></p><h2 id="Fork-x2F-Join"><a href="#Fork-x2F-Join" class="headerlink" title="Fork&#x2F;Join"></a>Fork&#x2F;Join</h2><p>Fork&#x2F;Join是JDK1.7加入的新的线程池实现，它体现的是一种分治思想。适用于能够进行任务拆分的cpu密集型运算。</p><p>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列、都可以用分治思想进行求解。</p><p>Fork&#x2F;Join在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率。</p><p>Fork&#x2F;Join默认会创建与cpu核心数大小相同的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">4</span>);</span><br><span class="line"><span class="comment">//        System.out.println(pool.invoke(new AddTask1(5)));</span></span><br><span class="line">        System.out.println(pool.invoke(<span class="keyword">new</span> <span class="title class_">AddTask3</span>(<span class="number">1</span>, <span class="number">5</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简单拆分 每次加法拆一个线程</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.AddTask&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddTask1</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddTask1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> + n + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;join() &#123;&#125;&quot;</span>, n);</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">AddTask1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask1</span>(n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//拆分</span></span><br><span class="line">        t1.fork();</span><br><span class="line">        log.debug(<span class="string">&quot;fork() &#123;&#125; + &#123;&#125;&quot;</span>, n, t1);</span><br><span class="line">        <span class="comment">//join:得到这次拆分的结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> n + t1.join();</span><br><span class="line">        log.debug(<span class="string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, n, t1, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分法拆分</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.AddTask&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddTask3</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> begin;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddTask3</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.begin = begin;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> + begin + <span class="string">&quot;,&quot;</span> + end + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;join() &#123;&#125;&quot;</span>, begin);</span><br><span class="line">            <span class="keyword">return</span> begin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end - begin == <span class="number">1</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, begin, end, end + begin);</span><br><span class="line">            <span class="keyword">return</span> end + begin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (end + begin) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">AddTask3</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask3</span>(begin, mid);</span><br><span class="line">        t1.fork();</span><br><span class="line">        <span class="type">AddTask3</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask3</span>(mid + <span class="number">1</span>, end);</span><br><span class="line">        t2.fork();</span><br><span class="line">        log.debug(<span class="string">&quot;fork() &#123;&#125; + &#123;&#125; = ?&quot;</span>, t1, t2);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> t1.join() + t2.join();</span><br><span class="line">        log.debug(<span class="string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, t1, t2, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a name="BB3Fs"></a></p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>全称是AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652853489298-79c23aa0-a5a0-4044-8128-f10337964b30.png#averageHue=%23fcfcfc&clientId=u0ee394ca-2eaa-4&from=paste&height=321&id=u2cf38110&originHeight=481&originWidth=976&originalType=binary&ratio=1&rotation=0&showTitle=false&size=119476&status=done&style=none&taskId=u02dd47a0-cef2-430d-8ae7-fde31f5781f&title=&width=650.6666666666666" alt="image.png"><br />AQS使用一个violatile的int类型的成员变量<strong>state</strong>来表示同步状态，通过内置的<strong>FIFO队列</strong>来完成资源获取的排队工作，将每条要抢占资源的线程封装成一个Node节点来完成锁的分配，通过CAS完成对state值的修改</p><p>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore&#x2F;CountDownLatch）。</p><p>ReetrantLock之类的自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p><ul><li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返w回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><p>自定义同步器内部会有一个AbstractQueuedSynchronizer的子类对象sync来使用aqs的内部API完成锁相关的操作。</p><p>Node结点是对每一个等待获取资源的线程的封装，其包含了需要同步的线程本身及其等待状态，如是否被阻塞、是否等待唤醒、是否已经被取消等。变量waitStatus则表示当前Node结点的等待状态，共有5种取CANCELLED、SIGNAL、CONDITION、PROPAGATE、0。</p><ul><li>CANCELLED(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</li><li>SIGNAL(-1)：<strong>表示后继结点在等待当前结点唤醒</strong>。后继结点入队时，会将前继结点的状态更新为SIGNAL。</li><li>CONDITION(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。</li><li>PROPAGATE(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li><li>0：新结点入队时的默认状态<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响<br /><strong>tryAcquire(int)：</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">//AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现</span></span><br></pre></td></tr></table></figure></li></ul><p><a name="c5HZ8"></a></p><h2 id="reetrantLock原理"><a href="#reetrantLock原理" class="headerlink" title="reetrantLock原理"></a>reetrantLock原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync是ReentrantLock的一个属性对象  aqs的子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;<span class="comment">//reetrantLock中有两个sync实现类 </span></span><br><span class="line">        ......</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//非公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                <span class="comment">//设置aps中一个变量为当前线程，记录当前抢占到锁的线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假如有三个线程ABC ,线程A首先拿到了锁，线程B执行lock方法时就会走到<strong>acquire</strong>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是调用的sync父类-aqs的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;</span><br><span class="line">            selfInt<span class="title function_">errupt</span><span class="params">()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="T3MMS"></a></p><h4 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h4><p>见代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里调用进入非公平锁的tryAcquire</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 具体代码在这里</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="comment">//若当前无其他线程抢占锁，则抢占；这里体现了非公平锁。</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">           <span class="comment">//如果已获取锁的线程再调用lock()则state值+1，这里就是可重入的原理</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 都不是则返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//显然 此时应该返回false 就会走后面的判断</span></span><br><span class="line"><span class="comment">//acquireQueued(addWaiter(Node.EXCLUSIVE), arg) 先看 addwaiter方法</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个节点 mode</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">// 刚开始tail是null，如果tail有值了就将node插入队尾；</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                    pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若队列为空，则插入节点</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果队列中有节点，队尾就不会为空，就将当前节点作为尾节点，此时队列为空，走enq方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 死循环</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// 初始下tail为null，因此创建一个头节点</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;<span class="comment">// 第二次循环，队列不为空，就将该节点插入队尾</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>enq插入节点是死循环:<br />第一次循环，由于tail为空，他先创建一个空的node节点，作为头节点，此时waitStatus&#x3D;0，然后将head指向该头节点，并将tail指针也指向head;<br />第二次循环，他将待插入node节点（线程B）的前置指针指向tail指向的节点（头节点），然后CAS将tail指向当前待插入节点（线程B），再让原来的tail指向的节点（头节点）的next域指向当前节点，这样就完成了节点（线程B）插入队尾，完成链式结构，跳出循环；<br /><code>此时head依然是虚拟头节点，tail指向刚插入的节点</code></p><p>现在就要进入前面acquire的AQS.acquireQueued(node, 1)方法了 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();<span class="comment">//获取节点的前置节点，线程B获取到的是头节点</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">//由于线程A占用，尝试获取失败</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())<span class="comment">// 线程B会进入这里</span></span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一次循环：首先predecessor()取出的就是前置节点，p就是链表中的头节点，然后进入判断，当前确实是头节点，然后再次尝试tryAcquire()，由于线程A并没有释放锁，因此，只能进入shouldParkAfterFailedAcquire()方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;<span class="comment">// 头节点的waitStatus=0</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)<span class="comment">// -1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<span class="comment">// 将头节点的waitStatus设置成-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//AQS.shouldParkAfterFailedAcquire(头节点，当前节点)，由于头节点的waitStatus等于0，</span></span><br><span class="line"><span class="comment">//因此这里最终将头节点的waitStatus设置成-1，并返回false；</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后进行第二次循环，再次进入shouldParkAfterFailedAcquire(),这一次由于ws&#x3D;-1，因此返回true，并进入parkAndCheckInterrupt()方法；这里会调用LockSupport.park()将线程挂起，此刻线程B就阻塞再这里了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">       LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">       <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着线程C调用lock()方法<br />省略前面的步骤，跳到addWaiter方法。<br />此刻addWaiter()方法的执行和线程B就有区别了，因为CLH队列有节点了，他直接将创建好的Node插入队尾并返回；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个节点 线程C</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">         <span class="comment">// 此时队列右节点，进入if</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 插入线程C节点到队尾并返回</span></span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 线程C不走这里</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着是acquireQueued()方法这里由于线程C的前置节点不是头节点，因此直接进入shouldParkAfterFailedAcquire()将线程B的状态改为-1；这里线程C把线程B节点的status改为了-1；</p><p>线程A调用unlock()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行ReentrantLock.unlock()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AQS.release()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 执行ReentrantLock.tryRelease()</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//c==0才会返回true 实现锁重入</span></span><br><span class="line">                free = <span class="literal">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//这里呢，线程A就先去获取AQS的state，并对应减去1个，并设置当前占有线程为null，</span></span><br><span class="line"><span class="comment">//然后找到头节点去调用unparkSuccessor(head);</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;<span class="comment">// 头节点是-1</span></span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);<span class="comment">// 头节点设置为0</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;<span class="comment">// 线程B</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。</span></span><br><span class="line"><span class="comment">        * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，</span></span><br><span class="line"><span class="comment">        * 稍后就会被保安大叔赶走了(GC回收)！</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="literal">null</span>) </span><br><span class="line">            LockSupport.unpark(s.thread);<span class="comment">//唤醒线程B</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//此刻进入unparkSuccessor(头节点)中，他将头节点的状态从-1设置为0，然后唤醒线程B；</span></span><br></pre></td></tr></table></figure><p>线程B唤醒后就会执行acquireQueued第三次循环<br />第三次循环时，执行tryAcquire 如果此时又来了一个线程获取锁，就会和线程B竞争，看获取到。这就是非公平的体现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();<span class="comment">//获取节点的前置节点，线程B获取到的是头节点</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">//目前锁无占用，进入此处</span></span><br><span class="line">                    setHead(node); <span class="comment">// 重新设置头节点</span></span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted; <span class="comment">// 被改为true</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())<span class="comment">// 线程B从这里唤醒</span></span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改头节点</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        head = node;</span><br><span class="line">        node.thread = <span class="literal">null</span>;</span><br><span class="line">        node.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="VMTzC"></a></p><h4 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h4><p><strong>不可打断模式</strong><br />在此模式下，即使它被打断，仍会驻留在AQS队列中，等获得锁后方能继续运行（是继续运行!只是打断标记被设置为true)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())<span class="comment">// 线程B会进入这里</span></span><br><span class="line">                    <span class="comment">//线程在这里阻塞,如果外面调用打断方法会唤醒线程  看下面的方法</span></span><br><span class="line">                    <span class="comment">//就会将interrupted置为true,然后继续for循环</span></span><br><span class="line">                    <span class="comment">//后面的循环又会park住</span></span><br><span class="line">                    <span class="comment">//当之前获取到锁的线程释放锁，唤醒park</span></span><br><span class="line">                    <span class="comment">// 此时下面的方法会返回false跳出if, 此时interrupted为true</span></span><br><span class="line">                    <span class="comment">//正常没有打断的情况。parkAndCheckInterrupt返回的都是false就不会进入if语句</span></span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//打断后 返回true但是线程中断标志位为false。返回true会执行后面的if语句,</span></span><br><span class="line">        <span class="comment">//如果不清除打断标记，那线程中断标志位就为true,park会失效，无法阻塞。</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是调用的sync父类-aqs的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;</span><br><span class="line">            <span class="comment">//被打断后 acquireQueued返回true  会执行selfInterrupt方法 执行中断</span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="jIeXF"></a></p><h4 id="公平锁的原理"><a href="#公平锁的原理" class="headerlink" title="公平锁的原理"></a>公平锁的原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">     acquire(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (</span><br><span class="line">         !tryAcquire(arg) &amp;&amp;</span><br><span class="line">         acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">         ) &#123;</span><br><span class="line">             selfInterrupt();</span><br><span class="line">         &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 与非公平锁主要区别在于 tryAcquire 方法的实现</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">     <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">     <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</span></span><br><span class="line">         <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">             compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">             setExclusiveOwnerThread(current);</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">         <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">         setState(nextc);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">     <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">     Node s;</span><br><span class="line">     <span class="comment">// h != t 时表示队列中有 Node</span></span><br><span class="line">     <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">     (</span><br><span class="line">         <span class="comment">// (s = h.next) == null 表示队列中还有没有老二</span></span><br><span class="line">         (s = h.next) == <span class="literal">null</span> ||</span><br><span class="line">            <span class="comment">// 或者队列中老二线程不是此线程</span></span><br><span class="line">         s.thread != Thread.currentThread()</span><br><span class="line">     );</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="owzuC"></a></p><h4 id="条件变量condition的实现原理"><a href="#条件变量condition的实现原理" class="headerlink" title="条件变量condition的实现原理"></a>条件变量condition的实现原理</h4><p>每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">condition.await();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ConditionObject <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">//new ConditionObject()是aqs的方法 返回其内部的ConditionObject对象 是condition类的实现类</span></span><br><span class="line">    </span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>** 开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程  **</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//aqs中ConditionObject对象对condition类await方法的实现  ConditionObject是aqs里面的一个子class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">            <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">            <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用addConditionWaiter方法</span></span><br><span class="line"> <span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">//firstWaiter lastWaiter 是条件队列ConditionObject首尾指针</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">            <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">            <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">                t = lastWaiter;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">                firstWaiter = node;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t.nextWaiter = node;</span><br><span class="line">            lastWaiter = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//创建新的 Node 状态为 -2（Node.CONDITION），关联 执行await方法的线程，加入等待队列尾部</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652972599848-303b15d6-c972-4d9b-89ae-db1257d53fb7.png#averageHue=%23f7f7f7&clientId=u0ead8153-855e-4&from=paste&height=375&id=u90f15228&originHeight=563&originWidth=1559&originalType=binary&ratio=1&rotation=0&showTitle=true&size=133829&status=done&style=none&taskId=u1296a2b2-2147-460c-b1f4-7daa8b67cdb&title=addConditionWaiter%E6%B5%81%E7%A8%8B&width=1039.3333333333333" alt="addConditionWaiter流程" title="addConditionWaiter流程"><br /> 接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullyRelease</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> savedState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                node.waitStatus = Node.CANCELLED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//释放锁之后，唤起等待队列里的线程来竞争锁 假设thread-1竞争成功</span></span><br></pre></td></tr></table></figure><p> <img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652972885079-9b76a3b1-0a91-4538-ba8b-29baf13b78b5.png#averageHue=%23f7f7f7&clientId=u0ead8153-855e-4&from=paste&height=387&id=u75ce8516&originHeight=581&originWidth=1526&originalType=binary&ratio=1&rotation=0&showTitle=false&size=116750&status=done&style=none&taskId=u9a7cf356-5583-492e-9193-c43c88527f0&title=&width=1017.3333333333334" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652972938747-55423cbf-6587-4290-9e30-72e3da115af6.png#averageHue=%23f7f7f7&clientId=u0ead8153-855e-4&from=paste&height=386&id=u305633f8&originHeight=579&originWidth=1547&originalType=binary&ratio=1&rotation=0&showTitle=false&size=109189&status=done&style=none&taskId=u186ba132-d134-4643-bb5c-0e3871b43b5&title=&width=1031.3333333333333" alt="image.png"><br />接着  Thread-0就会park 阻塞<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652972990458-f25a1df9-5d99-4c1b-96ec-6559fa96bd4c.png#averageHue=%23f7f7f6&clientId=u0ead8153-855e-4&from=paste&height=387&id=u7a44d254&originHeight=580&originWidth=1560&originalType=binary&ratio=1&rotation=0&showTitle=false&size=136533&status=done&style=none&taskId=u04dac3b2-71a6-40aa-a625-5b58eb6d859&title=&width=1040" alt="image.png"></p><p><strong>接下来看signal流程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将等待时间最长的线程（如果存在）从该条件的等待队列移动到拥有锁的等待队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">                doSignal(first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//将first移除条件队列</span></span><br><span class="line">                <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)</span><br><span class="line">                    lastWaiter = <span class="literal">null</span>;</span><br><span class="line">                first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//transferForSignal将firrst转移到等待锁的队列</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                     (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * cas设置当前节点的waitStauts为1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入队列</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">        <span class="comment">//将前驱节点的状态改成-1 代表有责任唤醒下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>假设Thread-1唤醒Thread-0<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652980463373-f25b7968-a431-4f0e-b315-e658a4270ee4.png#averageHue=%23f6f6f6&clientId=u0ead8153-855e-4&from=paste&height=485&id=u570bd8a4&originHeight=727&originWidth=1544&originalType=binary&ratio=1&rotation=0&showTitle=false&size=139194&status=done&style=none&taskId=ub5ac7abd-0a1a-4e3a-a122-6f547ebfab8&title=&width=1029.3333333333333" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652980745484-9980a48f-54c3-44ea-ba94-b946b9271b45.png#averageHue=%23f5f5f5&clientId=u0ead8153-855e-4&from=paste&height=469&id=u9a99b3b2&originHeight=704&originWidth=1543&originalType=binary&ratio=1&rotation=0&showTitle=true&size=137224&status=done&style=none&taskId=ub53047b9-2406-4052-8620-b2a93534228&title=%E8%BF%9B%E5%85%A5%20ConditionObject%20%E7%9A%84%20doSignal%20%E6%B5%81%E7%A8%8B%EF%BC%8C%E5%8F%96%E5%BE%97%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%20Node%EF%BC%8C%E5%8D%B3%20Thread-0%20%E6%89%80%E5%9C%A8%20Node&width=1028.6666666666667" alt="进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node" title="进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652980772291-d8079b72-ecdb-4718-9002-7f69b9eb682d.png#averageHue=%23f7f7f7&clientId=u0ead8153-855e-4&from=paste&height=372&id=u1fad4a00&originHeight=558&originWidth=1578&originalType=binary&ratio=1&rotation=0&showTitle=true&size=129095&status=done&style=none&taskId=ud387efbb-e461-4c8b-b8f9-46c488f9400&title=%E6%89%A7%E8%A1%8C%20transferForSignal%20%E6%B5%81%E7%A8%8B%EF%BC%8C%E5%B0%86%E8%AF%A5%20Node%20%E5%8A%A0%E5%85%A5%20AQS%20%E9%98%9F%E5%88%97%E5%B0%BE%E9%83%A8%EF%BC%8C%E5%B0%86%20Thread-0%20%E7%9A%84%20waitStatus%20%E6%94%B9%E4%B8%BA%200%EF%BC%8CThread-3%20%E7%9A%84%0D%20waitStatus%20%E6%94%B9%E4%B8%BA%20-1&width=1052" alt="执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的 waitStatus 改为 -1" title="执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的 waitStatus 改为 -1"></p><p><a name="RAdza"></a></p><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>当读操作远远高于写操作时，这时候使用 读写锁 让 读-读 可以并发，提高性能。 类似于数据库中的 select …<br />from … lock in share mode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataContainer</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> Object data;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">     <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">r</span> <span class="operator">=</span> rw.readLock();</span><br><span class="line">     <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">w</span> <span class="operator">=</span> rw.writeLock();</span><br><span class="line">     <span class="keyword">public</span> Object <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">         log.debug(<span class="string">&quot;获取读锁...&quot;</span>);</span><br><span class="line">         r.lock();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             log.debug(<span class="string">&quot;读取&quot;</span>);</span><br><span class="line">             sleep(<span class="number">1</span>);</span><br><span class="line">             <span class="keyword">return</span> data;</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             log.debug(<span class="string">&quot;释放读锁...&quot;</span>);</span><br><span class="line">             r.unlock();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">         log.debug(<span class="string">&quot;获取写锁...&quot;</span>);</span><br><span class="line">         w.lock();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             log.debug(<span class="string">&quot;写入&quot;</span>);</span><br><span class="line">             sleep(<span class="number">1</span>);</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             log.debug(<span class="string">&quot;释放写锁...&quot;</span>);</span><br><span class="line">             w.unlock();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>读锁不支持条件变量 <br />重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待  <br /> 重入时降级支持：即持有写锁的情况下去获取读锁 </p><p><a name="BOVLN"></a></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>读写锁用的是同一个sync锁(aqs的子类)，因此等待队列、state也用的同一个</p><p>现在假设有两个线程t1、t2，t1要加写锁，t2加读锁</p><p>l ) t1成功上锁，流程与ReentrantLock加锁相比没有特殊之处，不同是写锁状态占了state的低16位，而读锁使用的是state的高16位。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653220859052-b9bac57e-3e71-4ef1-94b6-cef886e281fa.png#averageHue=%23e1eac4&clientId=ub17e8e3a-9055-4&from=paste&height=384&id=ud1003b47&originHeight=576&originWidth=933&originalType=binary&ratio=1&rotation=0&showTitle=false&size=141325&status=done&style=none&taskId=u42f02d98-b9cd-4938-9e75-73e40f5d420&title=&width=622" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">  sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">     <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">     <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">     <span class="comment">//写锁</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line">     <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">         <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">         <span class="comment">// Reentrant acquire</span></span><br><span class="line">         setState(c + acquires);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">         !compareAndSetState(c, c + acquires))</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">         setExclusiveOwnerThread(current);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2 ) t2执行r.lock，这时进入读锁的sync.acquireShared(1)流程，首先会进入tryAcquireShared流程。如果有写锁占据，那么tryAcquireShared返回-1表示失败<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653225812952-44993750-4d10-4c27-ba93-db7847cb5bb3.png#averageHue=%23e6f3c9&clientId=ub17e8e3a-9055-4&from=paste&height=569&id=u2e9e9b4f&originHeight=854&originWidth=1295&originalType=binary&ratio=1&rotation=0&showTitle=false&size=120519&status=done&style=none&taskId=uab94d398-cdee-4d3d-9a73-9e1f83667cc&title=&width=863.3333333333334" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">         sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">     &#125;   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">       <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">       <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">           getExclusiveOwnerThread() != current)</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> sharedCount(c);</span><br><span class="line">       <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">           r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">           compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">           <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">               firstReader = current;</span><br><span class="line">               firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">               firstReaderHoldCount++;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;</span><br><span class="line">               <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                   cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                   readHolds.set(rh);</span><br><span class="line">               rh.count++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br><span class="line">tryAcquireShared返回值表示:</span><br><span class="line">-<span class="number">1</span>表示失败</span><br><span class="line"><span class="number">0</span>表示成功，但后继节点不会继续唤醒</span><br><span class="line">正数表示成功，而且数值是还有几个后继节点需要唤醒，读写锁返回<span class="number">1</span></span><br><span class="line"></span><br><span class="line">这时tryAcquireShared返回-<span class="number">1</span> 执行doAcquireShared方法</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653225805086-14a075e3-8110-421e-b21d-c742195c4691.png#averageHue=%23f6f6ef&clientId=ub17e8e3a-9055-4&from=paste&height=500&id=u23edce0a&originHeight=750&originWidth=1552&originalType=binary&ratio=1&rotation=0&showTitle=false&size=141630&status=done&style=none&taskId=uab3e4edb-edd0-412c-ab19-89abdbb9d96&title=&width=1034.6666666666667" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续t3 r.lock,t4 w.lock<br />这种状态下，假设又有t3加读锁和t4加写锁，这期间t1仍然持有锁，就变成了下面的样子<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653225992674-05793ce4-344f-4ff3-b173-589ae2c830b7.png#averageHue=%23f6f6f1&clientId=ub17e8e3a-9055-4&from=paste&height=326&id=u8a7e2c4a&originHeight=489&originWidth=1545&originalType=binary&ratio=1&rotation=0&showTitle=false&size=113643&status=done&style=none&taskId=u8d1d1a08-db16-41fd-8e57-ece92b8637d&title=&width=1030" alt="image.png"><br />t1.unlock()<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653226218143-d29af746-7ebf-4c27-a4ef-28a184cf9498.png#averageHue=%23f6f6f2&clientId=ub17e8e3a-9055-4&from=paste&height=325&id=u91a32bbf&originHeight=487&originWidth=1562&originalType=binary&ratio=1&rotation=0&showTitle=false&size=98666&status=done&style=none&taskId=u8457dcec-c482-40af-9f1d-8c8e3b46c12&title=&width=1041.3333333333333" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">   sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">      <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (free)</span><br><span class="line">          setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">      setState(nextc);</span><br><span class="line">      <span class="keyword">return</span> free;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>解锁之后 会再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一  </p><p>这时 t2 已经恢复运行，接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// Record old head for check below</span></span><br><span class="line">        setHead(node);</span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653226764096-323a8c9a-031d-46f7-8f63-56a6a006ccc0.png#averageHue=%23f5f5f0&clientId=ub17e8e3a-9055-4&from=paste&height=393&id=ud3bbc83a&originHeight=589&originWidth=1536&originalType=binary&ratio=1&rotation=0&showTitle=false&size=115288&status=done&style=none&taskId=uf431852c-19e3-4566-8799-76a1526895e&title=&width=1024" alt="image.png">事情还没完，在 setHeadAndPropagate 方法内还会检查下一个节点是否是 shared，如果是则调用<br />doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒老二，这时 t3 在 doAcquireShared 内<br />parkAndCheckInterrupt() 处恢复运行</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653226831987-00a4e893-7e88-4f4f-be33-488e99df4ece.png#averageHue=%23f6f6f1&clientId=ub17e8e3a-9055-4&from=paste&height=417&id=uc3bc5a65&originHeight=626&originWidth=1548&originalType=binary&ratio=1&rotation=0&showTitle=false&size=111248&status=done&style=none&taskId=uac6f72a3-56d3-4457-a6be-a5aa24ad5a8&title=&width=1032" alt="image.png"><br /> 这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一  <br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653226846171-18886aa1-f21a-406d-9cc6-0a593020348d.png#averageHue=%23f7f7f2&clientId=ub17e8e3a-9055-4&from=paste&height=419&id=u586ee9ab&originHeight=629&originWidth=1588&originalType=binary&ratio=1&rotation=0&showTitle=false&size=113141&status=done&style=none&taskId=ue1a92728-3fd0-406c-95c3-5ceaf53eb18&title=&width=1058.6666666666667" alt="image.png"><br /> 这时 t3 已经恢复运行，接下来 t3 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点  <br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653226885140-b8d8002a-0b2e-4499-8101-f3b032a97acb.png#averageHue=%23e8f5ca&clientId=ub17e8e3a-9055-4&from=paste&height=505&id=u0c0ea77d&originHeight=757&originWidth=1546&originalType=binary&ratio=1&rotation=0&showTitle=false&size=148488&status=done&style=none&taskId=ud3c1e7f7-c9eb-43a9-9dd7-dd805cdbba2&title=&width=1030.6666666666667" alt="image.png"><br /> 下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点  </p><p><strong>t2 r.unlock，t3 r.unlock</strong><br />t2 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但由于计数还不为零  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">      <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">          <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">          <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">              firstReader = <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">else</span> </span><br><span class="line">              firstReaderHoldCount--;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;</span><br><span class="line">          <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">              rh = readHolds.get();</span><br><span class="line">          <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> rh.count;</span><br><span class="line">          <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">              readHolds.remove();</span><br><span class="line">              <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">          &#125;</span><br><span class="line">          --rh.count;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">          <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c - SHARED_UNIT;</span><br><span class="line">          <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">              <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">              <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">              <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">              <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>t3 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，这回计数为零了，进入 doReleaseShared() 将头节点从 -1 改为 0 并唤醒老二，即  <br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653227818832-ecea2de8-6a3f-429f-8053-77bf25edfc15.png#averageHue=%23f6f6ee&clientId=ub17e8e3a-9055-4&from=paste&height=528&id=u4c8c5c64&originHeight=792&originWidth=1541&originalType=binary&ratio=1&rotation=0&showTitle=false&size=151319&status=done&style=none&taskId=uc1793a48-1c1f-46fa-8852-e1c0a969e9c&title=&width=1027.3333333333333" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后 t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是老二，并且没有其他 竞争，tryAcquire(1) 成功，修改头结点，流程结束  <br />其实写锁就是独占锁 也就是独占模式 和reentrantLock走的同一套流程，(重写tryAcquire)<br />读锁时共享锁 共享模式。(重写tryAcquireShare)</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653227837583-852cf25d-6769-44bd-8b50-dd22e01d7575.png#averageHue=%23e6f3c8&clientId=ub17e8e3a-9055-4&from=paste&height=546&id=u73b0f094&originHeight=819&originWidth=1211&originalType=binary&ratio=1&rotation=0&showTitle=false&size=112813&status=done&style=none&taskId=ua9320c13-f8c2-43fa-80e8-e9e191dcb3f&title=&width=807.3333333333334" alt="image.png"><br><a name="kQoLr"></a></p><h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><p>该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataContainerStamped</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">DataContainerStamped</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.data = data;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> readTime)</span> &#123;</span><br><span class="line">     <span class="comment">//StampedLock应该是利用了偏向锁+乐观锁的概念,读读之间的加锁，不会频繁cas操作，只有当</span></span><br><span class="line">     <span class="comment">//有写锁加上时，才会锁升级成读锁</span></span><br><span class="line">     <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line">     log.debug(<span class="string">&quot;optimistic read locking...&#123;&#125;&quot;</span>, stamp);</span><br><span class="line">     sleep(readTime);</span><br><span class="line">     <span class="keyword">if</span> (lock.validate(stamp)) &#123;</span><br><span class="line">         log.debug(<span class="string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);</span><br><span class="line">         <span class="keyword">return</span> data;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 锁升级 - 读锁</span></span><br><span class="line">     log.debug(<span class="string">&quot;updating to read lock... &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         stamp = lock.readLock();</span><br><span class="line">         log.debug(<span class="string">&quot;read lock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">         sleep(readTime);</span><br><span class="line">         log.debug(<span class="string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);</span><br><span class="line">         <span class="keyword">return</span> data;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         log.debug(<span class="string">&quot;read unlock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">         lock.unlockRead(stamp);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> newData)</span> &#123;</span><br><span class="line">     <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">     log.debug(<span class="string">&quot;write lock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         sleep(<span class="number">2</span>);</span><br><span class="line">         <span class="built_in">this</span>.data = newData;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         log.debug(<span class="string">&quot;write unlock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">         lock.unlockWrite(stamp);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="iULxs"></a></p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量，用来限制能同时访问共享资源的线程上线。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="comment">// 1. 创建 semaphore 对象</span></span><br><span class="line">     <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">     <span class="comment">// 2. 10个线程同时运行</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">             <span class="comment">// 3. 获取许可</span></span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 semaphore.acquire();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">                 sleep(<span class="number">1</span>);</span><br><span class="line">                 log.debug(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                 <span class="comment">// 4. 释放许可</span></span><br><span class="line">                 semaphore.release();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;).start();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="abRXB"></a></p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>Semaphore内部同样有一个aqs同步器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">        NonfairSync(<span class="type">int</span> <span class="keyword">permits</span>) &#123;</span><br><span class="line">            <span class="comment">//sync的构造</span></span><br><span class="line">            <span class="built_in">super</span>(<span class="keyword">permits</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Sync(<span class="type">int</span> <span class="keyword">permits</span>) &#123;</span><br><span class="line">    setState(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Semaphore 有点像一个停车场，permits 就好像停车位数量，当线程获得了 permits 就像是获得了停车位，然后 停车场显示空余车位减一 刚开始，permits（state）为 3，这时 5 个线程来获取资源。（semaphore.acquire()）<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653361171453-dfdeff10-e74c-4419-b3b1-70e74979e53b.png#averageHue=%23e8f4c4&clientId=ue4f918ef-5f35-4&from=paste&height=363&id=u5284df3e&originHeight=545&originWidth=1008&originalType=binary&ratio=1&rotation=0&showTitle=false&size=92099&status=done&style=none&taskId=u9f34e6cd-af96-4e8b-ae6c-d58a110eaa3&title=&width=672" alt="image.png">·</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认调用非公平锁的tryAcquireShared</span></span><br><span class="line"> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nonfairTryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假设其中 Thread-1，Thread-2，Thread-4 cas 竞争成功，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列<br />park 阻塞。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653361205613-ece7be8f-3126-4654-96c9-dbbdf668e3a0.png#averageHue=%23f6f6f1&clientId=ue4f918ef-5f35-4&from=paste&height=185&id=u075478f9&originHeight=278&originWidth=1029&originalType=binary&ratio=1&rotation=0&showTitle=false&size=61288&status=done&style=none&taskId=ub0ce0286-a065-49c6-8d79-4e88abd1492&title=&width=686" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这时 Thread-4 释放了 permits，状态如下  (release方法)<br /> <img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653370720394-3433233e-cb48-45ec-9cbf-6895fa5f5a10.png#averageHue=%23f7f6f2&clientId=ue4f918ef-5f35-4&from=paste&height=192&id=u8359cd6f&originHeight=288&originWidth=1053&originalType=binary&ratio=1&rotation=0&showTitle=false&size=55152&status=done&style=none&taskId=u9ba2e77d-7891-4294-9177-bb94b97ced9&title=&width=702" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">     sync.releaseShared(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">         doReleaseShared();</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//唤醒队列中的节点</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">         <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">             <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">             <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                     <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                 unparkSuccessor(h);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                      !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                 <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 接下来 Thread-0 竞争成功 (doAcquireSharedInterruptibly方法 for循环执行)，permits 再次设置为 0，设置自己为 head 节点，断开原来的 head 节点，unpark 接 下来的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态  <br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653370835850-cc209624-b529-4384-8d90-d2bafa62835d.png#averageHue=%23e6f2c1&clientId=ue4f918ef-5f35-4&from=paste&height=229&id=u8751c0a8&originHeight=343&originWidth=1034&originalType=binary&ratio=1&rotation=0&showTitle=false&size=63556&status=done&style=none&taskId=u4842649d-b5fd-4b68-93ce-02d4f267c4a&title=&width=689.3333333333334" alt="image.png"></p><p><a name="Ei1vB"></a></p><h2 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h2><p> 用来进行线程同步协作，等待所有线程完成倒计时。 其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">     <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">         log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">         sleep(<span class="number">1</span>);</span><br><span class="line">         latch.countDown();</span><br><span class="line">     log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">     &#125;).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">         log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">         sleep(<span class="number">2</span>);</span><br><span class="line">         latch.countDown();</span><br><span class="line">         log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">     &#125;).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">         log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">         sleep(<span class="number">1.5</span>);</span><br><span class="line">         latch.countDown();</span><br><span class="line">         log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">     &#125;).start();</span><br><span class="line">     log.debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">     latch.await();</span><br><span class="line">     log.debug(<span class="string">&quot;wait end...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="BMmck"></a></p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>CountdownLatch内部同样维护一个aqs同步器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将aqs内部成员变量设置为指定值</span></span><br><span class="line"><span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);   </span><br><span class="line"></span><br><span class="line"><span class="comment">//每次countDown都会-1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            <span class="comment">//唤醒主线程await方法</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//倒计时未结束也就是state还未=0时 执行这个方法 进入阻塞队列 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="OhyJh"></a></p><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程执<br />行到某个需要“同步”的时刻调用 await() 方法进行等待，<strong>当等待的线程数满足『计数个数』时</strong>，继续执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">cb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>，()-&gt;&#123; <span class="comment">//当await的线程全部运行完后，就会执行后面的方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;线程1 线程2 finish....&quot;</span>);</span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;线程1开始..&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         cb.await(); <span class="comment">// 当个数不足时，等待</span></span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(<span class="string">&quot;线程1继续向下运行...&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;线程2开始..&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">     <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">2000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         cb.await(); <span class="comment">// 2 秒后，await线程个数够2，继续运行</span></span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(<span class="string">&quot;线程2继续向下运行...&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//CyclicBarrier可以重复使用 当await调用两次 计数  变成0后，又可以再次await 再恢复成2</span></span><br></pre></td></tr></table></figure><p><a name="pu5xT"></a></p><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p><a name="sNDOU"></a></p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync(Runnable runnable);</span><br><span class="line">CompletableFuture.runAsync(Runnable runnable, Executor executor);</span><br><span class="line"></span><br><span class="line">CompletableFuture.supplyAsync(Supplier supplier);</span><br><span class="line">CompletableFuture.supplyAsync(Supplier supplier, Executor executor)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过上面几个方法可以创建一个CompletableFuture</span></span><br><span class="line">  CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; start,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">&quot; exit,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).whenComplete((res, e) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;future01回调方法执行 ==》&quot;</span> + res + <span class="string">&quot;，线程id：&quot;</span> + Thread.currentThread().getId()+<span class="string">&quot;--&quot;</span>+e);</span><br><span class="line">        &#125;);    </span><br><span class="line">        System.out.println(<span class="string">&quot;run result-&gt;&quot;</span>+cf.get());<span class="comment">//阻塞</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main thread exit,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line"><span class="comment">//runAsync 方法接收的是 Runnable 的实例，意味着它没有返回值</span></span><br><span class="line"><span class="comment">//supplyAsync 方法对应的是有返回值的情况  不是callable 是一个供给型接口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">https:<span class="comment">//www.cnblogs.com/dtdx/p/14238516.html</span></span><br></pre></td></tr></table></figure><p><br />    <br><a name="yOxsG"></a></p><h4 id="回调-whenComplete、whenCompleteAsync"><a href="#回调-whenComplete、whenCompleteAsync" class="headerlink" title="回调 whenComplete、whenCompleteAsync"></a>回调 whenComplete、whenCompleteAsync</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//当CompletableFuture的计算结果完成，或者抛出异常的时候，可以执行特定的Action。主要是下面的方法：</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> Throwable&gt; action)</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> Throwable&gt; action)</span></span><br><span class="line"><span class="comment">//whenComplete：是执行当前任务的线程执行继续执行 whenComplete 的任务。</span></span><br><span class="line"><span class="comment">//whenCompleteAsync：是执行把 whenCompleteAsync 这个任务继续提交给线程池来进行执行。</span></span><br></pre></td></tr></table></figure><p><a name="nqKBp"></a></p><h4 id="继续执行-thenApply-thenAccept-thenRun"><a href="#继续执行-thenApply-thenAccept-thenRun" class="headerlink" title="继续执行 thenApply thenAccept thenRun"></a>继续执行 thenApply thenAccept thenRun</h4><p>thenApply 方法：当一个线程依赖另一个线程时，获取上一个任务返回的结果，并返回当前任务的返回值。</p><p>thenAccept方法：消费处理结果。接收任务的处理结果，并消费处理，无返回结果。</p><p>thenRun方法：只要上面的任务执行完成，就开始执行thenRun，只是处理完任务后，执行 thenRun的后续操作  <br />带有Async默认是异步执行的。这里所谓的异步指的是不在当前线程内执行。  thenRunAsync</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; future01 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;future01执行，线程id：&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;).thenRun(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;thenRun执行，无法获取上一步执行结果，无返回值&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(future01.get());</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; future02 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;future01执行，线程id：&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;).thenAccept((res) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;thenAccept，上一步执行结果: &quot;</span> + res +<span class="string">&quot;，无返回值&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(future02.get());</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Long&gt; future03 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;future03执行，线程id：&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;).thenApply((res) -&gt; &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;thenApply，上一步执行结果: &quot;</span> + res + <span class="string">&quot;，有返回值: &quot;</span> + i);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;); </span><br></pre></td></tr></table></figure><p><br />    <br><a name="hSKQJ"></a></p><h4 id="组合-两个都处理完成-thenCombine-thenAcceptBoth-runAfterBoth"><a href="#组合-两个都处理完成-thenCombine-thenAcceptBoth-runAfterBoth" class="headerlink" title="组合 两个都处理完成 thenCombine thenAcceptBoth runAfterBoth"></a>组合 两个都处理完成 thenCombine thenAcceptBoth runAfterBoth</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">thenCombine：组合两个future，获取两个future任务的返回结果，并返回当前任务的返回值</span><br><span class="line"></span><br><span class="line">thenAcceptBoth：组合两个future，获取两个future任务的返回结果，然后处理任务，没有返回值。</span><br><span class="line"></span><br><span class="line">runAfterBoth：组合两个future，不需要获取future的结果，只需两个future处理完任务后，处理该任务</span><br><span class="line">    CompletableFuture&lt;Void&gt; future03 = future01.runAfterBoth(future02, () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务3开始。。。&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; future04 = future01.thenAcceptBoth(future02, (f1, f2) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务4开始。。。之前的结果 &quot;</span>+f1+<span class="string">&quot;==&gt;&quot;</span>+f2);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Long&gt; future05 = future01.thenCombine(future02, (f1, f2) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务5开始。。。之前的结果 &quot;</span>+f1+<span class="string">&quot;==&gt;&quot;</span>+f2);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p><a name="FIQBW"></a></p><h4 id="组合-只需一个处理完成"><a href="#组合-只需一个处理完成" class="headerlink" title="组合 只需一个处理完成"></a>组合 只需一个处理完成</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">applyToEither：组合两个future，只需一个future任务的返回结果，并返回当前任务的返回值</span><br><span class="line"></span><br><span class="line">acceptEither：组合两个future，只需一个future任务的返回结果，然后处理任务，没有返回值。</span><br><span class="line"></span><br><span class="line">runAfterEither：组合两个future，不需要获取future的结果，只需一个future处理完任务后，处理该任务</span><br><span class="line">    </span><br><span class="line">CompletableFuture&lt;Void&gt; future03 = future01.runAfterEither(future02, () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务3开始。。。&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; future04 = future01.acceptEither(future02, (res) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务4开始。。。之前的结果 &quot;</span>+res);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Long&gt; future05 = future01.applyToEither(future02, (res) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务5开始。。。之前的结果 &quot;</span>+res);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p><a name="gVS3p"></a></p><h4 id="多任务-allOf-anyOf"><a href="#多任务-allOf-anyOf" class="headerlink" title="多任务 allOf anyOf"></a>多任务 allOf anyOf</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">allOf：等待所有任务完成 才会执行future03</span><br><span class="line"></span><br><span class="line">anyOf：只要有一个任务完成，都会执行future03</span><br><span class="line">    </span><br><span class="line">    CompletableFuture&lt;Void&gt; future03 = CompletableFuture.allOf(future01, future02);</span><br><span class="line">    CompletableFuture&lt;Object&gt; future04 = CompletableFuture.anyOf(future01, future02);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;anyOf 任意一个异步任务执行完成&quot;</span>+future04.get());</span><br><span class="line">    System.out.println(<span class="string">&quot;allOf 等待所有异步任务执行完成&quot;</span>+future03.get());</span><br></pre></td></tr></table></figure><p><a name="FTzgT"></a></p><h4 id="thenCompose-嵌套future"><a href="#thenCompose-嵌套future" class="headerlink" title="thenCompose 嵌套future"></a>thenCompose 嵌套future</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;CompletableFuture&lt;Double&gt;&gt; result = getUserDetail(userId)</span><br><span class="line">.thenApply(user -&gt; getCreditRating(user));  <span class="comment">// getCreditRating也是一个CompletableFuture 返回了一个嵌套的CompletableFuture </span></span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Double&gt; result = getUserDetail(userId)<span class="comment">//正确写法</span></span><br><span class="line">.thenCompose(user -&gt; getCreditRating(user));</span><br><span class="line">因此，规则就是-如果你的回调函数返回一个CompletableFuture，但是你想从CompletableFuture链中获取一个直接合并后的结果，这时候你可以使用thenCompose()。</span><br></pre></td></tr></table></figure><p><a name="APk33"></a></p><h4 id="异常处理-exceptionally-handle"><a href="#异常处理-exceptionally-handle" class="headerlink" title="异常处理 exceptionally handle"></a>异常处理 exceptionally handle</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">exceptionally()回调给你一个从原始Future中生成的错误恢复的机会。你可以在这里记录这个异常并返回一个默认值。</span><br><span class="line">CompletableFuture&lt;String&gt; maturityFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span>(age &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Age can not be negative&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(age &gt; <span class="number">18</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Adult&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Child&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).exceptionally(ex -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Oops! We have an exception - &quot;</span> + ex.getMessage());</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Unknown!&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">handle()从异常恢复，无论一个异常是否发生它都会被调用。</span><br><span class="line"><span class="type">Integer</span> <span class="variable">age</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; maturityFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(age &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Age can not be negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(age &gt; <span class="number">18</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Adult&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Child&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).handle((res, ex) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(ex != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Oops! We have an exception - &quot;</span> + ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Unknown!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="WiSUM"></a></p><h2 id="线程安全的集合类"><a href="#线程安全的集合类" class="headerlink" title="线程安全的集合类"></a><br />线程安全的集合类</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653467080405-e6911d43-68af-4f50-8858-fa086f83cdde.png#averageHue=%23c3a585&clientId=ub3e8bb93-efe7-4&from=paste&height=167&id=u3f777897&originHeight=251&originWidth=1484&originalType=binary&ratio=1&rotation=0&showTitle=false&size=68586&status=done&style=none&taskId=u29b813b4-e044-405f-904a-6dac33b62c1&title=&width=989.3333333333334" alt="image.png"><br /><strong>遗留的安全集合</strong> 方法都是由synchronized修饰的，效率不高，不推荐使用。</p><p><strong>修饰的安全集合</strong>,就是将原本不安全的集合类，传进去。通过装饰者模式，给每个线程不安全的集合类的方法，外层套一个synchronized。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653467335343-ed581bee-e318-4237-ae65-b6ae81b0c0ef.png#averageHue=%23f7f5ec&clientId=ub3e8bb93-efe7-4&from=paste&height=428&id=u272f51d1&originHeight=642&originWidth=932&originalType=binary&ratio=1&rotation=0&showTitle=false&size=322427&status=done&style=none&taskId=u70c1f023-23a4-4574-b1be-e72e6b7256c&title=&width=621.3333333333334" alt="image.png"></p><p><strong>JUC安全集合</strong><br><a name="Cg5Kp"></a></p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p><a name="oGkkv"></a></p><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认为 0</span></span><br><span class="line"><span class="comment">// 当初始化时, 为 -1</span></span><br><span class="line"><span class="comment">// 当扩容时, 为 -(1 + 扩容线程数)</span></span><br><span class="line"><span class="comment">// 当初始化或扩容完成后，为 下一次的扩容的阈值大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整个 ConcurrentHashMap 就是一个 Node[]</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash 表</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容时的 新 hash 表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ReservationNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为 treebin 的头节点, 存储 root 和 first</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeBin</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为 treebin 的节点, 存储 parent, left, right</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Node[] 中第 i 个 Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="title function_">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// cas 修改 Node[] 中第 i 个 Node 的值, c 为旧值, v 为新值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 直接修改 Node[] 中第 i 个 Node 的值, v 为新值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title function_">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i, Node&lt;K,V&gt; v)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel) <span class="comment">// Use at least as many bins</span></span><br><span class="line">         initialCapacity = concurrencyLevel; <span class="comment">// as estimated threads</span></span><br><span class="line">     <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + (<span class="type">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// tableSizeFor 仍然是保证计算出最终size的大小是 2^n, 即 16,32,64 ... 用于后面的hash计算</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= (<span class="type">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">     MAXIMUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);</span><br><span class="line">     <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">        <span class="comment">// spread 方法能确保返回结果是正数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">        <span class="comment">//table就是hash表</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            <span class="comment">//根据key的hashcode和tab长度取模 找到对应的头节点 赋给e</span></span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果头结点已经是要查找的 key (hashcode相同)</span></span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">                <span class="comment">//头结点的key等于当前的key </span></span><br><span class="line">                <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果找到的头节点e的hash值小于0代表该bin正在扩容(头节点是forwardingNode)</span></span><br><span class="line">            <span class="comment">//或者是treebin() 调用对应的find方法来查找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//正常遍历链表</span></span><br><span class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//onlyIfAbsent 是否不覆盖旧值 false表示覆盖新值</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">//不允许null的可以,hashmap就允许</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">//保证正整数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">// f是链表头节点</span></span><br><span class="line">        <span class="comment">// fh是链表头结点的 hash</span></span><br><span class="line">        <span class="comment">// i是链表在 table 中的下标</span></span><br><span class="line">        <span class="comment">// n是table的长度</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//初始化table  使用了cas </span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//找到key的hashcode对应下标处的头节点 如果不存在则创建一个</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//cas创建 如果其他线程占用了,cas失败了 就继续循环</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//帮忙扩容  (头结点的hash值表示正在扩容)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//帮忙之后 进入下一次循环</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">//进入这个else表示不在扩容，不在初始化，发生了hash冲突</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//此时加锁了 锁住了这个桶的头节点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//确认链表的头节点没有被移动</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//找到了相同的key值</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="comment">//覆盖掉旧值</span></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">//没有找到key 新增追加到链表尾</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//红黑树 (TreeBin 红黑树的头节点)</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// putTreeVal 会看 key 是否已经在树中, 是, 则返回对应的 TreeNode</span></span><br><span class="line">                        <span class="comment">//然后更新操作,否 做新增操作</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//代表有hash冲突</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果链表长度&gt;=树化阙值(8) 就会将链表转为红黑树</span></span><br><span class="line">                <span class="comment">//(先扩容 到64 如果还是大于8 就会转换)</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加 size 计数</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">       <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">               Thread.<span class="keyword">yield</span>(); </span><br><span class="line">           <span class="comment">//尝试将sizeCtl设置为-1 表示初始化table</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">               <span class="comment">//创建table,其他线程会在while()循环中yield 直至table创建</span></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                       <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                       Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                       table = tab = nt;</span><br><span class="line">                       sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   sizeCtl = sc;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> tab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><a name="WZSd3"></a></p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p><a name="qhXl3"></a></p><h2 id="控制线程的执行顺序"><a href="#控制线程的执行顺序" class="headerlink" title="控制线程的执行顺序"></a>控制线程的执行顺序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">t2runned</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!t2runned) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,name: <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Lock) &#123;</span><br><span class="line">        Log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        t2runned = <span class="literal">true</span>;</span><br><span class="line">        lock.notify();</span><br><span class="line">    &#125;,name: <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        </span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//park unpark</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    Log.debug(<span class="string">&quot;1&quot;</span><span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;,name: &quot;</span>t1<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">t1.start();</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">new Thread(() -&gt;&#123;</span></span><br><span class="line"><span class="string">    log.debug(&quot;</span><span class="number">2</span><span class="string">&quot;);</span></span><br><span class="line"><span class="string">    LockSupport.unpark(t1);</span></span><br><span class="line"><span class="string">&#125;, name: &quot;</span>t2<span class="string">&quot; ).start();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p><a name="ub2J4"></a></p><h2 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">waitNotify</span> &#123;</span><br><span class="line">    <span class="comment">//等待标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> flag;</span><br><span class="line">    <span class="comment">//循环次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopNumber;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">waitNotify</span><span class="params">(<span class="type">int</span> flag, <span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">        <span class="built_in">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, <span class="type">int</span> waitFlag， <span class="type">int</span> nextFlag)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(flag != waitFlag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printstackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.print(str);</span><br><span class="line">                    </span><br><span class="line">                    flag = nextFlag;</span><br><span class="line">                    <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span> &#123;</span><br><span class="line">    <span class="type">waitNotify</span> <span class="variable">wn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">waitNotify</span>(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">        wn.print(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">        wn.print(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">        wn.print(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Awaitsignal</span> <span class="variable">awaitsignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Awaitsignal</span>(loopNumber:<span class="number">5</span>);</span><br><span class="line">    <span class="type">condition</span> <span class="variable">a</span> <span class="operator">=</span> awaitsignal.newCondition();</span><br><span class="line">    <span class="type">condition</span> <span class="variable">b</span> <span class="operator">=</span> awaitsignal.newCondition();</span><br><span class="line">    <span class="type">condition</span> <span class="variable">c</span> <span class="operator">=</span> awaitsignal.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        awaitSignal.print(<span class="string">&quot;a&quot;</span>,a,b);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        awaitSignal.print(<span class="string">&quot;b&quot;</span>,b,c);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        awaitSignal.print(<span class="string">&quot;c&quot;</span>,c,a);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    </span><br><span class="line">    a.signal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Awaitsignal</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopNumber;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Awaitsignal</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//参数1打印内容.参数2进入哪一件休息室 参数3 下一间休息室</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str，Condition current，Condition next)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">             lock();</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 current.await();</span><br><span class="line">                 System.out.print(str);</span><br><span class="line">                 next.signal():</span><br><span class="line">             &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                 unlock();</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="Jf0oT"></a></p><h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p>简单的说，JMM定义了一套在多线程读写共享数据时（成员变量、数组)时，对数据的可见性、有序性、和原子性的规则和保障。</p><p><a name="UKALM"></a></p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>通过synchronized保证原子性。</p><p><a name="yen15"></a></p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651906901594-fe06ad0b-08ab-467c-a883-4be2822f2788.png#averageHue=%23eae6a4&clientId=u4d909540-ad5c-4&from=paste&height=410&id=u1679bc2d&originHeight=677&originWidth=1397&originalType=binary&ratio=1&rotation=0&showTitle=false&size=222435&status=done&style=none&taskId=uf9d61d4a-6952-4358-91fa-bfa20269023&title=&width=846.666617730654" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651906913481-167d670a-d4bf-4bed-8ac1-2c8561745dec.png#averageHue=%23f5f4e8&clientId=u4d909540-ad5c-4&from=paste&height=466&id=u754490d1&originHeight=769&originWidth=1736&originalType=binary&ratio=1&rotation=0&showTitle=false&size=380733&status=done&style=none&taskId=uc03cbcbe-f8e3-41a7-a3db-247bcc83fb5&title=&width=1052.1211513102473" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651906923102-88ac5a15-8425-4c74-a483-43acc2c60dbf.png#averageHue=%23f4f3e8&clientId=u4d909540-ad5c-4&from=paste&height=459&id=u83e8a6cd&originHeight=757&originWidth=1758&originalType=binary&ratio=1&rotation=0&showTitle=false&size=376718&status=done&style=none&taskId=u08430a0b-b635-43a0-a4aa-c2b5b6b537a&title=&width=1065.4544838729348" alt="image.png"><br />可以通过volatile关键字来解决这个问题<br><a name="lkN90"></a></p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条<strong>Lock前缀</strong>的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p><p>volatile的两条实现原则:<br /><strong>Lock前缀指令会引起处理器缓存回写到内存</strong><br /><strong>一个处理器的缓存回写到内存会导致其他处理器的缓存无效</strong></p><p><strong>volatile只能保证可见性，并不能保证原子性。</strong><br />synchronized两者都能保证，但是是重量级操作，性能相对较低。</p><p><strong>volatile也能禁止指令重排</strong></p><p><a name="WOLDL"></a></p><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p><strong>内存屏障:</strong></p><ul><li>在每个volatile写操作的前面插入一个StoreStore屏障。</li><li>在每个volatile写操作的后面插人一个StoreLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadStore屏障。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652350701634-70c3f373-1d0f-4b99-806c-19e9208836b5.png#averageHue=%23faf9f9&clientId=uda4812d7-352a-4&from=paste&height=366&id=u99e7679e&originHeight=549&originWidth=793&originalType=binary&ratio=1&rotation=0&showTitle=false&size=109204&status=done&style=none&taskId=u83c604dd-d5f7-4a92-930d-bd3d51b36f7&title=&width=528.6666666666666" alt="image.png"><br />StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作已经对任意处理器可见了。<br />这是因为StoreStore屏障将保障上面<strong>所有的普通写在volatile写之前刷新到主内存</strong></p><p>volatile写后面的StoreLoad屏障。此屏障的作用是避免<strong>volatile写与后面可能有的volatile读&#x2F;写操作重排序</strong>  </p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652350815190-de203eb1-6288-4674-abbe-d9786ab868dd.png#averageHue=%23f9f9f9&clientId=uda4812d7-352a-4&from=paste&height=310&id=u1243807d&originHeight=465&originWidth=803&originalType=binary&ratio=1&rotation=0&showTitle=true&size=104697&status=done&style=none&taskId=ueeb850b5-500d-4f33-9c9a-b05a75110e1&title=%E8%AF%BB&width=535.3333333333334" alt="读" title="读"><br /> LoadLoad屏障用来禁止处理器把上面的volatile读与下面的<strong>普通读</strong>重排序  <br /> LoadStore屏障用来禁止处理器把上面的volatile读与下面的<strong>普通写</strong>重排序。<br><a name="uo8po"></a></p><h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><p>对与单例模式 懒汉法实现，双重check方法，在多线程环境下可能会因为指令重排出现问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">singleton</span><span class="params">( )</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    Wpublic staticjsingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//实例没创建，才会进入内部的synchronized代码块</span></span><br><span class="line">    <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">        <span class="comment">//也许有其它线程已经创建实例，所以再判断一次</span></span><br><span class="line">            <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>( );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>INSTANCE &#x3D; new Singleton()对应的字节码为:<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651908545922-7404c5d2-1082-4ef3-b40d-3277c8ca2000.png#averageHue=%23fbfbfa&clientId=u4d909540-ad5c-4&from=paste&height=168&id=u0f2b15c0&originHeight=278&originWidth=1700&originalType=binary&ratio=1&rotation=0&showTitle=false&size=141189&status=done&style=none&taskId=u195b006a-1b89-4f0e-ab36-6b820849eac&title=&width=1030.3029707531223" alt="image.png"><br />其中47两步的顺序不是固定的，也许jvm 会优化为:先将引用地址赋值给INSTANCE变量后，再执行构造方法(因为对结果不会造成影响)，如果两个线程t1，t2按如下时间序列执行:</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651908596904-265538e6-b281-4725-b5ba-3a0668b8dd7c.png#averageHue=%23e3e0d8&clientId=u4d909540-ad5c-4&from=paste&height=204&id=u5a684652&originHeight=336&originWidth=1663&originalType=binary&ratio=1&rotation=0&showTitle=false&size=327332&status=done&style=none&taskId=u122e144d-a27c-43e2-ab2e-5ea8eff354a&title=&width=1007.8787296249661" alt="image.png"><br /><strong>这时t1还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么t2拿到的是将是一个未初始化完毕的单例。</strong></p><p><strong>对INSTANCE使用volatile修饰即可，可以禁用指令重排，但要注意在JDK 5以上的版本的volatile才会真正有效</strong></p><p><a name="X3uJ9"></a></p><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>happens-before规定了哪些写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结:</p><p><strong>线程对volatile变量的写，对接下来其它线程对该变量的读可见</strong></p><p><strong>线程解锁m之前对变量的写，对于接下来对m加锁的其它线程对该变量的读可见</strong><br /><code>也就是说线程1锁住M对象，然后对一个变量A做了修改，另一个需要锁M对象的锁在获取到锁之后,对于变量A的修改是可见的</code></p><p><strong>线程start前对变量的写，对该线程开始后对该变量的读可见</strong></p><p><strong>线程结束前对变量的写，对其它线程得知它结束后的读可见(比如其它线程调用t1.isAlive()或t1.join()等待它结束)</strong></p><p><strong>线程t1打断t2( interrupt)前对变量A的写，对于其他线程得知t2被打断后对变量A的读可见（通过t2.interrupted或 t2.isInterrupted)</strong></p><p><strong>对变量默认值(0, false,null)的写，对其它线程对该变量的读可见</strong></p><p><a name="u8zRV"></a></p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS即Compare and Swap，它体现的一种乐观锁的思想，比如多个线程要对一个共享的整型变量执行+1操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要不断尝试</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span>旧值=共享变量;<span class="comment">//比如拿到了当前值0</span></span><br><span class="line">    <span class="type">int</span>结果=旧值+<span class="number">1</span>;<span class="comment">//在旧值О的基础上增加1，正确结果是1</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这时候如果别的线程把共享变量改成了5，本线程的正确结果1就作废了，这时候compareAndSwap返回false，重新尝试，直到:compareAndSwap返回true，表示我本线程做修改的同时，别的线程没有干扰</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//旧值会先和共享变量比较  相同时才会返回true，然后将结果更新到共享变量上。</span></span><br><span class="line">    <span class="keyword">if</span>(compareAndSwap (旧值，结果))&#123;</span><br><span class="line">        <span class="comment">//成功，退出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>获取共享变量时，为了保证该变量的可见性，需要使用volatile修饰</strong>。结合CAS和volatile可以实现无锁并发，适用于竞争不激烈、多核CPU的场景下。|<br />因为没有使用synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一<br />但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</p><p>juc (java.util.concurrent）中提供了原子操作类，可以提供线程安全的操作，例如: AtomicInteger、AtomicBoolean等，它们底层就是采用<strong>CAS技术+volatile</strong>来实现的。</p><p><a name="aIJC2"></a></p><h3 id="LongAdder-原子累加器"><a href="#LongAdder-原子累加器" class="headerlink" title="LongAdder 原子累加器"></a>LongAdder 原子累加器</h3><p>LongAdder累计相比于AtomicInteger效率提升很大。</p><p>性能提升的原因很简单，就是在有竞争时，设置多个累加单元，Therad-0累加Cel[0]，而Thread-l 累加Cell[1]..最后将结果汇总。这样它们在累加时操作的不同的Cell变量，因此减少了CAS重试失败，从而提高性能。</p><p><strong>原理</strong><br />LongAdder类有几个关键域</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//累加单元数组，懒惰初始化</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> cell[] cells;</span><br><span class="line"><span class="comment">//基础值，如果没有竞争，则用cas累加这个域</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> base;</span><br><span class="line"><span class="comment">//在 cells 创建或扩容时，置为1，表示加锁 (cas锁)</span></span><br><span class="line"><span class="keyword">transient</span> volatileiit cellsBusy;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要用于实践！！！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockCas</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (state.compareAndSet(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">         log.debug(<span class="string">&quot;unlock...&quot;</span>);</span><br><span class="line">         state.set(<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>原理之伪共享</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防止缓存行伪共享</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line"> <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line"> Cell(<span class="type">long</span> x) &#123; value = x; &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 最重要的方法, 用来 cas 方式进行累加, prev 表示旧值, next 表示新值</span></span><br><span class="line"> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">cas</span><span class="params">(<span class="type">long</span> prev, <span class="type">long</span> next)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="built_in">this</span>, valueOffset, prev, next);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 省略不重要代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>缓存和内存的速度对比<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652628866291-5d1105e3-d155-4e54-86a7-70fe2b61455a.png#averageHue=%23f9f8f8&clientId=ua41d68fc-b28c-4&from=paste&height=664&id=ueea74552&originHeight=996&originWidth=1017&originalType=binary&ratio=1&rotation=0&showTitle=false&size=155123&status=done&style=none&taskId=uc43a428c-6b87-4c22-b74a-24668a6ce2d&title=&width=678" alt="image.png"><br />因为 CPU 与 内存的速度差异很大，需要靠预读数据至缓存来提升效率。 而缓存以缓存行为单位，每个缓存行对应着一块内存，一般是 64 byte（8 个 long） <br />缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中 <br />CPU 要保证数据的一致性，如果某个 CPU 核心更改了数据，其它 CPU 核心对应的整个缓存行必须失效</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652629186783-edc71493-757b-422b-ac3d-772a379cd05e.png#averageHue=%23dee8b4&clientId=ua41d68fc-b28c-4&from=paste&height=423&id=ud6be82f9&originHeight=634&originWidth=1549&originalType=binary&ratio=1&rotation=0&showTitle=false&size=152223&status=done&style=none&taskId=u3ba51c2d-7758-4b06-a692-e5d11abce4d&title=&width=1032.6666666666667" alt="image.png"><br />因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因<br />此缓存行可以存下 2 个的 Cell 对象。这样问题来了：<br />Core-0 要修改 Cell[0]<br />Core-1 要修改 Cell[1]<br />无论谁修改成功，都会导致对方 Core 的缓存行失效，比如 Core-0 中 Cell[0]&#x3D;6000, Cell[1]&#x3D;8000 要累加<br />Cell[0]&#x3D;6001, Cell[1]&#x3D;8000 ，这时会让 Core-1 的缓存行失效  这样就会影响效率。</p><p>@sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的前后各增加 128 字节大小的<br />padding，从而让 CPU 将对象预读至缓存时占用不同的缓存行，这样，<strong>不会造成对方缓存行的失效</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">     <span class="comment">// as 为累加单元数组</span></span><br><span class="line">     <span class="comment">// b 为基础值</span></span><br><span class="line">     <span class="comment">// x 为累加值</span></span><br><span class="line">     Cell[] as; <span class="type">long</span> b, v; <span class="type">int</span> m; Cell a;</span><br><span class="line">     <span class="comment">// 进入 if 的两个条件</span></span><br><span class="line">     <span class="comment">// 1. as 有值, 表示已经发生过竞争, 进入 第二个if</span></span><br><span class="line">     <span class="comment">// 2. cas 给 base 累加时失败了, 表示 base 发生了竞争, 进入 if</span></span><br><span class="line">     <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">         <span class="comment">// uncontended 表示 cell 没有竞争</span></span><br><span class="line">         <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">         <span class="keyword">if</span> (</span><br><span class="line">             <span class="comment">// as 还没有创建</span></span><br><span class="line">             as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">             <span class="comment">// 当前线程对应的 cell 还没有创建</span></span><br><span class="line">             (a = as[getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">             <span class="comment">// cas 给当前线程的 cell 累加失败 uncontended=false ( a 为当前线程的 cell )</span></span><br><span class="line">             !(uncontended = a.cas(v = a.value, v + x))</span><br><span class="line">             ) &#123;</span><br><span class="line">             <span class="comment">// 进入 cell 数组创建、cell 创建的流程</span></span><br><span class="line">             longAccumulate(x, <span class="literal">null</span>, uncontended);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652629906336-b932fde5-f2e8-46fc-9955-88d3d5d84515.png#averageHue=%23fcfcdd&clientId=ua41d68fc-b28c-4&from=paste&height=298&id=uc9ed4230&originHeight=447&originWidth=1451&originalType=binary&ratio=1&rotation=0&showTitle=false&size=107835&status=done&style=none&taskId=u8145646b-0368-4657-89cc-d54cf5d6d95&title=&width=967.3333333333334" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">longAccumulate</span><span class="params">(<span class="type">long</span> x, LongBinaryOperator fn,</span></span><br><span class="line"><span class="params">                             <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line">     <span class="type">int</span> h;</span><br><span class="line">     <span class="comment">// 当前线程还没有对应的 cell, 需要随机生成一个 h 值用来将当前线程绑定到 cell</span></span><br><span class="line">     <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 初始化 probe</span></span><br><span class="line">         ThreadLocalRandom.current();</span><br><span class="line">         <span class="comment">// h 对应新的 probe 值, 用来对应 cell</span></span><br><span class="line">         h = getProbe();</span><br><span class="line">         wasUncontended = <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// collide 为 true 表示需要扩容</span></span><br><span class="line">     <span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         Cell[] as; Cell a; <span class="type">int</span> n; <span class="type">long</span> v;</span><br><span class="line">         <span class="comment">// 已经有了 cells</span></span><br><span class="line">         <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line">                 <span class="comment">// 为 cellsBusy 加锁, 创建 cell, cell 的初始累加值为 x</span></span><br><span class="line">                 <span class="comment">// 成功则 break, 否则继续 continue 循环</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 有竞争, 改变线程对应的 cell 来重试 cas</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)</span><br><span class="line">                 wasUncontended = <span class="literal">true</span>;</span><br><span class="line">             <span class="comment">// cas 尝试累加, fn 配合 LongAccumulator 不为 null, 配合 LongAdder 为 null</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="comment">//如果 cells 长度已经超过了最大长度(CPU核心数), 或者已经扩容, </span></span><br><span class="line">             <span class="comment">//改变线程对应的 cell 来重试 cas</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                 collide = <span class="literal">false</span>;</span><br><span class="line">             <span class="comment">// 确保 collide 为 false 进入此分支, 就不会进入下面的 else if 进行扩容了</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                 collide = <span class="literal">true</span>;</span><br><span class="line">             <span class="comment">// 加锁</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">             <span class="comment">// 加锁成功, 扩容</span></span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 改变线程对应的 cell</span></span><br><span class="line">             h = advanceProbe(h);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 还没有 cells, 尝试给 cellsBusy 加锁</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">             <span class="comment">// 加锁成功, 初始化 cells, 最开始长度为 2, 并填充一个 cell</span></span><br><span class="line">             <span class="comment">// 成功则 break;</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 上两种情况失败, 尝试给 base 累加 如果再失败 就无法执行break 再次循环</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652630480269-24cb7e01-5889-4b6c-a3d1-b4dbd53e15dd.png#averageHue=%23fcfcdd&clientId=ua41d68fc-b28c-4&from=paste&height=217&id=ueaf7f225&originHeight=325&originWidth=1426&originalType=binary&ratio=1&rotation=0&showTitle=false&size=68742&status=done&style=none&taskId=u85ad2aad-94af-4900-8de0-d3c3e5a36d0&title=&width=950.6666666666666" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652631025218-43cbe378-6e9e-47bc-adcd-0809415519bf.png#averageHue=%23fcfcdd&clientId=ua41d68fc-b28c-4&from=paste&height=251&id=u4f25057f&originHeight=377&originWidth=1390&originalType=binary&ratio=1&rotation=0&showTitle=false&size=58980&status=done&style=none&taskId=u3b8d29d8-cd70-4e62-8910-6af21652a62&title=&width=926.6666666666666" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652631102454-34f02836-d3a5-4087-a26c-46aa8575fb1d.png#averageHue=%23fcfcdd&clientId=ua41d68fc-b28c-4&from=paste&height=325&id=uf13ac630&originHeight=488&originWidth=1407&originalType=binary&ratio=1&rotation=0&showTitle=false&size=103587&status=done&style=none&taskId=uea924691-3850-4654-b6bf-73cb07f4cf0&title=&width=938" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">     Cell[] as = cells; Cell a;</span><br><span class="line">     <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> base;</span><br><span class="line">     <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">             <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">             sum += a.value;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="mDuvU"></a></p><h2 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h2><p>Java HotSpot虚拟机中，每个对象都有对象头（包括class指针和Mark Word) 。Mark Word平时存储这个对象的哈希码、分代年龄，当加锁时，这些信息就根据情况被替换为标记位、线程锁记录指针、重量级锁指针、线程ID等内容。<br><a name="MnfKi"></a></p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652187200050-747a4d9a-3ac8-4fe4-980b-d9df09fa674e.png#averageHue=%23e4e5a1&clientId=ub2cb5786-dc2a-4&from=paste&height=303&id=u4a1fc741&originHeight=454&originWidth=870&originalType=binary&ratio=1&rotation=0&showTitle=false&size=210819&status=done&style=none&taskId=ud9561da1-d0e7-4e9b-89e2-baf4fe5e81a&title=&width=580" alt="image.png"><br />让锁记录中Object reference指向锁对象，并尝试用cas替换Object的Mark Word，<br />也会将Mark Word的值存入锁记录（lock record）。 <code>lock record 后面的 00 表示轻量级锁 01表示正常状态 前面30位表示锁记录地址</code></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652187357049-ba4c587d-f239-4ffe-a6e3-1de32cced6ae.png#averageHue=%23dcdc9b&clientId=ub2cb5786-dc2a-4&from=paste&height=313&id=ubd9a72d4&originHeight=469&originWidth=946&originalType=binary&ratio=1&rotation=0&showTitle=true&size=249260&status=done&style=none&taskId=ufe972293-e9ed-42f7-b019-108d6f6f023&title=%E5%8A%A0%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E4%B9%8B%E5%90%8E&width=630.6666666666666" alt="加轻量级锁之后" title="加轻量级锁之后"><br />如果cas 失败，有两种情况</p><ul><li>如果是其它线程已经持有了该Object的轻量级锁，这时表明有竞争，进入锁膨胀过程</li><li>如果是自己执行了synchronized<strong>锁重入</strong>，那么再添加一条Lock Recorrd 作为重入的计数</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652187543586-c1915fd0-6d07-4b2f-ab08-430efdcaaaeb.png#averageHue=%23dddd9b&clientId=ub2cb5786-dc2a-4&from=paste&height=367&id=uc04c8646&originHeight=550&originWidth=891&originalType=binary&ratio=1&rotation=0&showTitle=false&size=331577&status=done&style=none&taskId=u5566ceb2-7a14-48f0-a4bc-3ccb8c86edc&title=&width=594" alt="image.png"></p><p>当退出synchronized代码块（解锁时）如果有取值为null的锁记录，表示有重入，这时重置锁记录，表示<br />重入计数减一。</p><p>当退出synchronized代码块（解锁时）锁记录的值不为null，这时使用cas将Mark Word 的值恢复给对象头</p><ul><li>成功，则解锁成功</li><li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651916739005-675c8ac0-7490-4cda-abde-6c8bc5eeb562.png#averageHue=%23f8f7f7&clientId=u4d909540-ad5c-4&from=paste&height=777&id=u3606bc88&originHeight=1282&originWidth=905&originalType=binary&ratio=1&rotation=0&showTitle=false&size=236980&status=done&style=none&taskId=u8ff03b52-0b9d-44be-8da7-75689953a9f&title=&width=548.4848167832798" alt="image.png"><br><a name="QMYW6"></a></p><h3 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h3><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻<br />量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p><ul><li>为Object对象申请 Monitor锁，让object指向重量级锁地址</li><li>然后自己进入Monitor的EntryList BLOCKED</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652231751456-3a19835d-a249-460f-92ae-c2a1fad65a43.png#averageHue=%23e3e8b4&clientId=u986fdba0-2901-4&from=paste&height=207&id=u3dd7e676&originHeight=311&originWidth=924&originalType=binary&ratio=1&rotation=0&showTitle=false&size=136386&status=done&style=none&taskId=ufd513d7f-6601-4497-8b0a-eea0c2c873e&title=&width=616" alt="image.png"><br />当Thread-0退出同步块解锁时，使用cas将Mark Word 的值恢复给对象头，会失败。这时会进入重量级解锁流程，即按照Monitor地址找到Monitor对象，设置Owner为null，唤醒EntryList中 BLOCKED线程。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651917159175-01d5800b-9d75-4278-8b57-f85ad1659b71.png#averageHue=%23f8f6f6&clientId=u4d909540-ad5c-4&from=paste&height=689&id=u173746e5&originHeight=1137&originWidth=908&originalType=binary&ratio=1&rotation=0&showTitle=false&size=215612&status=done&style=none&taskId=uc56ab351-eda1-410e-9567-51075472dc7&title=&width=550.3029984963736" alt="image.png"><br><a name="G2Bf4"></a></p><h3 id="重量级锁的优化"><a href="#重量级锁的优化" class="headerlink" title="重量级锁的优化"></a>重量级锁的优化</h3><p><a name="tY10t"></a></p><h4 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h4><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退<br />出了同步块，释放了锁），这时当前线程就可以**避免阻塞 减少上下文切换**。</p><p>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能<br />性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</p><p>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</p><p>自旋成功<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651917371100-4cc26771-5c62-4c62-9941-145c70d6e7af.png#averageHue=%23f5f4f4&clientId=u4d909540-ad5c-4&from=paste&height=661&id=u29f33815&originHeight=1091&originWidth=1621&originalType=binary&ratio=1&rotation=0&showTitle=false&size=215501&status=done&style=none&taskId=u53d262f9-efc8-4c3c-8fd6-83c42798683&title=&width=982.4241856416537" alt="image.png"><br />自旋失败<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651917379646-6e0109e8-bcee-4326-b894-d977faa0d175.png#averageHue=%23f4f4f3&clientId=u4d909540-ad5c-4&from=paste&height=613&id=u3dc6bedb&originHeight=1012&originWidth=1638&originalType=binary&ratio=1&rotation=0&showTitle=false&size=204612&status=done&style=none&taskId=u697f51a6-9611-44f0-a524-b21e1021f26&title=&width=992.7272153491849" alt="image.png"><br><a name="qkABq"></a></p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。Java 6 中引入了偏向锁<br />来做进一步优化：只有第一次使用 CAS 将<strong>线程 ID</strong> 设置到对象的 Mark Word 头(不是设置锁记录地址了)，之后发现这个线程 ID是自己的就表示没有竞争，不用重新 CAS。 </p><ul><li>撤销偏向需要将持锁线程升级为轻量级锁，这个过程中所有线程需要暂停（STW）</li><li>访问对象的 hashCode 也会撤销偏向锁 <ul><li>因为hashCode本来是存到mark里的，然后由于加锁到了线程中，此时其他对象想获取这个对象的hashcode就拿不到了。</li></ul></li><li>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，</li><li>重偏向会重置对象的 Thread ID</li><li>撤销偏向和重偏向都是批量进行的，以类为单位</li><li>如果撤销偏向到达某个阈值，整个类的所有对象都会变为不可偏向的</li><li>可以主动使用 -XX:-UseBiasedLocking 禁用偏向锁</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652337060162-a0fcea0d-a450-4433-93a6-65b0d9f33e98.png#averageHue=%23eaeee7&clientId=uda4812d7-352a-4&from=paste&height=413&id=u55a4105c&originHeight=620&originWidth=1522&originalType=binary&ratio=1&rotation=0&showTitle=false&size=449961&status=done&style=none&taskId=u11a72a2e-02a2-4b63-9698-9280efc6a4a&title=&width=1014.6666666666666" alt="image.png"><br />一个对象创建时：</p><ul><li>如果开启了偏向锁（默认开启），那么对象创建后，markword值为0x05即最后3位为101,这时它的</li></ul><p>thread、epoch、age都为0。</p><ul><li>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加VM参数- XX:BiasedLockingStartupDelay&#x3D;g来禁用延迟。</li><li>如果没有开启偏向锁，那么对象创建后，markword值为Ox01即最后3位为00l,这时它的hashcode、age</li></ul><p>都为0，第一次用到hashcode时才会赋值。synchronized<br><a name="cAAU1"></a></p><h3 id="其它优化"><a href="#其它优化" class="headerlink" title="其它优化"></a>其它优化</h3><ul><li>减少上锁时间</li><li>减少锁的粒度</li><li>锁粗化<ul><li>多次循环进入同步块不如同步块内多次循环</li></ul></li><li>锁消除<ul><li>JVM 会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候就会被即时编译器忽略掉所有同步操作</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;
&lt;a name=&quot;GJCOp&quot;&gt;&lt;/a&gt;
# disruptor
&lt;a name=&quot;v7F26&quot;&gt;&lt;/a&gt;
# A进程和线程
&lt;a name=&quot;AoAR9&quot;&gt;&lt;/a&gt;
## 进程
我们编写</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Mysql</title>
    <link href="http://example.com/2023/05/12/Mysql/"/>
    <id>http://example.com/2023/05/12/Mysql/</id>
    <published>2023-05-12T02:22:13.322Z</published>
    <updated>2023-06-09T06:01:44.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一条sql语句是如何执行的"><a href="#一条sql语句是如何执行的" class="headerlink" title="一条sql语句是如何执行的"></a>一条sql语句是如何执行的</h1><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648093341473-68f1e895-bb41-45cb-9b0e-cb0d7797a3e7.png#averageHue=%23ecefe2&clientId=ub35db475-a524-4&from=paste&id=ub86e15fd&originHeight=1440&originWidth=1920&originalType=url&ratio=1&rotation=0&showTitle=true&size=609051&status=done&style=none&taskId=udd5444c6-42b3-4ee3-b7f0-c6b67a2ffc1&title=Mysql%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E5%9B%BE" alt="Mysql基本架构图" title="Mysql基本架构图"><br>MySQL 可以分为 Server 层和存储引擎层两部分</p><p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p><p>也就是说，你执行 create table 建表的时候，如果不指定引擎类型，默认使用的就是 InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在 create table 语句中使用 engine&#x3D;memory, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同。</p><p>从图中不难看出，不同的存储引擎共用一个 Server 层，也就是从连接器到执行器的部分。</p><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h$ip <span class="operator">-</span>P$port <span class="operator">-</span>u$<span class="keyword">user</span> <span class="operator">-</span>p</span><br></pre></td></tr></table></figure><p>输完命令之后，你就需要在交互对话里面输入密码。虽然密码也可以直接跟在 -p 后面写在命令行中，但这样可能会导致你的密码泄露。如果你连的是生产服务器，强烈建议你不要这么做。</p><p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p><ul><li>如果用户名或密码不对，你就会收到一个”<strong>Access denied for user</strong>“的错误，然后客户端程序结束执行。</li><li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li><li></li></ul><p>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到它。文本中这个图是 show processlist 的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648100906726-b843b434-66a0-4c16-923d-149c872f5402.png#averageHue=%23060208&clientId=ub35db475-a524-4&from=paste&id=uec2e5d2a&originHeight=163&originWidth=875&originalType=url&ratio=1&rotation=0&showTitle=false&size=27260&status=done&style=none&taskId=u34b2b0d5-b675-4b6c-a3b8-99d595321e3&title=" alt="image.png"><br>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 <strong>wait_timeout <strong>控制的，默认值是 8 小时。如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒：</strong> Lost connection to MySQL server during query</strong>。这时候如果你要继续，就需要重连，然后再执行请求了。</p><p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p><p>但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p><p>怎么解决这个问题呢？你可以考虑以下两种方案。</p><ul><li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ul><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>连接建立完成后，你就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。</p><p>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。</p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p><p><strong>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</strong></p><p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p><p>好在 MySQL 也提供了这种“按需使用”的方式。你可以将参数 <strong>query_cache_type</strong> 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> SQL_CACHE <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>；</span><br></pre></td></tr></table></figure><p>需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。</p><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。</p><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。</p><p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。</p><p>MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p><p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。如果你的语句不对，就会收到“<strong>You have an error in your SQL syntax</strong>”的错误提醒，比如下面这个语句 select 少打了开头的字母“s”。</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p><p>比如你执行下面这样的语句，这个语句是执行两个表的 join：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">using</span>(ID) <span class="keyword">where</span> t1.c<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> t2.d<span class="operator">=</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure><ul><li>既可以先从表 t1 里面取出 c&#x3D;10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</li><li>也可以先从表 t2 里面取出 d&#x3D;20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。</li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p><p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，没关系，我会在后面的文章中单独展开说明优化器的内容</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p><p>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 (在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限)。</p><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p><p>比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p><ul><li>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ul><p>至此，这个语句就执行完成了。</p><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p><p>你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p><p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。我们后面会专门有一篇文章来讲存储引擎的内部机制，里面会有详细的说明。</p><p>mysql分为service层和存储层，存储引擎层是插件式的，innodb是默认的存储引擎。<br>service层分为连接器、分析器、优化器、执行器<br>客户端和mysql服务器建立tcp连接，然后验证用户密码、权限之后，连接成功，会查询缓存(8之后移除)，没有命中就开始执行语句，先经过分析器 词法分析 知道要做什么、语法分析、检测是否符合mysql规则，然后优化器，对使用那个索引，多表关联决定各个表的执行顺序</p><h1 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h1><p><code>只要我们写的是DML语句（insert,update,delete,create）等等，那么我们在数据库服务端执行的时候就会涉及到 redo log(重做日志) 和 binlog(归档日志) 两个日志文件的变动。</code></p><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><h3 id="WAL技术"><a href="#WAL技术" class="headerlink" title="WAL技术"></a>WAL技术</h3><p><strong>MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。</strong><br>在 MySQL 里有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。</p><p>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到日志里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p><p><code>redo log是一个特定的区域，写入操作是顺序写，非常快，而将数据刷新到磁盘是随机io，比较慢，所以要先写入redo log。 </code><br><code>WAL操作这样可以避免每次更新都要通过磁盘随机 IO 定位到记录位置。 将改动以顺序 IO 写到 redo log。可以使用组提交来批量更新.</code></p><p>InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648108055998-29f22c92-5ea3-442e-9fdc-a5bb73578294.png#averageHue=%23f3f0e9&clientId=ub35db475-a524-4&from=paste&id=ub0653dee&originHeight=856&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=230615&status=done&style=none&taskId=u4fa0be29-3fc3-491d-8a98-4028c4e8501&title=" alt="image.png">write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，<strong>这时候不能再执行新的更新，得停下来先擦掉一些记录</strong>，把 checkpoint 推进一下。</p><p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 <strong>crash-safe</strong>。<br><code>redo log 是 InnoDB引擎所特有的，所以我们如果再使用InnoDB引擎创建表时，如果数据库发生异常重启，之前提交的记录都不会丢失。 InnoDB正因为有了 redo log(重做日志)，才有了 crash-safe 的能力（即使mysql服务宕机，也不会丢失数据的能力）</code>。</p><p>** redo log 只会记录未刷盘的日志，已经刷入磁盘的数据都会从 redo log 这个有限大小的日志文件里删除 （猜测后台有线程）**</p><h3 id="redo-log-的写入机制"><a href="#redo-log-的写入机制" class="headerlink" title="redo log 的写入机制"></a>redo log 的写入机制</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1650877429762-363312e7-1539-40de-9cab-ac46d3c8e06c.png#averageHue=%23ecebd6&clientId=u84cf85c6-a1db-4&from=paste&id=ue760740b&originHeight=639&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=true&size=59527&status=done&style=none&taskId=ubb09edc4-d7a5-47b0-80c5-4fa65d36482&title=MySQL%20redo%20log%20%E5%AD%98%E5%82%A8%E7%8A%B6%E6%80%81" alt="MySQL redo log 存储状态" title="MySQL redo log 存储状态"><br>这三种状态分别是：</p><ol><li>存在 redo log buffer 中，物理上是在 MySQL 进程内存中，就是图中的红色部分；</li><li>写到磁盘 (write)，但是没有持久化（fsync)，物理上是在文件系统的 page cache 里面，也就是图中的黄色部分；</li><li>持久化到磁盘，对应的是 hard disk，也就是图中的绿色部分。</li></ol><p>日志写到 redo log buffer 是很快的，wirte 到 page cache 也差不多，但是持久化到磁盘的速度就慢多了。<br>为了控制 redo log 的写入策略，InnoDB 提供了 <strong>innodb_flush_log_at_trx_commit</strong> 参数，它有三种可能取值：</p><ol><li>设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;</li><li>设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘；</li><li>设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。</li></ol><p>InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。<br><code>与binlog不同，binlog是每个线程都有一个binlog cache，而redo log是多个线程共用一个redo log buffer。</code><br>事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的，这些 redo log 也会被后台线程一起持久化到磁盘。也就是说，<strong>一个没有提交的事务的 redo log，也是可能已经持久化到磁盘的</strong>。</p><p>除了后台线程每秒一次的轮询操作外，还有两种场景会让一个没有提交的事务的 redo log 写入到磁盘中。</p><ol><li>一种是，redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动写盘。注意，由于这个事务并没有提交，所以这个写盘动作只是 write，而没有调用 fsync，也就是只留在了文件系统的 page cache。<code>innodb_log_buffer_size 决定 innodb 重做日志缓存池的大小,默认是 8MB</code></li><li>另一种是，并行的事务提交的时候，顺带将这个事务的 redo log buffer 持久化到磁盘。假设一个事务 A 执行到一半，已经写了一些 redo log 到 buffer 中，这时候有另外一个线程的事务 B 提交，如果 innodb_flush_log_at_trx_commit 设置的是 1，那么按照这个参数的逻辑，事务 B 要把 redo log buffer 里的日志全部持久化到磁盘。这时候，就会带上事务 A 在 redo log buffer 里的日志一起持久化到磁盘。</li></ol><p><code>如果把 innodb_flush_log_at_trx_commit 设置成 1，那么 redo log 在 prepare 阶段就要持久化一次，</code></p><p>通常我们说 MySQL 的“双 1”配置，指的就是 sync_binlog 和 innodb_flush_log_at_trx_commit 都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是 redo log（prepare 阶段），一次是 binlog。</p><h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜,redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。</p><p>因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。<br><code>binlog是追加写，crash时不能判定binlog中哪些内容是已经写入到磁盘，哪些还没被写入,所以不能单依靠binlog支持崩溃恢复。而redolog是循环写，从check point到write pos (不是write pos到check point)间的内容都是未写入到磁盘的，但是redolog是无法支持归档的。</code><br><code>redo log 和 binlog 有一个很大的区别就是，一个是循环写，一个是追加写。也就是说 redo log 只会记录未刷盘的日志，已经刷入磁盘的数据都会从 redo log 这个有限大小的日志文件里删除。binlog 是追加日志，保存的是全量的日志。 当数据库 crash 后，想要恢复未刷盘但已经写入 redo log 和 binlog 的数据到内存时，binlog 是无法恢复的。虽然 binlog 拥有全量的日志，但没有一个标志让 innoDB 判断哪些数据已经刷盘，哪些数据还没有。</code></p><p>这两种日志有以下三点不同。</p><ul><li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li><li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID&#x3D;2 这一行的 c 字段加 1 ”。</li><li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ul><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>有了对这两个日志的概念性理解，我们再来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程。</p><ol><li>执行器先找引擎取 ID&#x3D;2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID&#x3D;2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648113221297-708a4029-be16-4b31-9538-1ef82cece307.png#averageHue=%23ecede2&clientId=ub35db475-a524-4&from=paste&height=487&id=eROFt&originHeight=731&originWidth=513&originalType=binary&ratio=1&rotation=0&showTitle=false&size=149649&status=done&style=none&taskId=u1d9c41ee-c839-4ec7-a5e3-d67f8b6c729&title=&width=342" alt="image.png"><br>将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是”两阶段提交”。<br>由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p><p>仍然用前面的 update 语句来做例子。假设当前 ID&#x3D;2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？</p><p><strong>先写 redo log 后写 binlog</strong>。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</p><p><strong>先写 binlog 后写 redo log</strong>。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。</p><p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p><p>你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？</p><p>其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用 binlog 来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p><p>Binlog有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有。</p><p><strong>两阶段提交的不同时刻，MySQL 异常重启会出现什么现象。</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1650437373196-5ae1790e-1e28-4526-992e-88a474a8fc80.png#averageHue=%23edeee2&clientId=u52eb2620-e685-4&from=paste&id=uc6cedb1d&originHeight=1522&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=634267&status=done&style=none&taskId=u44f064d3-65b6-4987-b3a8-796c757e343&title=" alt="image.png"><br>1、如果在图中时刻 A 的地方，也就是写入 redo log 处于 prepare 阶段之后、写 binlog 之前，发生了崩溃（crash），由于此时 binlog 还没写，redo log 也还没提交，所以崩溃恢复的时候，这个事务会回滚。这时候，binlog 还没写，所以也不会传到备库。<br>2、时刻 B，也就是 binlog 写完，redo log 还没 commit 前发生 crash，那崩溃恢复的时候 MySQL 会怎么处理？</p><ul><li>如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交；</li><li>如果 redo log 里面的事务只有完整的 prepare，则判断对应的事务 binlog 是否存在并完整：<ul><li>a. 如果是，则提交事务；</li><li>b. 否则，回滚事务。</li></ul></li></ul><h3 id="binlog的三种格式"><a href="#binlog的三种格式" class="headerlink" title="binlog的三种格式"></a>binlog的三种格式</h3><h4 id="statement"><a href="#statement" class="headerlink" title="statement"></a>statement</h4><p>当 binlog_format&#x3D;statement 时，binlog 里面记录的就是 SQL 语句的原文</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">delete</span> <span class="keyword">from</span> t <span class="comment">/*comment*/</span>  <span class="keyword">where</span> a<span class="operator">&gt;=</span><span class="number">4</span> <span class="keyword">and</span> t_modified<span class="operator">&lt;=</span><span class="string">&#x27;2018-11-10&#x27;</span> limit <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;master.000001&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1650876306414-ef659638-160f-4294-86c2-1bedf9932b53.png#averageHue=%23090109&clientId=u84cf85c6-a1db-4&from=paste&id=u0bed92d0&originHeight=213&originWidth=1882&originalType=url&ratio=1&rotation=0&showTitle=false&size=43916&status=done&style=none&taskId=u7696b2bc-d028-4672-b728-7d0c514bfb8&title=" alt="image.png"><br>第二行是一个 BEGIN，跟第四行的 commit 对应，表示中间是一个事务；</p><p>第三行就是真实执行的语句了。可以看到，在真实执行的 delete 命令之前，还有一个“use ‘test’”命令。这条命令不是我们主动执行的，而是 MySQL 根据当前要操作的表所在的数据库，自行添加的。这样做可以保证日志传到备库去执行的时候，不论当前的工作线程在哪个库里，都能够正确地更新到 test 库的表 t。</p><h4 id="row"><a href="#row" class="headerlink" title="row"></a>row</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1650876481808-6f610fff-712f-4e13-8dba-b32366c53c42.png#averageHue=%23050207&clientId=u84cf85c6-a1db-4&from=paste&id=u2fbfb767&originHeight=533&originWidth=1920&originalType=url&ratio=1&rotation=0&showTitle=false&size=419977&status=done&style=none&taskId=u21be3baf-c2b0-4a03-99c2-b2487712508&title=" alt="image.png"><br>可以看到，与 statement 格式的 binlog 相比，前后的 BEGIN 和 COMMIT 是一样的。但是，row 格式的 binlog 里没有了 SQL 语句的原文，而是替换成了两个 event：Table_map 和 Delete_rows。</p><p>Table_map event，用于说明接下来要操作的表是 test 库的表 t;Delete_rows event，用于定义删除的行为。<br>可以看到，当 binlog_format 使用 row 格式的时候，binlog 里面记录了真实删除行的主键 id，这样 binlog 传到备库去的时候，就肯定会删除 id&#x3D;4 的行，不会有主备删除不同行的问题。</p><h4 id="mixed"><a href="#mixed" class="headerlink" title="mixed"></a>mixed</h4><p>因为有些 statement 格式的 binlog 可能会导致主备不一致，所以要使用 row 格式。但 row 格式的缺点是，很占空间。比如你用一个 delete 语句删掉 10 万行数据，用 statement 的话就是一个 SQL 语句被记录到 binlog 中，占用几十个字节的空间。但如果用 row 格式的 binlog，就要把这 10 万条记录都写到 binlog 中。这样做，不仅会占用更大的空间，同时写 binlog 也要耗费 IO 资源，影响执行速度。所以，MySQL 就取了个折中方案，也就是有了 mixed 格式的 binlog。mixed 格式的意思是，MySQL 自己会判断这条 SQL 语句是否可能引起主备不一致，如果有可能，就用 row 格式，否则就用 statement 格式。</p><h3 id="binlog-的写入机制"><a href="#binlog-的写入机制" class="headerlink" title="binlog 的写入机制"></a>binlog 的写入机制</h3><p>binlog 的写入逻辑比较简单：事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。</p><p>一个事务的 binlog 是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。这就涉及到了 binlog cache 的保存问题。</p><p>系统给 binlog cache 分配了一片内存，每个线程一个，参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p><p>事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 中，并清空 binlog cache。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1650877216791-c4eec49b-0149-4260-8ae2-1faf6b27731e.png#averageHue=%23a1bd8c&clientId=u84cf85c6-a1db-4&from=paste&id=ucd5cd72c&originHeight=748&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=350828&status=done&style=none&taskId=u7be45086-e9e1-4fca-905f-58cd27461ae&title=" alt="image.png"><br>每个线程有自己 binlog cache，但是共用同一份 binlog 文件。</p><p>图中的 write，指的就是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快。<br>图中的 fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为 fsync 才占磁盘的 IOPS。<br>write 和 fsync 的时机，是由参数 <strong>sync_binlog</strong> 控制的：</p><p>sync_binlog&#x3D;0 的时候，表示每次提交事务都只 write，不 fsync；sync_binlog&#x3D;1 的时候，表示每次提交事务都会执行 fsync；sync_binlog&#x3D;N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</p><p>因此，在出现 IO 瓶颈的场景里，将 sync_binlog 设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成 0，比较常见的是将其设置为 100~1000 中的某个数值。但是，将 sync_binlog 设置为 N，对应的风险是：如果主机发生异常重启，会丢失最近 N 个事务的 binlog 日志。</p><h2 id="redo-log-和-binlog-是怎么关联起来的"><a href="#redo-log-和-binlog-是怎么关联起来的" class="headerlink" title="redo log 和 binlog 是怎么关联起来的?"></a>redo log 和 binlog 是怎么关联起来的?</h2><p>它们有一个共同的数据字段，叫 XID。崩溃恢复的时候，会按顺序扫描 redo log：如果碰到既有 prepare、又有 commit 的 redo log，就直接提交；<br>如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。<br>如果完整，则提交事务，如果binlog不完整，则回滚事务</p><h2 id="组提交"><a href="#组提交" class="headerlink" title="组提交"></a>组提交</h2><h3 id="LSN"><a href="#LSN" class="headerlink" title="LSN"></a>LSN</h3><p>日志逻辑序列号（log sequence number，LSN）<br>LSN 是单调递增的，用来对应 redo log 的一个个写入点。每次写入长度为 length 的 redo log， LSN 的值就会加上 length。</p><p>LSN 也会写到 InnoDB 的数据页中，来确保数据页不会被多次执行重复的 redo log<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1650877956349-248ca201-d6c2-43a0-ac70-ae7d4c7bce0a.png#averageHue=%23e3e3bf&clientId=u84cf85c6-a1db-4&from=paste&id=ud19e5689&originHeight=2171&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=398351&status=done&style=none&taskId=u4a4d4116-61f8-48a7-bbdb-764b0f1ad4c&title=" alt="image.png"><br>trx1 是第一个到达的，会被选为这组的 leader；等 trx1 要开始写盘的时候，这个组里面已经有了三个事务，这时候 LSN 也变成了 160；trx1 去写盘的时候，带的就是 LSN&#x3D;160，因此等 trx1 返回时，所有 LSN 小于等于 160 的 redo log，都已经被持久化到磁盘；这时候 trx2 和 trx3 就可以直接返回了。</p><p>在并发更新场景下，第一个事务写完 redo log buffer 以后，接下来这个 fsync 越晚调用，组员可能越多，节约 IOPS 的效果就越好。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1650878105681-14abb035-6107-418a-b237-a148a90f3feb.png#averageHue=%23f1f2e9&clientId=u84cf85c6-a1db-4&from=paste&id=u3fd2b35f&originHeight=1522&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=true&size=210196&status=done&style=none&taskId=u794cd052-0d6a-467a-8b8e-ad30ca66b63&title=%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E7%BB%86%E5%8C%96" alt="两阶段提交细化" title="两阶段提交细化"><br>如果你想提升 binlog 组提交的效果，可以通过设置 <strong>binlog_group_commit_sync_delay</strong> 和 <strong>binlog_group_commit_sync_no_delay_count</strong> 来实现。<br><strong>binlog_group_commit_sync_delay</strong> 参数，表示延迟多少微秒后才调用 fsync;<br><strong>binlog_group_commit_sync_no_delay_count</strong> 参数，表示累积多少次以后才调用 fsync。</p><p><strong>WAL 机制是减少磁盘写，可是每次提交事务都要写 redo log 和 binlog，这磁盘读写次数也没变少呀?</strong></p><ul><li>redo log 和 binlog 都是顺序写，磁盘的顺序写比随机写速度要快；</li><li>组提交机制，可以大幅度降低磁盘的 IOPS 消耗。</li></ul><h2 id="刷盘"><a href="#刷盘" class="headerlink" title="刷盘"></a>刷盘</h2><p>当内存数据页跟磁盘数据页内容不一致的时候，<strong>我们称这个内存页为“脏页”</strong>。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。<br>有四种情况会刷盘：</p><ol><li>当innoDB的redo log写满了，这时候系统会停止所有更新操作，把 checkpoint 往前推进，redo log 留出空间可以继续写。checkPoint推进的过程中 会把推进路上对应的内存中的所有脏页都flush到磁盘上。redolog环对应的可以继续写入的部分要么是新的，要么是内存中的干净页，可以直接覆盖的。redolog对应的有用的部分对应的是内存中的脏页</li><li>当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。</li><li>当mysql认为系统空闲的时候就会刷盘</li><li>当mysql关闭前也会刷盘</li></ol><p>当出现第一种情况的时候，整个系统就不能在更新了，因为写redolog是更新的必须程序，所有的更新都会被堵住，所以是要尽量避免的</p><p>InnoDB 用<strong>缓冲池（buffer pool）</strong>管理内存</p><h3 id="脏页的控制策略"><a href="#脏页的控制策略" class="headerlink" title="脏页的控制策略"></a>脏页的控制策略</h3><p>通过i**nnodb_io_capacity **这个参数，它会告诉 InnoDB 你的磁盘能力,建议设置成磁盘的IOPS<br><code>“IOPS全称:Input/Output Operations Per Second,即每秒进行读写(I/O)操作的次数。”</code></p><p>InnoDB 的刷盘速度是要参考这两个因素：一个是脏页比例，一个是 redo log 写盘速度。</p><p>参数** innodb_max_dirty_pages_pct** 是脏页比例上限，默认值是 75%。InnoDB 会根据当前的脏页比例（假设为 M），算出一个范围在 0 到 100 之间的数字 F1(M)，</p><p>对于redolog,InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的差值，我们假设为 N。InnoDB 会根据这个 N 算出一个范围在 0 到 100 之间的数字 F2（N）</p><p>然后，根据上述算得的 F1(M) 和 F2(N) 两个值，取其中较大的值记为 R，之后引擎就可以按照 innodb_io_capacity 定义的能力乘以 R% 来控制刷脏页的速度。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1650436507824-2065113f-bb0b-4c48-ae9b-c90c853b9f70.png#averageHue=%23edefe4&clientId=u52eb2620-e685-4&from=paste&id=ud0ac7cf8&originHeight=1522&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=435479&status=done&style=none&taskId=u467db1e5-c649-40bd-9c85-90a5b6a7636&title=" alt="image.png"></p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。你现在知道，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。</p><p><strong>事务的 ACID（Atomicity、Consistency、Isolation、Durability，</strong><br><strong>即原子性:每个事务都是不可分割的最小单元，要么全部成功，要不全部失败恢复到执行事务前的状态</strong><br><strong>一致性:事务总是使得数据库从一个一致性状态到另一种一致性状态。</strong><br><strong>隔离性:在并发的执行事务时，事务之间是不会造成影响的</strong><br><strong>持久性:一旦事务提交。那么这个事务一定是生效的，即使遭遇到了崩溃宕机。通过redoLog+binlog实现）</strong></p><h2 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h2><p>当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。</p><p>在谈隔离级别之前，你首先要知道，你<strong>隔离得越严实，效率就会越低</strong>。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。下面我逐一为你解释：</p><ul><li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</li><li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><p>假设数据表 T 中只有一列，其中一行的值为 1，下面是按照时间顺序执行两个事务的行为。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648114969737-ca2280ec-d1d7-403f-ab13-926f1dfe3d99.png#averageHue=%23f2f1ed&clientId=ub35db475-a524-4&from=paste&id=u3d4fa0c4&originHeight=1420&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=386590&status=done&style=none&taskId=u2cf5b523-30d0-40be-8854-8517eb9d974&title=" alt="image.png"><br>我们来看看在不同的隔离级别下，事务 A 会有哪些不同的返回结果，也就是图里面 V1、V2、V3 的返回值分别是什么</p><p>隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2</p><p>若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。</p><p>若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：<strong>事务在执行期间看到的数据前后必须是一致的。</strong></p><p>若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。</p><p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的<strong>，整个事务存在期间都用这个视图</strong>。在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</p><p>我们可以看到在不同的隔离级别下，数据库行为是有所不同的。Oracle 数据库的默认隔离级别其实就是“读提交”，因此对于一些从 Oracle 迁移到 MySQL 的应用，为保证数据库隔离级别的一致，你一定要记得将 MySQL 的隔离级别设置为“读提交”。(mysql默认隔离级别 可重复读)</p><p>配置的方式是，将启动参数** transaction-isolation** 的值设置成** READ-COMMITTED**。你可以用 show variables 来查看当前的值</p><p><strong>可能会问那什么时候需要“可重复读”的场景呢？</strong><br>我们来看一个数据校对逻辑的案例。假设你在管理一个个人银行账户表。一个表存了账户余额，一个表存了账单明细。到了月底你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响</p><h2 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h2><p>我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复读”。</p><p>在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648115713483-7e04eee4-1941-44e6-a4e7-f56490fefa37.png#averageHue=%23f2f1eb&clientId=ub35db475-a524-4&from=paste&id=ubed388d6&originHeight=737&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=248434&status=done&style=none&taskId=u190e6fc5-52a1-48d9-8607-953b27a477b&title=" alt="image.png"><br>当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。</p><p>同时你会发现，即使现在有另外一个事务正在将 4 改成 5，这个事务跟 read-view A、B、C 对应的事务是不会冲突的。</p><p>你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的 read-view 的时候。</p><p>基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。</p><p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，<strong>数据库里面它可能用到的回滚记录都必须保留</strong>，这就会导致大量占用存储空间。</p><p><code>在RR的隔离级别里，长事务的执行期间，其他事务每次开启，都会保留这次事务初始状态的read-view,这样就能保证在长事务的执行过程中看到的其他数据都是最初始的，但是这样就会导致老的事务视图、以及回滚日志必须存在，占用了大量的存储空间</code></p><p>在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 ibdata 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数据只有 20GB，而回滚段有 200GB 的库。最终只好为了清理回滚段，重建整个库。</p><p>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。</p><h2 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h2><p>如前面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并不是有意使用长事务，通常是由于误用所致。</p><p>MySQL 的事务启动方式有以下几种：显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。set autocommit&#x3D;0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。</p><p>这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。</p><p>有些客户端连接框架会默认连接成功后先执行一个 set autocommit&#x3D;0 的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。因此，我会建议你总是使用 set autocommit&#x3D;1, 通过显式语句的方式来启动事务。</p><p>但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。</p><p>如果你也有这个顾虑，我建议你使用 commit work and chain 语法。在 autocommit 为 1 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。</p><p>同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p><p>你可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(timediff(now(),trx_started))<span class="operator">&gt;</span><span class="number">60</span></span><br></pre></td></tr></table></figure><h2 id="可重复读的理解"><a href="#可重复读的理解" class="headerlink" title="可重复读的理解"></a>可重复读的理解</h2><p>在 MySQL 里，有两个“视图”的概念：<br>一个是 view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样。<br>另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 <strong>consistent read view</strong>，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。</p><p>它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”</p><p>InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在<strong>事务开始</strong>的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。</p><p>而<strong>每行数据</strong>也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648431114419-7ad7fe30-7e51-44e9-83e8-381a4139a59c.png#averageHue=%23edefe4&clientId=ubdd7c6a3-1836-4&from=paste&id=u1f4cd4e2&originHeight=856&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=true&size=349597&status=done&style=none&taskId=u6a2056db-3401-4df7-ae8f-e23a3b4608c&title=%E5%9B%BE1%3A%E8%AE%B0%E5%BD%95%E8%A2%AB%E5%A4%9A%E4%B8%AA%E4%BA%8B%E5%8A%A1%E8%BF%9E%E7%BB%AD%E6%9B%B4%E6%96%B0%E5%90%8E%E7%9A%84%E7%8A%B6%E6%80%81%E3%80%82" alt="图1:记录被多个事务连续更新后的状态。" title="图1:记录被多个事务连续更新后的状态。"><br>图中虚线框里是同一行数据的 4 个版本，当前最新版本是 V4，k 的值是 22，它是被 transaction id 为 25 的事务更新的，因此它的 row trx_id 也是 25。</p><p>实际上，图中的三个虚线箭头，就是 <strong>undo log；</strong>而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。</p><p>按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见</p><p>因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。<br><code>事务执行之后，其他事务的更新对它虽然不可见，但是数据版本还是可见的，因为数据库实际上存储的是最新版本的数据。但是对于该事务来说，需要根据版本号以及Undo Logs计算出他需要的版本对应的数据</code></p><p>当然，如果“上一个版本”也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数据，它自己还是要认的。</p><p>在实现上，** InnoDB 为每个事务构造了一个数组**，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。<br><code>事务启动瞬间就会创建一个视图，并且生成一个trx_id</code></p><p>数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。</p><p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。而数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648433319988-54447ac9-f2d7-442a-9fdf-d94d9a2584ba.png#averageHue=%23f4efe8&clientId=ubdd7c6a3-1836-4&from=paste&id=u2ff698cc&originHeight=856&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=146395&status=done&style=none&taskId=u159b7bfa-f7ad-40c3-a9c8-151a3a6cb32&title=" alt="image.png"><br>这样，<strong>对于当前事务的启动瞬间来说</strong>，一个数据版本的 row trx_id，有以下几种可能：</p><ol><li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li><li>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li><li>如果落在黄色部分，那就包括两种情况<ul><li>若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；</li><li>若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li></ul></li></ol><p><code>落在黄色区域意味着是事务ID在低水位和高水位这个范围里面，而真正是是否可见，看黄色区域是否有这个值。如果黄色区域没有这个事务ID，则可见，如果有，则不可见。在这个范围里面并不意味这这个范围里有这个值，比如[1,2,3,5]，4在这个数组1-5的范围里，却没在这个数组里面。表示4是已提交的</code><br><code>事务启动时看到的一批活跃事务id 不一定都是连续的，比如99，100，102，104，105。而事务id又是严格递增的，这是因为 101，103 事务虽然晚于99事务启动，但先提交了。所以也应该可见。</code><br><code>**一个事务A，事务B，事务A先事务B启动 但是事务A执行第一个语句之前，事务B已经提交了，那么事务B对于事务A来说是可见的，其数据版本落在黄色部分。**</code></p><p> <strong>InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</strong></p><p>例题：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `k` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(id, k) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648436642991-cb96c42e-1d75-451f-8bfe-da1fe5ce2c8d.png#averageHue=%23fafafa&clientId=ubdd7c6a3-1836-4&from=paste&id=u88640d3b&originHeight=509&originWidth=910&originalType=url&ratio=1&rotation=0&showTitle=false&size=77588&status=done&style=none&taskId=ua2ee9126-6b57-46ec-8113-c6447e13318&title=" alt="image.png"><br>begin&#x2F;start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用** start transaction with consistent snapshot** 这个命令。<br>第一种启动方式，一致性视图是在执行第一个快照读语句时创建的；<br>第二种启动方式，一致性视图是在执行 start transaction with consistent snapshot 时创建的。</p><p>这里，我们不妨做如下假设：<br>事务 A 开始前，系统里面只有一个活跃事务 ID 是 99；<br>事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务；<br>三个事务开始前，(1,1）这一行数据的 row trx_id 是 90。<br>这样，事务 A 的视图数组就是[99,100], 事务 B 的视图数组是[99,100,101], 事务 C 的视图数组是[99,100,101,102]。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648436831411-e1b8b943-71ac-4b16-90d6-cdc022316d02.png#averageHue=%23bbcaae&clientId=ubdd7c6a3-1836-4&from=paste&id=uf77228b9&originHeight=856&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=389463&status=done&style=none&taskId=ucfa9e2d6-3e31-4da4-8fb4-27f1046d8bb&title=" alt="image.png"><br><code>如果使用第一种启动方式，事务A在最后查询才会创建视图，此时102版本低于高水位大于低水位，但是不在活跃数组中，所以102版本对于事务A可见，事务A查出的结果就是2。属于黄色区域第二种情况(事务c在事务A启动到创建视图这段时间间隔内提交了事务)</code></p><p>从图中可以看到，第一个有效更新是事务 C，把数据从 (1,1) 改成了 (1,2)。这时候，这个数据的最新版本的 row trx_id 是 102，而 90 这个版本已经成为了历史版本。</p><p>第二个有效更新是事务 B，把数据从 (1,2) 改成了 (1,3)。这时候，这个数据的最新版本（即 row trx_id）是 101，而 102 又成为了历史版本。<br><code>每行数据的版本链中版本号不一定是递增的</code></p><p>好，现在事务 A 要来读数据了，它的视图数组是[99,100]。当然了，读数据都是从当前版本读起的。所以，事务 A 查询语句的读数据流程是这样的：</p><ul><li>找到 (1,3) 的时候，判断出 row trx_id&#x3D;101，比高水位大(创建事务时确定高水位)，处于红色区域，不可见；</li><li>接着，找到上一个历史版本，一看 row trx_id&#x3D;102，比高水位大，处于红色区域，不可见；</li><li>再往前找，终于找到了（1,1)，它的 row trx_id&#x3D;90，比低水位小，处于绿色区域，可见。</li></ul><p>这样执行下来，虽然期间这一行数据被修改过，但是事务 A 不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读</p><p>但是<strong>事务 B 的 update 语句，如果按照一致性读，好像结果不对哦？</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648438902227-33dfff5b-7752-42f9-ae8f-4ba54824af5b.png#averageHue=%23c2d0b7&clientId=ubdd7c6a3-1836-4&from=paste&id=u29cc65f6&originHeight=856&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=181203&status=done&style=none&taskId=ubc0f1fa8-0770-462c-a1c2-f5bf051a302&title=" alt="image.png"><br>上图中，事务 B 的视图数组是先生成的，之后事务 C 才提交，不是应该看不见 (1,2) 吗，怎么能算出 (1,3) 来？<br>是的，如果事务 B 在更新之前查询一次数据，这个查询返回的 k 的值确实是 1。</p><p>所以，这里就用到了这样一条规则：更新数据都是先读后写的，而这个读，只能读当前的值，称为“<strong>当前读”（current read）</strong>。<br><code>事务与事务之间的隔离不应该影响最终数据的落地。就是说事务C先更新了数据，而后事务B也更新了同一份数据，以数据库的眼光来看这份数据的变动就是事务C的更新跟着事务B的更新，必须延续在一块而不能分开。 所以事务的更新必须是基于当前最新值来执行的，而读则是基于其视图，即可重复读的隔离，真的只是读层面的隔离。 在这个例子中，就是因为事务C的更新在前，事务B的更新必须延续事务C的结果，所以只能读取当前值再更新。而事务本身的更新是能被看到的，所以事务B再查询就只能是得到当前最新值。</code></p><p>因此，在更新的时候，当前读拿到的数据是 (1,2)，更新后生成了新版本的数据 (1,3)，这个新版本的 row trx_id 是 101。</p><p>所以，在执行事务 B 查询语句的时候，一看自己的版本号是 101，最新数据的版本号也是 101，是自己的更新，可以直接使用，所以查询得到的 k 的值是 3。</p><p>这里我们提到了一个概念，叫作当前读。其实，除了 update 语句外，select 语句如果加锁，也是当前读</p><p>所以，如果把事务 A 的查询语句 select * from t where id&#x3D;1 修改一下，加上 <strong>lock in share mode</strong> 或 <strong>for update</strong>，也都可以读到版本号是 101 的数据，返回的 k 的值是 3。下面这两个 select 语句，就是分别加了读锁（S 锁，<strong>共享锁</strong>）和写锁（X 锁，<strong>排他锁</strong>）<br><code>共享锁就是可以事务可以继续加共享锁，但是不能加排他锁了。排他锁加上后就不能再加任何类型的锁</code><br><code>不加锁叫快照读</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> k <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> lock <span class="keyword">in</span> share mode;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> k <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>再往前一步，假设事务 C 不是马上提交的，而是变成了下面的事务 C，会怎么样呢？<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648439136431-4b35da83-71d7-4f2e-aacc-34b0b870f86b.png#averageHue=%23f9f9f9&clientId=ubdd7c6a3-1836-4&from=paste&id=u555af770&originHeight=565&originWidth=906&originalType=url&ratio=1&rotation=0&showTitle=false&size=90942&status=done&style=none&taskId=u257c13bb-7de7-4653-ae0c-08c330e0e8d&title=" alt="image.png"><br>事务 C’的不同是，更新后并没有马上提交，在它提交前，事务 B 的更新语句先发起了。前面说过了，虽然事务 C’还没提交，但是 (1,2) 这个版本也已经生成了，并且是当前的最新版本。那么，事务 B 的更新语句会怎么处理呢？</p><p>这时候，“两阶段锁协议”就要上场了。事务 C’没提交，也就是说 (1,2) 这个版本上的写锁还没释放。而事务 B 是<strong>当前读，必须要读最新版本</strong>，<strong>而且必须加锁</strong>，因此就被锁住了，必须等到事务 C’释放这个锁，才能继续它的当前读。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648439181432-b5b054ed-4f67-44a5-b6a0-63dfd27c5fe5.png#averageHue=%23c1cfb6&clientId=ubdd7c6a3-1836-4&from=paste&id=u28580c0d&originHeight=856&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=337234&status=done&style=none&taskId=u654b2065-2bcb-4bfc-9b0f-587f4f74d55&title=" alt="image.png"></p><p><strong>可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</strong></p><p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p><ul><li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li><li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li></ul><p>那么，我们再看一下，在读提交隔离级别下，事务 A 和事务 B 的查询语句查到的 k，分别应该是多少呢？<br><code>这里需要说明一下，“start transaction with consistent snapshot; ”的意思是从这个语句开始，创建一个持续整个事务的一致性快照。所以，在读提交隔离级别下，这个用法就没意义了，等效于普通的 start transaction。</code></p><p>下面是读提交时的状态图，可以看到这两个查询语句的创建视图数组的时机发生了变化，就是图中的 read view 框。（注意：这里，我们用的还是事务 C 的逻辑直接提交，而不是事务 C’）<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648439281611-5d682321-af61-48bc-87f1-c12fcaf0b6ae.png#averageHue=%23a0b792&clientId=ubdd7c6a3-1836-4&from=paste&id=u3133d187&originHeight=856&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=534050&status=done&style=none&taskId=u99b6227f-1384-4887-a71b-d08f6a30f1b&title=" alt="image.png"></p><p>这时，事务 A 的查询语句的视图数组是在执行这个语句的时候创建的，时序上 (1,2)、(1,3) 的生成时间都在创建这个视图数组的时刻之前。但是，在这个时刻：(1,3) 还没提交，不可见；(1,2) 提交了，属于情况 可见。<br>所以，这时候事务 A 查询语句返回的是 k&#x3D;2。<br>显然地，事务 B 查询结果 k&#x3D;3。</p><p>可以想一下，为什么表结构不支持“可重复读”？这是因为表结构没有对应的行数据，也没有 row trx_id，因此只能遵循当前读的逻辑。</p><p>当然，MySQL 8.0 已经可以把表结构放在 InnoDB 字典里了，也许以后会支持表结构的可重复读。</p><h1 id="深入浅出索引"><a href="#深入浅出索引" class="headerlink" title="深入浅出索引"></a>深入浅出索引</h1><p>索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。一本 500 页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”</p><p><code>其实最好的例子就是我们从小就用的字典 里面的声母查询方式就是聚簇索引。 偏旁部首就是二级索引 偏旁部首+笔画就是联合索引。 这种方式比较适合人类的思维方式，设计也比较精妙。 </code></p><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。</p><p>不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。</p><p>假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648172350141-1148f1ae-5357-4246-9e55-df37b38e9a0c.png#averageHue=%23ebede1&clientId=ub38593e9-da58-4&from=paste&id=u711c2508&originHeight=856&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=394076&status=done&style=none&taskId=ue30f032e-37eb-4230-8d4b-9bab7ebb4ed&title=" alt="image.png"><br>图中，User2 和 User4 根据身份证号算出来的值都是 N，但没关系，后面还跟了一个链表。假设，这时候你要查 ID_card_n2 对应的名字是什么，处理步骤就是：首先，将 ID_card_n2 通过哈希函数算出 N；然后，按顺序遍历，找到 User2。</p><p>需要注意的是，图中四个 ID_card_n 的值并不是递增的，这样做的好处是增加新的 User 时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以<strong>哈希索引做区间查询的速度是很慢的</strong>。</p><p>你可以设想下，如果你现在要找身份证号在[ID_card_X, ID_card_Y]这个区间的所有用户，就必须全部扫描一遍了。</p><p>所以，哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。</p><h2 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h2><p>有序数组在等值查询和范围查询场景中的性能就都非常优秀。</p><p>还是上面这个根据身份证号查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648172988285-612ee6fd-9e8e-40e7-9548-c8f73834f70f.png#averageHue=%23eff0e7&clientId=ub38593e9-da58-4&from=paste&id=u523f9001&originHeight=787&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=261326&status=done&style=none&taskId=u52aeb952-9eaa-40a9-9029-3f108f01bad&title=" alt="image.png"><br>这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你要查 ID_card_n2 对应的名字，用二分法就可以快速得到，这个时间复杂度是 O(log(N))。</p><p>同时很显然，这个索引结构支持范围查询。你要查身份证号在[ID_card_X, ID_card_Y]区间的 User，可以先用二分法找到 ID_card_X（如果不存在 ID_card_X，就找到大于 ID_card_X 的第一个 User），然后向右遍历，直到查到第一个大于 ID_card_Y 的身份证号，退出循环。</p><p>如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。</p><p>所以，有序数组索引只适用于静态存储引擎，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。</p><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>还是上面根据身份证号查名字的例子，如果我们用二叉搜索树来实现的话，示意图如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648173122656-422a42b5-a1f1-4d77-bc75-06766e296dff.png#averageHue=%23edeee5&clientId=ub38593e9-da58-4&from=paste&id=ue2441f8f&originHeight=856&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=445439&status=done&style=none&taskId=u5719c66d-7877-4064-a4df-e1c3f17715c&title=" alt="image.png"><br>二叉搜索树的特点是：父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。这样如果你要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -&gt; UserC -&gt; UserF -&gt; User2 这个路径得到。这个时间复杂度是 O(log(N))。</p><p>当然为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 O(log(N))。</p><p>树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</p><p>你可以想象一下一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询可真够慢的</p><p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。</p><p>以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p><p>在 MySQL 中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。而 InnoDB 存储引擎在 MySQL 数据库中使用最为广泛。</p><h2 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h2><p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。</p><p>每一个索引在 InnoDB 里面对应一棵 B+ 树。假设，我们有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引</p><p>表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648177404439-962473ed-5691-4733-977e-7e121ac1f8e2.png#averageHue=%23f2f1eb&clientId=ub38593e9-da58-4&from=paste&id=ua47e1a1f&originHeight=856&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=302521&status=done&style=none&taskId=u9f6a80ce-67fa-4e12-ab52-1cb35124172&title=" alt="image.png"><br>从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为<strong>聚簇索引</strong>（clustered index）。非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为<strong>二级索引</strong>（secondary index）</p><h3 id="主键索引和普通索引的查询有什么区别？"><a href="#主键索引和普通索引的查询有什么区别？" class="headerlink" title="主键索引和普通索引的查询有什么区别？"></a>主键索引和普通索引的查询有什么区别？</h3><ul><li>如果语句是 select * from T where ID&#x3D;500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；</li><li>如果语句是 select * from T where k&#x3D;5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。</li></ul><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p><h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。</p><p>而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。</p><p>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%</p><p>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p><p>自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂</p><p>而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？</p><p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</p><p><strong>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</strong></p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p><p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</p><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>看到这里你一定有一个疑问，如果为每一种查询都设计一个索引，索引是不是太多了。如果我现在要按照市民的身份证号去查他的家庭地址呢？虽然这个查询需求在业务中出现的概率不高，但总不能让它走全表扫描吧？反过来说，单独为一个不频繁的请求创建一个（身份证号，地址）的索引又感觉有点浪费。应该怎么做呢？</p><p><strong>B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</strong></p><p>为了直观地说明这个概念，我们用（name，age）这个联合索引来分析<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648178687735-90c51b38-d3f9-46aa-8227-852cde96647f.png#averageHue=%23f2f1ea&clientId=ub38593e9-da58-4&from=paste&id=u6826c5cc&originHeight=818&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=289776&status=done&style=none&taskId=uff5cb309-bf12-4c5c-8c3d-d7614291dbb&title=" alt="image.png">可以看到，索引项是按照索引定义里面出现的字段顺序排序的。</p><p><code>联合索引先根据第一个字段排序，如果第一个字段有相同的，就按照第二个字段排序，注意，这里仅仅有相同的第一个字段情况下，才会根据第二个字段排序。</code></p><p>当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到 ID4，然后向后遍历得到所有需要的结果。</p><p>如果你要查的是所有名字第一个字是“张”的人，你的 SQL 语句的条件是”where name like ‘张 %’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。</p><p>可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的<strong>最左 M 个字符</strong>。</p><p><strong>在建立联合索引的时候，如何安排索引内的字段顺序。</strong></p><p>这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。因此，<strong>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</strong></p><p>那么，如果既有联合查询，又有基于 a、b 各自的查询呢？查询条件里面只有 b 的语句，是无法使用 (a,b) 这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护 (a,b)、(b) 这两个索引。</p><p>这时候，我们要考虑的原则就是空间了。比如上面这个市民表的情况，name 字段是比 age 字段大的 ，那我就建议你创建一个（name,age) 的联合索引和一个 (age) 的单字段索引。</p><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你可能要问，那些不符合最左前缀的部分，会怎么样呢？我们还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。那么，SQL 语句是这么写的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tuser <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span> <span class="keyword">and</span> age<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> ismale<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录 ID3。当然，这还不错，总比全表扫描要好。 </p><p><code>因为联合索引在建立的时候是按照“字典序”来排序的，假设以(a,b)为例，先按照a的大小排序，如果a相等时再按照b的大小来排序：（2，100）、（3，150）、（4，50），第二个字段不一定有序，所以查询范围的时候最多匹配一个范围列，因为下一个字段不一定有序。</code> </p><p>然后呢？当然是判断其他条件是否满足。在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。</p><p>在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。</p><p>而 MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数<br>过程图如下:<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648179582601-8505ffa6-926a-4b92-8a9f-76f28a3f3dec.png#averageHue=%23f3f1ed&clientId=ue989aaab-00e7-4&from=paste&id=ubb129163&originHeight=833&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=true&size=290640&status=done&style=none&taskId=u3696a908-4b07-4f0b-aaf8-eaeaa6a5005&title=%E6%97%A0%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B" alt="无索引下推执行流程" title="无索引下推执行流程"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648179640502-b73960eb-e5ca-4c60-b294-026553498c3f.png#averageHue=%23f3f1ed&clientId=ue989aaab-00e7-4&from=paste&id=ue7b7341e&originHeight=856&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=true&size=289593&status=done&style=none&taskId=u7d11f6c5-1ec1-4daf-9d2c-91219c7d68a&title=%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B" alt="索引下推执行流程" title="索引下推执行流程"><br>这两个图里面，每一个虚线箭头表示回表一次。<br>第一个图中 在 (name,age) 索引里面我特意去掉了 age 的值，这个过程 InnoDB 并不会去看 age 的值，只是按顺序把“name 第一个字是’张’”的记录一条条取出来回表。因此，需要回表 4 次。</p><p>第二个图中 InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。在我们的这个例子中，只需要对 ID4、ID5 这两条记录回表取数据判断，就只需要回表 2 次。</p><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><p>在select语句之前添加explain关键字会返回语句的执行计划。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> servers;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------+---------------+------+---------+------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------+---------------+------+---------+------+------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> servers <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------+---------------+------+---------+------+------+-------+</span></span><br></pre></td></tr></table></figure><p>其中最重要的type:<br><strong>NULL</strong><br>MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。<br><strong>const、system</strong><br>当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量,system是const类型的特例，当查询的表只有一行的情况下，使用system<br><strong>eq_ref</strong><br>类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件<br><strong>ref</strong><br>表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值<br><strong>range</strong><br>只检索给定范围的行，使用一个索引来选择行<br>i<strong>ndex</strong><br>Full Index Scan，index与ALL区别为index类型只遍历索引树<br><strong>ALL</strong><br>Full Table Scan， MySQL将遍历全表以找到匹配的行</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>顾名思义，全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是** Flush tables with read lock** (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p><p>全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都 select 出来存成文本。</p><p>以前有一种做法，是通过 FTWRL 确保不会有其他线程对数据库做更新，然后对整个库做备份。注意，在备份过程中整个库完全处于只读状态。</p><p>但是让整库都只读，听上去就很危险：如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。</p><p>官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。</p><p>你一定在疑惑，有了这个功能，为什么还需要 FTWRL 呢？一致性读是好，但前提是引擎要支持这个隔离级别。比如，对于 MyISAM 这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用 FTWRL 命令了。</p><p>所以，single-transaction 方法只适用于所有的表使用事务引擎的库。如果有的表使用了不支持事务的引擎，那么备份就只能通过 FTWRL 方法。这往往是 DBA 要求业务开发人员使用 InnoDB 替代 MyISAM 的原因之一。</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p><strong>表锁的语法是 lock tables … read&#x2F;write</strong>。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p><p>举个例子, 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表</p><p>在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。</p><h3 id="MDL"><a href="#MDL" class="headerlink" title="MDL"></a>MDL</h3><p>另一类表级的锁是 MDL（metadata lock)。MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>因此，在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</p><ul><li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</li><li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li></ul><p><code>加读锁则所有线程可正常读元数据，不影响增删改查操作，只是不能修改表结构；加写锁则只有拥有锁的线程可以读写元数据，也就是修改表结构，其它线程不能执行任何操作，包括修改表结构与增删改查。</code><br>(DDL 更改表结构) DML(增删改查)</p><p>我们来看一下下面的操作序列，假设表 t 是一个小表。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648189243388-65fe8441-51c7-4a86-bc57-4e15975df962.png#averageHue=%23f0eee7&clientId=ue989aaab-00e7-4&from=paste&id=ubbc20e7c&originHeight=856&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=286437&status=done&style=none&taskId=u0e1bcf88-be7f-4897-990e-fe397bfb3af&title=" alt="image.png">我们可以看到 session A 先启动，这时候会对表 t 加一个 MDL 读锁。由于 session B 需要的也是 MDL 读锁，因此可以正常执行。</p><p>之后 session C 会被 blocked，是因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁，因此只能被阻塞。</p><p>如果只有 session C 自己被阻塞还没什么关系，但是之后所有要在表 t 上新申请 MDL 读锁的请求也会被 session C 阻塞。前面我们说了，所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了。</p><p>如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。<br><code>表不可用的原因是因为 sessionc 申请写锁 并且在队列处于优先，导致 sessionc 后面的所有 读锁 请求申请都被 block 了。这个时候客户端如果有频繁重试的逻辑就会导致不停的和数据库建立连接，把连接池打满导致库不可用。</code></p><p>你现在应该知道了，事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。<br><code>有未提交的事务时无法修改表字段，而且在存在长事务时执行修改表字段命令是一个危险的操作，可能阻塞其它增删改查请求，或导致线程爆满</code></p><p><strong>如何安全地给小表加字段？</strong><br>首先我们要解决长事务，事务不提交，就会一直占着 MDL 锁。在 MySQL 的 information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。</p><p>但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？</p><p>这时候 kill 可能未必管用，因为新的请求马上就来了。比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。</p><p>MariaDB 已经合并了 AliSQL 的这个功能，所以这两个开源分支目前都支持 DDL NOWAIT&#x2F;WAIT n<br>这个语法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name NOWAIT add column ...</span><br><span class="line">ALTER TABLE tbl_name WAIT N add column ...</span><br></pre></td></tr></table></figure><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。</p><p>顾名思义，行锁就是针对数据表中行记录的锁。这很好理解，比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。</p><p><strong>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p><p>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放；</p><p><code>也就是说 如果一个事务中包含了对多条记录的增删改，每执行一条语句，就会对其中的一条记录加上对应的行锁，当事务提交时，才会释放锁，并不是语句执行完成释放。所有当一个事务包含了多条操作，影响了多行记录，尽量把并发度最高的操作放在最后，这样这行记录的行锁就不会在这个事务中停留很长的时间。</code></p><h3 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h3><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。这里我用数据库中的行锁举个例子。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648219769688-d2a63c64-b371-44de-871f-06f8f19bf9ca.png#averageHue=%23eeeee3&clientId=u2e8a2ebc-6522-4&from=paste&id=u3244e8e4&originHeight=856&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=299114&status=done&style=none&taskId=u44d2fac4-01da-4283-824c-45fb342615b&title=" alt="image.png"><br>这时候，事务 A 在等待事务 B 释放 id&#x3D;2 的行锁，而事务 B 在等待事务 A 释放 id&#x3D;1 的行锁。 事务 A 和事务 B 在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：</p><ul><li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数** innodb_lock_wait_timeout** 来设置。</li><li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 **innodb_deadlock_detect **设置为 on，表示开启这个逻辑。</li></ul><p>在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。但是，我们又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p><p>所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且 innodb_deadlock_detect 的默认值本身就是 on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。</p><p>你可以想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p><p>那如果是我们上面说到的所有事务都要更新同一行的场景呢？每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n平方) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。</p><p>怎么解决由热点更新导致的性能问题呢?</p><p>一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，<strong>可以临时把死锁检测关掉</strong>。但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。</p><p>另一个思路是<strong>控制并发度</strong>。根据上面的分析，你会发现如果并发能够控制住，比如同一行同时最多只有 10 个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。一个直接的想法就是，在客户端做并发控制。但是，你会很快发现这个方法不太可行，因为客户端很多。我见过一个应用，有 600 个客户端，这样即使每个客户端控制到只有 5 个并发线程，汇总到数据库服务端以后，峰值并发数也可能要达到 3000。</p><p>因此，这个<strong>并发控制要做在数据库服务端</strong>。如果你有中间件，可以考虑在中间件实现；如果你的团队有能修改 MySQL 源码的人，也可以做在 MySQL 里面。基本思路就是，<strong>对于相同行的更新，在进入引擎之前排队</strong>。这样在 InnoDB 内部就不会有大量的死锁检测工作了。</p><p>也可以考虑通过将一行改成逻辑上的多行来减少锁冲突。还是以影院账户为例，可以考虑放在多条记录上，比如 10 个记录，影院的账户总额等于这 10 个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的 1&#x2F;10，可以减少锁等待个数，也就减少了死锁检测的 CPU 消耗。</p><h2 id="加锁规则"><a href="#加锁规则" class="headerlink" title="加锁规则"></a>加锁规则</h2><p><strong>加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。</strong><br>原则 1：加锁的基本单位是 next-key lock。<code>next-key lock 是前开后闭区间。</code><br>原则 2：查找过程中访问到的对象才会加锁。<br>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。<br>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。<br>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure><h3 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一<img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1650196785720-81dc67d8-9362-460f-8c72-124925f32c83.png#averageHue=%23f9f9f9&clientId=u3a41a891-d6bd-4&from=paste&id=u3fc85d1e&originHeight=462&originWidth=1244&originalType=url&ratio=1&rotation=0&showTitle=false&size=87911&status=done&style=none&taskId=uc6cee32e-a121-46ec-bd29-bc18a18beb1&title=" alt="image.png"></h3><p>这里 session A 要给索引 c 上 c&#x3D;5 的这一行加上读锁。</p><ul><li>根据原则 1，加锁单位是 next-key lock，因此会给 (0,5]加上 next-key lock。</li><li>要注意 c 是普通索引，因此仅访问 c&#x3D;5 这一条记录是不能马上停下来的，需要向右遍历，查到 c&#x3D;10 才放弃。根据原则 2，访问到的都要加锁，因此要给 (5,10]加 next-key lock。</li><li>但是同时这个符合优化 2：等值判断，向右遍历，最后一个值不满足 c&#x3D;5 这个等值条件，因此退化成间隙锁 (5,10)。</li><li>根据原则 2 ，只有访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么 session B 的 update 语句可以执行完成。</li></ul><p>但 session C 要插入一个 (7,7,7) 的记录，就会被 session A 的间隙锁 (5,10) 锁住（c的值）。</p><p>需要注意，在这个例子中，lock in share mode 只锁覆盖索引，但是如果是 for update 就不一样了。 执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。</p><p>这个例子说明，锁是加在索引上的；同时，它给我们的指导是，如果你要用 lock in share mode 来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。比如，将 session A 的查询语句改成 select d from t where c&#x3D;5 lock in share mode</p><h3 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1650196929106-7660a1a3-6640-4347-b798-5c4b471bc95b.png#averageHue=%23fafafa&clientId=u3a41a891-d6bd-4&from=paste&id=ua535fe5d&originHeight=313&originWidth=936&originalType=url&ratio=1&rotation=0&showTitle=false&size=55984&status=done&style=none&taskId=uf85c6652-35de-4ff4-98b8-dd0793c5afe&title=" alt="image.png"><br>根据原则 1，加锁单位是 next-key lock，session A 加锁范围就是 (5,10]；<br>同时根据优化 2，这是一个等值查询 (id&#x3D;7)，而 id&#x3D;10 不满足查询条件，next-key lock 退化成间隙锁，因此最终加锁的范围是 (5,10)。<br>所以，session B 要往这个间隙里面插入 id&#x3D;8 的记录会被锁住，但是 session C 修改 id&#x3D;10 这行是可以的。</p><h3 id="案例三"><a href="#案例三" class="headerlink" title="案例三"></a>案例三</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">and</span> id<span class="operator">&lt;</span><span class="number">11</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>这两条语句，加锁范围相同吗？<br>在逻辑上，这两条查语句肯定是等价的，但是它们的加锁规则不太一样。现在，我们就让 session A 执行第二个查询语句，来看看加锁效果。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1650197044039-7a303e5d-1b56-41bc-a529-eb7c6ffecd40.png#averageHue=%23fbfafa&clientId=u3a41a891-d6bd-4&from=paste&id=ub5ac83fc&originHeight=718&originWidth=1244&originalType=url&ratio=1&rotation=0&showTitle=false&size=124356&status=done&style=none&taskId=u0ef12a21-8e64-4984-9f19-cc8fbc4fc53&title=" alt="image.png"></p><ul><li>开始执行的时候，要找到第一个 id&#x3D;10 的行，因此本该是 next-key lock(5,10]。 根据优化 1， 主键 id 上的等值条件，退化成行锁， 只加了 id&#x3D;10 这一行的行锁。</li><li>范围查找就往后继续找，找到 id&#x3D;15 这一行停下来，因此需要加 next-key lock(10,15]。此时是符</li></ul><p>所以，session A 这时候锁的范围就是主键索引上，行锁 id&#x3D;10 和 next-key lock(10,15]。这样，session B 和 session C 的结果你就能理解了。</p><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>在同一个事务中，两次读取到的数据不一致的情况称为幻读和不可重复读。<strong>幻读是针对insert导致的数据不一致</strong>，<strong>不可重复读是针对 delete、update导致的数据不一致</strong></p><p>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“<strong>当前读</strong>”下才会出现。<br><code>当前读指的是select for update或者select in share mode，指的是在更新之前必须先查寻当前的值，因此叫当前读</code></p><p><strong>幻读只针对新增的记录，查询时记录条数不一样</strong><br><code>事务a 开启, 查询符合条件的数据 ,发现有10条, 准备将这10条记录修改, 此时事务b开启, 插入了一条符合事务a查询条件的记录. 提交事务, 回到事务a, a也提交事务, 当再次查询到时候, 发现修改了11条..感觉发生了幻觉一样. 此为幻读.</code></p><hr><h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure><p>即使给所有行加上了锁，也避免不了幻读，这是因为给行加锁的时候，这条记录还不存在，没法加锁，因此，为了解决幻读问题，InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。<br>顾名思义，间隙锁，锁的就是两个值之间的空隙，比如下面5个数据(id值 0，5，10，15，20，25)，这就产生了 7 个间隙。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1649992660264-65dd581d-b5b9-4976-8485-8772530f2194.png#averageHue=%23f4f2ed&clientId=u0e71056a-b30e-4&from=paste&id=Kt72W&originHeight=550&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=76936&status=done&style=none&taskId=u94793186-c86f-4978-bdda-8140978c040&title=" alt="image.png"><br>这样，当执行 select * from t where id&#x3D;5 for update时，就不止是给数据库中已有的 6 个记录加上了行锁，还同时加了 7 个间隙锁。这样就确保了无法再插入新的记录。<br><code>（如果只是给所有数据加上锁，那么对于新加入的数据 比如id=1 这一行是锁不住的，就会导致数据不一致的问题出现）</code><br>所以数据行是可以加上锁的实体，数据行之间的间隙，也是可以加上锁的实体。但是间隙锁跟我们之前碰到过的锁都不太一样。<br>比如行锁，分成读锁和写锁。下图就是这两种类型行锁的冲突关系。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1649993034198-38b45746-5725-4dde-9da9-98a6171fd13a.png#averageHue=%23fafafa&clientId=u0e71056a-b30e-4&from=paste&id=EM16B&originHeight=154&originWidth=411&originalType=url&ratio=1&rotation=0&showTitle=false&size=12389&status=done&style=none&taskId=ue83bb8ed-a0fa-420d-ba7d-63351017074&title=" alt="image.png"><br>也就是说，跟行锁有冲突关系的是“另外一个行锁”。</p><p>但是间隙锁不一样，跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。间隙锁之间都不存在冲突关系。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1649993266628-29fe8369-3579-4a77-89e8-cbd0cc4871c4.png#averageHue=%23f9f9f9&clientId=u0e71056a-b30e-4&from=paste&id=lvjx5&originHeight=210&originWidth=946&originalType=url&ratio=1&rotation=0&showTitle=false&size=35886&status=done&style=none&taskId=ufcfa8103-a650-4c06-b4b9-a2b2d3bd682&title=" alt="image.png"><br>c7不存在 都会在这个间隙 加上锁，但是不会冲突</p><p>间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间。也就是说，我们的表 t 初始化以后，如果用 select * from t for update 要把整个表所有记录锁起来，就形成了 7 个 next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]。</p><p><code>这个 supremum 从哪儿来的呢？这是因为 +∞是开区间。实现上，InnoDB 给每个索引加了一个不存在的最大值 supremum，这样才符合我们前面说的“都是前开后闭区间</code></p><h1 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h1><h2 id="NLJ"><a href="#NLJ" class="headerlink" title="NLJ"></a>NLJ</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t2` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `a` (`a`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 <span class="keyword">like</span> t2;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1650953541569-e9649522-4b4b-48c8-a1f7-4b2031bd1563.png#averageHue=%23090109&clientId=u9f841287-a109-4&from=paste&id=u90881f8f&originHeight=163&originWidth=1394&originalType=url&ratio=1&rotation=0&showTitle=false&size=31471&status=done&style=none&taskId=ua6df17c9-4a06-4638-95b5-21c16652669&title=" alt="image.png"><br>上面这个语句的执行流程</p><ol><li>从表 t1 中读入一行数据 R；</li><li>从数据行 R 中，取出 a 字段到表 t2 里去查找；</li><li>取出表 t2 中满足条件的行，跟 R 组成一行，作为结果集的一部分；</li><li>重复执行步骤 1 到 3，直到表 t1 的末尾循环结束。</li></ol><p>在形式上，这个过程就跟我们写程序时的嵌套查询类似，并且可以用上被驱动表的索引，所以我们称之为“Index Nested-Loop Join”，简称 NLJ。<br><strong>如果使用 join 语句的话，需要让小表做驱动表。</strong></p><h2 id="BNL"><a href="#BNL" class="headerlink" title="BNL"></a>BNL</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> (t1.a<span class="operator">=</span>t2.b);</span><br></pre></td></tr></table></figure><p>这时候，被驱动表上没有可用的索引，算法的流程是这样的：<br><code>“Block Nested-Loop Join”的算法，简称 BNL。</code></p><ol><li>把表 t1 的数据读入线程内存 join_buffer 中，由于我们这个语句中写的是 select *，因此是把整个表 t1 放入了内存；</li><li>扫描表 t2，把表 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1650954146426-5e868fc8-9ad5-4b5f-b757-c2f09ada4833.png#averageHue=%23edeee5&clientId=u9f841287-a109-4&from=paste&id=uf584d183&originHeight=880&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=209296&status=done&style=none&taskId=ue49e250b-56bf-4280-b030-62a5d419e01&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1650954156660-9fdff866-3e36-4a30-8565-51856356f1fc.png#averageHue=%23090109&clientId=u9f841287-a109-4&from=paste&id=u996c909a&originHeight=164&originWidth=1763&originalType=url&ratio=1&rotation=0&showTitle=false&size=35157&status=done&style=none&taskId=u0c33c4a8-b702-4f8c-9f31-70491336d60&title=" alt="image.png"><br>可以看到，在这个过程中，对表 t1 和 t2 都做了一次全表扫描，因此总的扫描行数是 1100。由于 join_buffer 是以无序数组的方式组织的，因此对表 t2 中的每一行，都要做 100 次判断，总共需要在内存中做的判断次数是：100*1000&#x3D;10 万次。<br>在这种情况下，应该选择哪个表做驱动表?</p><p>假设小表的行数是 N，大表的行数是 M，那么在这个算法里：两个表都做一次全表扫描，所以总的扫描行数是 M+N；内存中的判断次数是 M*N。<br>显然调换N和M没有区别</p><p>但是当join_buffer不足以放下表t1的数据时，mysql的策略就是<strong>分段放</strong><br> 能放下多少就先放多少，然后返回结果集之后，清空join_buffer继续放<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1650954434057-b82dcdd6-f89a-42cb-b067-9c45e777e1ac.png#averageHue=%23ebece1&clientId=u9f841287-a109-4&from=paste&id=u2a584d0a&originHeight=880&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=291462&status=done&style=none&taskId=u8f432b2f-13dd-47a2-9beb-2f0043323ed&title=" alt="image.png"><br>图中的步骤 4 和 5，表示清空 join_buffer 再复用。</p><p>假设，驱动表的数据行数是 N，需要分 K 段才能完成算法流程，被驱动表的数据行数是 M。注意，这里的 K 不是常数，N 越大 K 就会越大，因此把 K 表示为λ*N，显然λ的取值范围是 (0,1)</p><p>扫描行数是 N+λ<em>N</em>M；内存判断 N*M 次。 所以结论是，应该让小表当驱动表。<br>而λ的大小也会影响扫描的行数，而λ显然是受join_buffer_size影响，join_buffer_size 越大，一次可以放入的行越多，分成的段数也就越少，对被驱动表的全表扫描次数就越少。这就是为什么，你可能会看到一些建议告诉你，如果你的 join 语句很慢，就把 join_buffer_size 改大。</p><p><strong>更准确地说，在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与 join 的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</strong></p><h2 id="BKA"><a href="#BKA" class="headerlink" title="BKA"></a>BKA</h2><p>Batched Key Access(BKA)算法其实是对NLJ算法的优化</p><p><code>Multi-Range Read 优化 (MRR)。这个优化的主要目的是尽量使用顺序读盘。因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。</code></p><p>NLJ 算法执行的逻辑是：从驱动表 t1，一行行地取出 a 的值，再到被驱动表 t2 去做 join。也就是说，对于表 t2 来说，每次都是匹配一个值。这时，MRR 的优势就用不上了。那怎么才能一次性地多传些值给表 t2 呢？方法就是，从表 t1 里一次性地多拿些行出来，一起传给表 t2。</p><p>既然如此，我们就把表 t1 的数据取出来一部分，先放到一个临时内存。这个临时内存不是别人，就是 join_buffer。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1650955774308-bf38ea60-0d50-4b0b-a3da-cbd9b6a031eb.png#averageHue=%23dae2cf&clientId=u9f841287-a109-4&from=paste&id=u1b2c7b3b&originHeight=880&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=143155&status=done&style=none&taskId=uec77b0b5-13d3-42fb-969d-134a255c2b9&title=" alt="image.png"></p><p>图中，我在 join_buffer 中放入的数据是 P1<del>P100，表示的是只会取查询需要的字段。当然，如果 join buffer 放不下 P1</del>P100 的所有数据，就会把这 100 行数据分成多段执行上图的流程。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">set</span> optimizer_switch<span class="operator">=</span><span class="string">&#x27;mrr=on,mrr_cost_based=off,batched_key_access=on&#x27;</span>;</span><br></pre></td></tr></table></figure><p>前两个参数的作用是要启用 MRR。这么做的原因是，BKA 算法的优化要依赖于 MRR。</p><h1 id="InnoDB-和-Memory-引擎的区别"><a href="#InnoDB-和-Memory-引擎的区别" class="headerlink" title="InnoDB 和 Memory 引擎的区别"></a>InnoDB 和 Memory 引擎的区别</h1><p>InnoDB 引擎把数据放在主键索引上，其他索引上保存的是主键 id。这种方式，我们称之为索引组织表（Index Organizied Table）。<br>而 Memory 引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之为堆组织表（Heap Organizied Table）。</p><p>不同:</p><ol><li>InnoDB 表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的；</li><li>当数据文件有空洞的时候，InnoDB 表在插入新数据的时候，为了保证数据有序性，只能在固定的位置写入新值，而内存表找到空位就可以插入新值；</li><li>数据位置发生变化的时候，InnoDB 表只需要修改主键索引，而内存表需要修改所有索引；</li><li>InnoDB 表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的。</li><li>InnoDB 支持变长数据类型，不同记录的长度可能不同；内存表不支持 Blob 和 Text 字段，并且即使定义了 varchar(N)，实际也当作 char(N)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。</li></ol><p>内存表使用的是哈希索引是无法进行范围查询的，会走全表扫描。<br>其实，一般在我们的印象中，内存表的优势是速度快，其中的一个原因就是 Memory 引擎支持 hash 索引。当然，更重要的原因是，内存表的所有数据都保存在内存，而内存的读写速度总是比磁盘快</p><p>但是为什么不建议你在生产环境上使用内存表。<br>这里的原因主要包括两个方面：锁粒度问题；数据持久化问题。</p><ul><li>内存表不支持行锁，只支持表锁。因此，一张表只要有更新，就会堵住其他所有在这个表上的读写操作。</li><li>数据放在内存中，是内存表的优势，但也是一个劣势。因为，数据库重启的时候，所有的内存表都会被清空。</li></ul><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="普通索引和唯一索引，应该怎么选择？"><a href="#普通索引和唯一索引，应该怎么选择？" class="headerlink" title="普通索引和唯一索引，应该怎么选择？"></a>普通索引和唯一索引，应该怎么选择？</h2><p>对于普通索引来说，查找到满足条件的第一个记录 后，需要查找下一个记录，直到碰到第一个不满足 条件的记录。</p><p>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</p><p>这个不同带来的性能差距会有多少呢？答案是，微乎其微。</p><p>InnoDB 的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB。</p><p>因为引擎是按页读写的，所以说，当找到 k&#x3D;5 的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。</p><p>当然，如果满足条件的这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些。</p><h3 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h3><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p><p>需要说明的是，虽然名字叫作 change buffer，实际上它是可以持久化的数据。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。<br><code>change buffer可以看成也是一个数据页，需要被持久化到 系统表空间（ibdata1），以及把这个change buffer页的改动记录在redo log里，事后刷进系统表空间（ibdata1）。</code></p><p>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。</p><p>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入 (4,400) 这个记录，就要先判断现在表中是否已经存在 k&#x3D;4 的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。</p><p>change buffer 用的是 buffer pool 里的内存，因此不能无限增大。change buffer 的大小，可以通过参数 innodb_change_buffer_max_size 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。<br><code>Buffer Pool 是一片内存空间，受制于内存空间大小。 可以通过innodb_buffer_pool_size 来控制Buffer Pool 的大小。</code></p><p>现在来看一下插入一条记录的流程<br>第一种情况是，这个记录要更新的目标页在内存中。这时，InnoDB 的处理流程如下：</p><ul><li>对于唯一索引来说，找到要插入的位置，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，找到 要插入的位置，插入这个值，语句执行结束。</li></ul><p>第二种情况是，这个记录要更新的目标页不在内存中。这时，InnoDB 的处理流程如下：</p><ul><li>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束</li></ul><p>将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p><p>普通索引的所有场景，使用 change buffer 都可以起到加速作用吗？</p><p>因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。</p><p>因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。</p><p>反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反而起到了副作用。</p><p>回到我们文章开头的问题，普通索引和唯一索引应该怎么选择。其实，这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。所以，建议尽量选择普通索引。</p><p>如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭 change buffer。而在其他情况下，change buffer 都能提升更新性能。</p><h3 id="change-buffer-和-redo-log"><a href="#change-buffer-和-redo-log" class="headerlink" title="change buffer 和 redo log"></a>change buffer 和 redo log</h3><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(id,k) <span class="keyword">values</span>(id1,k1),(id2,k2);</span><br></pre></td></tr></table></figure><p>k1 所在的数据页在内存 (InnoDB buffer pool) 中，k2 所在的数据页不在内存中<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648448480028-98b82840-60c9-4dec-a9da-fa2e7f384d1e.png#averageHue=%23a7bc99&clientId=ubdd7c6a3-1836-4&from=paste&id=u386044d6&originHeight=856&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=523388&status=done&style=none&taskId=udf24454a-a8ef-49b0-b750-fc23cf86083&title=" alt="image.png"><br>这条更新语句做了如下的操作（按照图中的数字顺序）：</p><ol><li>Page 1 在内存中，直接更新内存；</li><li>Page 2 没有在内存中，就在内存的 change buffer 区域，记录下“我要往 Page 2 插入一行”这个信息</li><li>将上述两个动作记入 redo log 中（图中 3 和 4）。</li></ol><p>做完上面这些，事务就可以完成了。所以，你会看到，执行这条更新语句的成本很低，就是写了两处内存，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是顺序写的。</p><p>同时，图中的两个虚线箭头，是后台操作，不影响更新的响应时间。那在这之后的读请求，要怎么处理呢？</p><p>比如，我们现在要执行 select * from t where k in (k1, k2)。以下这两个读请求的流程图。<br><code>如果读语句发生在更新语句后不久，内存中的数据都还在，那么此时的这两个读操作就与系统表空间（ibdata1）和 redo log（ib_log_fileX）无关了</code><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648448593841-dadf2d65-6d2f-4a8f-b8ed-6e5fa1737979.png#averageHue=%23bfcdb3&clientId=ubdd7c6a3-1836-4&from=paste&id=u55f462e7&originHeight=856&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=382614&status=done&style=none&taskId=u1afa9e5d-34f7-4de8-8b10-99e34853198&title=" alt="image.png"><br>读 Page 1 的时候，直接从内存返回。有几位同学在前面文章的评论中问到，WAL 之后如果读数据，是不是一定要读盘，是不是一定要从 redo log 里面把数据更新以后才可以返回？其实是不用的。你可以看一下上图的这个状态，虽然磁盘上还是之前的数据，但是这里直接从内存返回结果，结果是正确的。</p><p>要读 Page 2 的时候，需要把 Page 2 从磁盘读入内存中，然后应用 change buffer 里面的操作日志，生成一个正确的版本并返回结果。（merge后结果刷到磁盘上。）</p><p>可以看到，直到需要读 Page 2 的时候，这个数据页才会被读入内存。</p><h2 id="MySQL为什么有时候会选错索引？"><a href="#MySQL为什么有时候会选错索引？" class="headerlink" title="MySQL为什么有时候会选错索引？"></a>MySQL为什么有时候会选错索引？</h2><p>写 SQL 语句的时候，并没有主动指定使用哪个索引。也就是说，使用哪个索引是由 MySQL 来确定的。<br><code>mysql对索引的是用是由mysql的server层的优化器决定的；</code></p><p>而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少。</p><p>当然，扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。</p><p>MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息来估算记录数。</p><p>这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越大，索引的区分度越好。</p><p>我们可以使用 show index 方法，看到一个索引的基数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648454396086-286835f4-56a0-4855-bbdb-929959b8897c.png#averageHue=%23090109&clientId=ubdd7c6a3-1836-4&from=paste&id=u25bc3d64&originHeight=209&originWidth=1850&originalType=url&ratio=1&rotation=0&showTitle=false&size=42815&status=done&style=none&taskId=uac7e024d-d508-470a-9a49-13b6181534f&title=" alt="image.png"></p><p>那么，MySQL 是怎样得到索引的基数的呢？这里，我给你简单介绍一下 MySQL 采样统计的方法。</p><p>采样统计的时候，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。</p><p>而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过 1&#x2F;M 的时候，会自动触发重新做一次索引统计。</p><p>在 MySQL 中，有两种存储索引统计的方式，可以通过设置参数 innodb_stats_persistent 的值来选择：<br>设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。<br>设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。</p><h2 id="为什么我的MySQL会“抖”一下？"><a href="#为什么我的MySQL会“抖”一下？" class="headerlink" title="为什么我的MySQL会“抖”一下？"></a>为什么我的MySQL会“抖”一下？</h2><p>一条 SQL 语句，正常执行的时候特别快，但是有时也不知道怎么回事，它就会变得特别慢，并且这样的场景很难复现，它不只随机，而且持续时间还很短。</p><p>InnoDB 在处理更新语句的时候，只做了写日志这一个磁盘操作。这个日志叫作 redo log（重做日志），在更新内存写完 redo log 后，就返回给客户端，本次更新成功。</p><p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。</p><p>不论是脏页还是干净页，都在内存中。</p><p>不难想象，平时执行很快的更新操作，其实就是在写内存和日志，而 MySQL 偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）。</p><p><strong>什么情况会引发数据库的 flush 过程呢？</strong></p><ol><li>InnoDB 的 redo log 写满了。这时候系统会停止所有更新操作，把 checkpoint 往前推进，redo log 留出空间可以继续写</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648456454734-b1c65cc5-a2d1-474b-95f6-935db1efad7a.png#averageHue=%23f3f0ea&clientId=u6601b37f-239d-4&from=paste&id=X7cS6&originHeight=856&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=255505&status=done&style=none&taskId=ued0fa08d-ba43-47ee-949d-335a83988ba&title=" alt="image.png"><br><code>checkpoint 可不是随便往前修改一下位置就可以的。比如图中，把 checkpoint 位置从 CP 推进到 CP’，就需要将两个点之间的日志（浅绿色部分），对应的所有脏页都 flush 到磁盘上。之后，图中从 write pos 到 CP’之间就是可以再写入的 redo log 的区域。</code></p><ol start="2"><li>系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。</li><li>MySQL 认为系统“空闲”的时候。</li><li>MySQL 正常关闭的情况。这时候，MySQL 会把内存的脏页都 flush 到磁盘上，这样下次 MySQL 启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</li></ol><p>InnoDB 的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少。</p><p>而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。</p><p>所以，刷脏页虽然是常态，但是出现以下这两种情况，都是会明显影响性能的：</p><ul><li>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；</li><li>日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的。</li></ul><p>所以，InnoDB 需要有控制脏页比例的机制，来尽量避免上面的这两种情况。</p><h3 id="InnoDB-刷脏页的控制策略"><a href="#InnoDB-刷脏页的控制策略" class="headerlink" title="InnoDB 刷脏页的控制策略"></a>InnoDB 刷脏页的控制策略</h3><p>innodb_io_capacity 这个参数，它会告诉 InnoDB 你的磁盘能力。这个值我建议你设置成磁盘的 IOPS。磁盘的 IOPS 可以通过 fio 这个工具来测试，下面的语句是我用来测试磁盘随机读写的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest </span><br></pre></td></tr></table></figure><p><strong>所以，InnoDB 的刷盘速度就是要参考这两个因素：一个是脏页比例，一个是 redo log 写盘速度。</strong></p><p>InnoDB 会根据这两个因素先单独算出两个数字。</p><p>参数 innodb_max_dirty_pages_pct 是脏页比例上限，默认值是 75%。InnoDB 会根据当前的脏页比例（假设为 M），算出一个范围在 0 到 100 之间的数字(F1(M))，计算这个数字的伪代码类似这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">F1(M)</span><br><span class="line">&#123;</span><br><span class="line">  if M<span class="operator">&gt;=</span>innodb_max_dirty_pages_pct <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span><span class="operator">*</span>M<span class="operator">/</span>innodb_max_dirty_pages_pct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的差值，我们假设为 N。InnoDB 会根据这个 N 算出一个范围在 0 到 100 之间的数字，这个计算公式可以记为 F2(N)。F2(N) 算法比较复杂，你只要知道 N 越大，算出来的值越大就好了。</p><p>然后，根据上述算得的 F1(M) 和 F2(N) 两个值，取其中较大的值记为 R，之后引擎就可以按照 innodb_io_capacity 定义的能力乘以 R% 来控制刷脏页的速度。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648457335769-b4d029f5-e5db-49f4-afac-8d4da16e3500.png#averageHue=%23edefe4&clientId=u6601b37f-239d-4&from=paste&id=uf9222f00&originHeight=1522&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=435479&status=done&style=none&taskId=u86033bb8-9020-4268-a3f2-4bffcba8a75&title=" alt="image.png"><br>平时要多关注脏页比例，不要让它经常接近 75%。</p><p>其中，脏页比例是通过 Innodb_buffer_pool_pages_dirty&#x2F;Innodb_buffer_pool_pages_total 得到的，具体的命令参考下面的代码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@a</span> <span class="keyword">from</span> global_status <span class="keyword">where</span> VARIABLE_NAME <span class="operator">=</span> <span class="string">&#x27;Innodb_buffer_pool_pages_dirty&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@b</span> <span class="keyword">from</span> global_status <span class="keyword">where</span> VARIABLE_NAME <span class="operator">=</span> <span class="string">&#x27;Innodb_buffer_pool_pages_total&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@a</span><span class="operator">/</span><span class="variable">@b</span>;</span><br></pre></td></tr></table></figure><p>接下来，我们再看一个有趣的策略。一旦一个查询请求需要在执行过程中先 flush 掉一个脏页时，这个查询就可能要比平时慢了。而 MySQL 中的一个机制，可能让你的查询会更慢：在准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；而且这个把“邻居”拖下水的逻辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷。</p><p>在 InnoDB 中，innodb_flush_neighbors 参数就是用来控制这个行为的，值为 1 的时候会有上述的“连坐”机制，值为 0 时表示不找邻居，自己刷自己的。</p><h2 id="为什么表数据删掉一半，表文件大小不变？"><a href="#为什么表数据删掉一半，表文件大小不变？" class="headerlink" title="为什么表数据删掉一半，表文件大小不变？"></a>为什么表数据删掉一半，表文件大小不变？</h2><h3 id="参数-innodb-file-per-table"><a href="#参数-innodb-file-per-table" class="headerlink" title="参数 innodb_file_per_table"></a>参数 innodb_file_per_table</h3><p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数 innodb_file_per_table 控制的：</p><ul><li>这个参数设置为 OFF 表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</li><li>这个参数设置为 ON 表示的是，每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中。</li></ul><p>从 MySQL 5.6.6 版本开始，它的默认值就是 ON 了。</p><p>因为，一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过 drop table 命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。</p><p>将 innodb_file_per_table 设置为 ON，是推荐做法，我们接下来的讨论都是基于这个设置展开的。</p><h3 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648458246901-2059df42-0c96-480b-ab06-32e2de24bf39.png#averageHue=%23f1f1eb&clientId=u6601b37f-239d-4&from=paste&id=u60cc30d7&originHeight=856&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=125104&status=done&style=none&taskId=uea35a2b3-8b62-4c81-996a-89295f00942&title=" alt="image.png"><br>假设，我们要删掉 R4 这个记录，InnoDB 引擎只会把 R4 这个记录标记为删除。如果之后要再插入一个 ID 在 300 和 600 之间的记录时，可能会复用这个位置。但是，磁盘文件的大小并不会缩小。 (也就是逻辑删除)</p><p>记录的复用，只限于符合范围条件的数据。比如上面的这个例子，R4 这条记录被删除后，如果插入一个 ID 是 400 的行，可以直接复用这个空间。但如果插入的是一个 ID 是 800 的行，就不能复用这个位置了。</p><p>而当整个页从 B+ 树里面摘掉以后，可以复用到任何位置。以上 为例，如果将数据页 page A 上的所有记录删除以后，page A 会被标记为可复用。这时候如果要插入一条 ID&#x3D;50 的记录需要使用新页的时候，page A 是可以被复用的。</p><p>如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用。</p><p>进一步地，如果我们用 delete 命令把整个表的数据删除呢？结果就是，所有的数据页都会被标记为可复用。但是磁盘上，文件不会变小。</p><p>你现在知道了，delete 命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。也就是说，通过 delete 命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是“空洞”。</p><p>实际上，不止是删除数据会造成空洞，插入数据也会。</p><p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。<br>假设下图中 page A 已经满了，这时我要再插入一行数据，会怎样呢？<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648459031612-11d73511-84fb-4435-a36c-041513621a6e.png#averageHue=%23ecece4&clientId=u6601b37f-239d-4&from=paste&id=ub5d91120&originHeight=1522&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=386541&status=done&style=none&taskId=u936777ff-9e33-4869-a5d0-ec6cc0b8295&title=" alt="image.png"><br>可以看到，由于 page A 满了，再插入一个 ID 是 550 的数据时，就不得不再申请一个新的页面 page B 来保存数据了。页分裂完成后，page A 的末尾就留下了空洞（注意：实际上，可能不止 1 个记录的位置是空洞）。另外，更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。不难理解，这也是会造成空洞的。</p><p>也就是说，经过大量增删改的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。而重建表，就可以达到这样的目的。</p><h3 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h3><p>试想一下，如果你现在有一个表 A，需要做空间收缩，为了把表中存在的空洞去掉，你可以怎么做呢？</p><p>你可以新建一个与表 A 结构相同的表 B，然后按照主键 ID 递增的顺序，把数据一行一行地从表 A 里读出来再插入到表 B 中。</p><p>由于表 B 是新建的表，所以表 A 主键索引上的空洞，在表 B 中就都不存在了。显然地，表 B 的主键索引更紧凑，数据页的利用率也更高。如果我们把表 B 作为临时表，数据从表 A 导入表 B 的操作完成后，用表 B 替换 A，从效果上看，就起到了收缩表 A 空间的作用。</p><p>这里，你可以使用 <strong>alter table A engine&#x3D;InnoDB</strong> 命令来重建表。在 MySQL 5.5 版本之前，这个命令的执行流程跟我们前面描述的差不多，区别只是这个临时表 B 不需要你自己创建，MySQL 会自动完成转存数据、交换表名、删除旧表的操作。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648460656185-14aee1dd-885c-47b2-a030-28ea6ec8cb57.png#averageHue=%23eae9df&clientId=u6601b37f-239d-4&from=paste&id=u9c4de8a8&originHeight=856&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=514037&status=done&style=none&taskId=uc61ce6a1-1af4-40f9-a3aa-94c8c8cbb13&title=" alt="image.png"></p><p>显然，花时间最多的步骤是往临时表插入数据的过程，如果在这个过程中，有新的数据要写入到表 A 的话，就会造成数据丢失。因此，在整个 DDL 过程中，表 A 中不能有更新。也就是说，这个 DDL 不是 Online 的。</p><p><strong>而在 MySQL 5.6 版本开始引入的 Online DDL，对这个操作流程做了优化。</strong></p><p>简单描述一下引入了 Online DDL 之后，重建表的流程：</p><ol><li>建立一个临时文件，扫描表 A 主键的所有数据页；</li><li>用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；</li><li>生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中，对应的是图中 state2 的状态；</li><li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件，对应的就是图中 state3 的状态；</li><li>用临时文件替换表 A 的数据文件。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648460673335-4500620b-e333-4439-8366-d2f4c69765aa.png#averageHue=%23e8e8dd&clientId=u6601b37f-239d-4&from=paste&id=u53977a6f&originHeight=856&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=397982&status=done&style=none&taskId=u68a17300-301c-4350-b4ff-8913ac7b306&title=" alt="image.png"><br><code>Online DDL 其实是会先获取MDL写锁, 再退化成MDL读锁；但MDL写锁持有时间比较短，所以可以称为Online； 而MDL读锁，不阻止数据增删查改，但会阻止其它线程修改表结构；</code></p><h2 id="count-这么慢，我该怎么办？"><a href="#count-这么慢，我该怎么办？" class="headerlink" title="count(*)这么慢，我该怎么办？"></a>count(*)这么慢，我该怎么办？</h2><h3 id="count-的实现方式"><a href="#count-的实现方式" class="headerlink" title="count(*) 的实现方式"></a>count(*) 的实现方式</h3><ul><li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；</li><li>而 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li></ul><p><code>MyISAM count 是存储在硬盘，这只是无条件查询的时候，如果有where条件，也是和InnoDB一样</code></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648518819244-17e71729-17f5-41d0-af7f-c120ae34b61d.png#averageHue=%23f9f9f9&clientId=ue5c9d5d3-f062-4&from=paste&id=u1d9077ed&originHeight=362&originWidth=943&originalType=url&ratio=1&rotation=0&showTitle=false&size=68577&status=done&style=none&taskId=u52029278-5cd6-4933-bd23-f236702007c&title=" alt="image.png"><br>这和 InnoDB 的事务设计有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制，也就是 MVCC 来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于 count(*) 请求来说，InnoDB 只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。</p><p>你知道的，InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于 count(*) 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，<strong>MySQL 优化器会找到最小的那棵树来遍历</strong>。在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。</p><h3 id="不同的-count-用法"><a href="#不同的-count-用法" class="headerlink" title="不同的 count 用法"></a>不同的 count 用法</h3><p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。</p><p>所以，count(*)、count(主键 id) 和 count(1) 都表示返回满足条件的结果集的总行数；而 count(字段），则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。</p><p><strong>对于 count(主键 id) 来说</strong>，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</p><p><strong>对于 count(1) 来说</strong>，InnoDB 引擎遍历整张表，<strong>但不取值</strong>。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p><p>单看这两个用法的差别的话，能对比出来，count(1) 执行得要比 count(主键 id) 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。</p><p><strong>对于 count(字段) 来说</strong>：如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；<br>如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。</p><p><strong>但是 count(*) 是例外</strong>，并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。</p><p>所以结论是：按照效率排序的话，<strong>count(字段)&lt;count(主键 id)&lt;count(1)≈count(*)</strong></p><h2 id="“order-by”是怎么工作的？"><a href="#“order-by”是怎么工作的？" class="headerlink" title="“order by”是怎么工作的？"></a>“order by”是怎么工作的？</h2><h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> city,name,age <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>  ;(city上有索引)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648563803148-12d05c2e-862d-41a3-92cc-079081c02eec.png#averageHue=%2305040e&clientId=ub49b8c3b-28e5-4&from=paste&id=u51b876bf&originHeight=126&originWidth=1470&originalType=url&ratio=1&rotation=0&showTitle=false&size=275103&status=done&style=none&taskId=u04ab12bb-161a-4189-8085-6ff37e68c53&title=" alt="image.png"><br>Extra 这个字段中的“Using filesort”表示的就是需要排序，MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648563889459-6771ce6b-40c0-43fe-b195-d8b4fd06dba4.png#averageHue=%23f1f0ea&clientId=ub49b8c3b-28e5-4&from=paste&id=u5ad65b3c&originHeight=856&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=244167&status=done&style=none&taskId=u4687b797-6402-426d-b26f-c616d1dcf1f&title=" alt="image.png"><br>从图中可以看到，满足 city&#x3D;’杭州’条件的行，是从 ID_X 到 ID_(X+N) 的这些记录。<br>通常情况下，这个语句执行流程如下所示 ：</p><ol><li>初始化 sort_buffer，确定放入 name、city、age 这三个字段；</li><li>从索引 city 找到第一个满足 city&#x3D;’杭州’条件的主键 id，也就是图中的 ID_X；</li><li>到主键 id 索引取出整行，取 name、city、age 三个字段的值，存入 sort_buffer 中；</li><li>从索引 city 取下一个记录的主键 id；</li><li>重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的 ID_Y；</li><li>对 sort_buffer 中的数据按照字段 name 做快速排序；</li><li>按照排序结果取前 1000 行返回给客户端。</li></ol><p>图中“按 name 排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 sort_buffer_size。</p><p>sort_buffer_size，就是 MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</p><p>可以用下面介绍的方法，来确定一个排序语句是否使用了临时文件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 打开optimizer_trace，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span><span class="string">&#x27;enabled=on&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* @a保存Innodb_rows_read的初始值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@a</span> <span class="keyword">from</span>  performance_schema.session_status <span class="keyword">where</span> variable_name <span class="operator">=</span> <span class="string">&#x27;Innodb_rows_read&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> city, name,age <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `information_schema`.`OPTIMIZER_TRACE`\G</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @b保存Innodb_rows_read的当前值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> <span class="variable">@b</span> <span class="keyword">from</span> performance_schema.session_status <span class="keyword">where</span> variable_name <span class="operator">=</span> <span class="string">&#x27;Innodb_rows_read&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算Innodb_rows_read差值 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@b</span><span class="operator">-</span><span class="variable">@a</span>;</span><br></pre></td></tr></table></figure><p>这个方法是通过查看 OPTIMIZER_TRACE 的结果来确认的，你可以从 number_of_tmp_files 中看到是否使用了临时文件。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648564689820-6f0d8fa4-6687-4e4f-ad20-5e6a1d4a1280.png#averageHue=%23090109&clientId=ub49b8c3b-28e5-4&from=paste&id=ud81073ab&originHeight=183&originWidth=713&originalType=url&ratio=1&rotation=0&showTitle=false&size=103799&status=done&style=none&taskId=ufc87cf83-e1f6-4102-90a8-7243ba19e13&title=" alt="image.png"><br>number_of_tmp_files 表示的是，排序过程中使用的临时文件数。你一定奇怪，为什么需要 12 个文件？内存放不下时，就需要使用外部排序，外部排序一般使用归并排序算法。可以这么简单理解，MySQL 将需要排序的数据分成 12 份，每一份单独排序后存在这些临时文件中。然后把这 12 个有序文件再合并成一个有序的大文件。</p><p>如果 sort_buffer_size 超过了需要排序的数据量的大小，number_of_tmp_files 就是 0，表示排序可以直接在内存中完成。</p><p>否则就需要放在临时文件中排序。<strong>sort_buffer_size 越小，需要分成的份数越多</strong>，number_of_tmp_files 的值就越大。（理解成每一份临时文件也会在内存中排序，sort_buffer_size可以理解成一次内存排序的内存大小，所以每一份临时文件大小就取决于sort_buffer_size的大小）</p><p><strong>examined_rows&#x3D;4000，表示参与排序的行数是 4000 行。</strong></p><p><strong>sort_mode 里面的 packed_additional_fields 的意思是，排序过程对字符串做了“紧凑”处理。即使 name 字段的定义是 varchar(16)，在排序过程中还是要按照实际长度来分配空间的。</strong></p><p><strong>同时，最后一个查询语句 select @b-@a 的返回结果是 4000，表示整个执行过程只扫描了 4000 行。</strong></p><h3 id="rowid-排序"><a href="#rowid-排序" class="headerlink" title="rowid 排序"></a>rowid 排序</h3><p>在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在 sort_buffer 和临时文件中执行的。但这个算法有一个问题，就是<strong>如果查询要返回的字段很多的话，那么 sort_buffer 里面要放的字段数太多，这样内存里能够同时放下的行数很少</strong>，要分成很多个临时文件，排序的性能会很差。</p><p>所以如果单行很大，这个方法效率不够好。</p><p>如果 MySQL 认为排序的单行长度太大会怎么做呢?</p><p>接下来，修改一个参数，让 MySQL 采用另外一种算法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> max_length_for_sort_data <span class="operator">=</span> <span class="number">16</span>;</span><br></pre></td></tr></table></figure><p>上面这个参数是MySQL 中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。</p><p>新的算法放入 sort_buffer 的字段，只有要排序的列（即 name 字段）和主键 id。</p><p>但这时，排序的结果就因为少了 city 和 age 字段的值，不能直接返回了，整个执行流程就变成如下所示的样子：</p><ol><li>初始化 sort_buffer，确定放入两个字段，即 name 和 id；</li><li>从索引 city 找到第一个满足 city&#x3D;’杭州’条件的主键 id，也就是图中的 ID_X；</li><li>到主键 id 索引取出整行，取 name、id 这两个字段，存入 sort_buffer 中；</li><li>从索引 city 取下一个记录的主键 id；</li><li>重复步骤 3、4 直到不满足 city&#x3D;’杭州’条件为止，也就是图中的 ID_Y；</li><li>对 sort_buffer 中的数据按照字段 name 进行排序；</li><li>遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。</li></ol><p>对比全字段排序流程你会发现，rowid 排序多访问了一次表 t 的主键索引，就是步骤 7。</p><p>需要说明的是，最后的“结果集”是一个逻辑概念，实际上 MySQL 服务端从排序后的 sort_buffer 中依次取出 id，然后到原表查到 city、name 和 age 这三个字段的结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的。<code>需要按顺序使用主键再从索引树上查询，查到一个就返回一个</code></p><p><strong>rowid 排序的 OPTIMIZER_TRACE 部分输出</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648566128890-cf3076d8-183b-4f66-95fb-6db07943954f.png#averageHue=%23080109&clientId=ub49b8c3b-28e5-4&from=paste&id=u025fd973&originHeight=183&originWidth=468&originalType=url&ratio=1&rotation=0&showTitle=false&size=93232&status=done&style=none&taskId=uaae4be2c-c501-4cc6-b296-5a9fed1e59a&title=" alt="image.png"><br><strong>select @b-@a 这个语句的值变成 5000 了。</strong>因为这时候除了排序过程外，在排序完成后，还要根据 id 去原表取值。由于语句是 limit 1000，因此会多读 1000 行。</p><p><strong>sort_mode 变成了 &lt;sort_key, rowid&gt;，</strong>表示参与排序的只有 name 和 id 这两个字段。</p><p><strong>number_of_tmp_files 变成 10 了</strong>，是因为这时候参与排序的行数虽然仍然是 4000 行，但是每一行都变小了，因此需要排序的总数据量就变小了，需要的临时文件也相应地变少了。</p><p>如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</p><p>如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</p><p>这也就体现了 MySQL 的一个设计思想：<strong>如果内存够，就要多利用内存，尽量减少磁盘访问。</strong></p><p>其实，并不是所有的 order by 语句，都需要排序操作的。从上面分析的执行过程，我们可以看到，MySQL 之所以需要生成临时表，并且在临时表上做排序操作，其<strong>原因是原来的数据都是无序的。</strong></p><p>如果能够保证从 city 这个索引上取出来的行，天然就是按照 name 递增排序的话，是不是就可以不用再排序了呢？</p><p>所以，我们可以在表上创建一个 city 和 name 的联合索引<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648566346093-471e3c9b-0b83-4c38-95cd-1c6b5d7f58ca.png#averageHue=%23f0efe8&clientId=ub49b8c3b-28e5-4&from=paste&id=u9d957077&originHeight=856&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=250929&status=done&style=none&taskId=ub68238d3-09db-4d04-9d04-8aa7a1bb945&title=" alt="image.png"><br>在这个索引里面，我们依然可以用树搜索的方式定位到第一个满足 city&#x3D;’杭州’的记录，并且额外确保了，接下来按顺序取“下一条记录”的遍历过程中，只要 city 的值是杭州，name 的值就一定是有序的。</p><p>这样整个查询过程的流程就变成了：</p><ol><li>从索引 (city,name) 找到第一个满足 city&#x3D;’杭州’条件的主键 id；</li><li>到主键 id 索引取出整行，取 name、city、age 三个字段的值，作为结果集的一部分直接返回；</li><li>从索引 (city,name) 取下一个记录主键 id；重复步骤 2、3，</li><li>直到查到第 1000 条记录，或者是不满足 city&#x3D;’杭州’条件时循环结束。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648566428823-b2716a19-cb2c-48a4-a0ad-94552cf1ae7d.png#averageHue=%2307020a&clientId=ub49b8c3b-28e5-4&from=paste&id=u30022e94&originHeight=127&originWidth=1382&originalType=url&ratio=1&rotation=0&showTitle=true&size=250223&status=done&style=none&taskId=u72da902c-04e1-462b-87e2-4c65adca397&title=%E5%BC%95%E5%85%A5%20%28city%2Cname%29%20%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%90%8E%EF%BC%8C%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92" alt="引入 (city,name) 联合索引后，查询语句的执行计划" title="引入 (city,name) 联合索引后，查询语句的执行计划"><br><code>图中rows是预估行数,【Using index condition】 使用了索引下推技术ICP</code> </p><p>从图中可以看到，Extra 字段中没有 Using filesort 了，也就是不需要排序了。而且由于 (city,name) 这个联合索引本身有序，所以这个查询也不用把 4000 行全都读一遍，只要找到满足条件的前 1000 条记录就可以退出了。也就是说，在我们这个例子里，<strong>只需要扫描 1000 次</strong>。</p><p>当然如果想要进步优化，可以使用覆盖索引，针对这个查询，我们可以创建一个 city、name 和 age 的联合索引。</p><p>这时，对于 city 字段的值相同的行来说，还是按照 name 字段的值递增排序的，此时的查询语句也就不再需要排序了。这样整个查询语句的执行流程就变成了：</p><ol><li>从索引 (city,name,age) 找到第一个满足 city&#x3D;’杭州’条件的记录，取出其中的 city、name 和 age 这三个字段的值，作为结果集的一部分直接返回；</li><li>从索引 (city,name,age) 取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接返回；</li><li>重复执行步骤 2，直到查到第 1000 条记录，或者是不满足 city&#x3D;’杭州’条件时循环结束。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648566612447-97a4f6c2-8f67-4a0b-8614-eb63ab8093aa.png#averageHue=%2306030d&clientId=ub49b8c3b-28e5-4&from=paste&id=ufc70bd2c&originHeight=125&originWidth=1586&originalType=url&ratio=1&rotation=0&showTitle=true&size=266076&status=done&style=none&taskId=u3093dc9d-f32b-4b81-b102-2d08dd4fe1b&title=%E5%BC%95%E5%85%A5%20%28city%2Cname%2Cage%29%20%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%90%8E%EF%BC%8C%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92" alt="引入 (city,name,age) 联合索引后，查询语句的执行计划" title="引入 (city,name,age) 联合索引后，查询语句的执行计划">可以看到，Extra 字段里面多了“Using index”，表示的就是使用了覆盖索引，性能上会快很多。</p><h2 id="order-by-rand"><a href="#order-by-rand" class="headerlink" title="order by rand()"></a>order by rand()</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> rand() limit <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>这个语句的意思很直白，随机排序取前 3 个。虽然这个 SQL 语句写法很简单，但执行流程却有点复杂的。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648802439889-2e2907be-5fc4-411a-b79f-f9a29153b597.png#averageHue=%2308020a&clientId=ud645e606-5915-4&from=paste&id=u14caa359&originHeight=142&originWidth=1553&originalType=url&ratio=1&rotation=0&showTitle=false&size=269434&status=done&style=none&taskId=uc50316d7-c136-4ce7-92d6-3c16c7a8496&title=" alt="image.png"><br>Extra 字段显示 Using temporary，表示的是需要使用临时表；Using filesort，表示的是需要执行排序操作。</p><p>对于 InnoDB 表来说，执行全字段排序会减少磁盘访问，因此会被优先选择。<br>对于内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，根本不会导致多访问磁盘。优化器没有了这一层顾虑，那么它会优先考虑的，就是用于排序的行越小越好了，所以，MySQL 这时就会选择 rowid 排序。</p><p>语句执行流程:</p><ol><li>创建一个临时表。这个临时表使用的是 memory 引擎，表里有两个字段，第一个字段是 double 类型，为了后面描述方便，记为字段 R，第二个字段是 varchar(64) 类型，记为字段 W。并且，这个表没有建索引。</li><li>从 words 表中，按主键顺序取出所有的 word 值。对于每一个 word 值，调用 rand() 函数生成一个大于 0 小于 1 的随机小数，并把这个随机小数和 word 分别存入临时表的 R 和 W 字段中，到此，扫描行数是 10000。</li><li>现在临时表有 10000 行数据了，接下来你要在这个没有索引的内存临时表上，按照字段 R 排序。</li><li>初始化 sort_buffer。sort_buffer 中有两个字段，一个是 double 类型，另一个是整型。</li><li>从内存临时表中一行一行地取出 R 值和位置信息，分别存入 sort_buffer 中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加 10000，变成了 20000。</li><li>在 sort_buffer 中根据 R 的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。</li><li>排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出 word 值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了 20003。</li></ol><p>如果你创建的表没有主键，或者把一个表的主键删掉了，那么 InnoDB 会自己生成一个长度为 6 字节的 rowid 来作为主键。这也就是排序模式里面，rowid 名字的来历。实际上它表示的是：每个引擎用来唯一标识数据行的信息。对于有主键的 InnoDB 表来说，这个 rowid 就是主键 ID；对于没有主键的 InnoDB 表来说，这个 rowid 就是由系统生成的；MEMORY 引擎不是索引组织表。在这个例子里面，你可以认为它就是一个数组。因此，这个 rowid 其实就是数组的下标。</p><p><strong>order by rand() 使用了内存临时表，内存临时表排序的时候使用了 rowid 排序方法。</strong></p><p><strong>那么，是不是所有的临时表都是内存表呢？</strong></p><p>其实不是的。**tmp_table_size **这个配置限制了内存临时表的大小，默认值是 16M。如果临时表大小超过了 tmp_table_size，那么内存临时表就会转成磁盘临时表。</p><p>磁盘临时表使用的引擎默认是 InnoDB，是由参数 <strong>internal_tmp_disk_storage_engine</strong> 控制的。<br>当使用磁盘临时表的时候，对应的就是一个没有显式索引的 InnoDB 表的排序过程。</p><h3 id="优先队列排序算法"><a href="#优先队列排序算法" class="headerlink" title="优先队列排序算法"></a>优先队列排序算法</h3><p>其实，我们现在的 SQL 语句，只需要取 R 值最小的 3 个 rowid。但是，如果使用归并排序算法的话，虽然最终也能得到前 3 个值，但是这个算法结束后，已经将 10000 行数据都排好序了。也就是说，后面的 9997 行也是有序的了。但，我们的查询并不需要这些数据是有序的。所以，想一下就明白了，这浪费了非常多的计算量。</p><p>流程：<code>也就是堆排序</code></p><ul><li>对于这 10000 个准备排序的 (R,rowid)，先取前三行，构造成一个堆；</li><li>取下一个行 (R’,rowid’)，跟当前堆里面最大的 R 比较，如果 R’小于 R，把这个 (R,rowid) 从堆中去掉，换成 (R’,rowid’)；</li><li>重复第 2 步，直到第 10000 个 (R’,rowid’) 完成比较。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> city,name,age <span class="keyword">from</span> t <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>  ;</span><br></pre></td></tr></table></figure><p>这里也用到了 limit，为什么没用优先队列排序算法呢？原因是，这条 SQL 语句是 limit 1000，如果使用优先队列算法的话，需要维护的堆的大小就是 1000 行的 (name,rowid)，超过了我设置的 sort_buffer_size 大小，所以只能使用归并排序算法。<code>limit 3 就远不及sort_buffer_size 大小</code></p><h2 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(id <span class="type">int</span> <span class="keyword">primary</span> key, a <span class="type">int</span>, b <span class="type">int</span>, index(a));</span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">  while(i<span class="operator">&lt;=</span><span class="number">1000</span>)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id<span class="operator">%</span><span class="number">10</span> <span class="keyword">as</span> m, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651112503277-b1df9ad1-1d95-417a-b8e9-48a390770a29.png#averageHue=%23090109&clientId=ud1598026-e3a9-4&from=paste&id=ua744d424&originHeight=143&originWidth=1702&originalType=url&ratio=1&rotation=0&showTitle=false&size=30065&status=done&style=none&taskId=u53a60222-d9e4-44f3-a5c7-c090d7a9176&title=" alt="image.png"><br>在 Extra 字段里面，我们可以看到三个信息：</p><ul><li>Using index，表示这个语句使用了覆盖索引，选择了索引 a，不需要回表；</li></ul><p><code>因为select用到的实际字段只有id，索引a和主键都能满足这个要求，且索引a叶子节点只存放主键所以体  积更小，于是mysql选择了索引a。</code></p><ul><li>Using temporary，表示使用了临时表；</li><li>Using filesort，表示需要排序。</li></ul><p>语句的执行流程:</p><ul><li>创建内存临时表，表里有两个字段 m 和 c，主键是 m；</li><li>扫描表 t1 的索引 a，依次取出叶子节点上的 id 值，计算 id%10 的结果，记为 x；</li><li>如果临时表中没有主键为 x 的行，就插入一个记录 (x,1);</li><li>如果表中有主键为 x 的行，就将 x 这一行的 c 值加 1；遍历完成后，再根据字段 m 做排序，得到结果集返回给客户端。</li></ul><h3 id="group-by-优化方法-–-索引"><a href="#group-by-优化方法-–-索引" class="headerlink" title="group by 优化方法 – 索引"></a><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651112629688-9b998014-3798-4028-931b-9518eb10ce2a.png#averageHue=%23eceee3&clientId=ud1598026-e3a9-4&from=paste&id=u878ce08e&originHeight=880&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=184375&status=done&style=none&taskId=ub60c1c98-b904-4010-937c-eea5dfc94e9&title=" alt="image.png">group by 优化方法 – 索引</h3><p>可以看到，不论是使用内存临时表还是磁盘临时表，group by 逻辑都需要构造一个带唯一索引的表，执行代价都是比较高的。如果表的数据量比较大，上面这个 group by 语句执行起来就会很慢，我们有什么优化的方法呢？</p><p><strong>执行 group by 语句为什么需要临时表？</strong><br>group by 的语义逻辑，是统计不同的值出现的个数。但是，由于每一行的 id%100 的结果是无序的，所以我们就需要有一个临时表，来记录并统计结果。</p><p>那么，如果扫描过程中可以保证出现的数据是有序的，是不是就简单了呢<br>所以在group by的字段上加上索引 就不会在使用临时表了</p><h3 id="group-by-优化方法-–-直接排序"><a href="#group-by-优化方法-–-直接排序" class="headerlink" title="group by 优化方法 – 直接排序"></a>group by 优化方法 – 直接排序</h3><p>所以，如果可以通过加索引来完成 group by 逻辑就再好不过了。但是，如果碰上不适合创建索引的场景，我们还是要老老实实做排序的。那么，这时候的 group by 要怎么优化呢？</p><p>在 group by 语句中加入 SQL_BIG_RESULT 这个提示（hint），就可以告诉优化器：这个语句涉及的数据量很大，请直接用磁盘临时表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SQL_BIG_RESULT id<span class="operator">%</span><span class="number">100</span> <span class="keyword">as</span> m, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m;</span><br></pre></td></tr></table></figure><p>MySQL 的优化器一看，磁盘临时表是 B+ 树存储，存储效率不如数组来得高。所以，既然你告诉我数据量很大，那从磁盘空间考虑，还是直接用数组来存吧。<br>因此，上面这个语句的执行流程就是这样的：</p><ul><li>初始化 sort_buffer，确定放入一个整型字段，记为 m；</li><li>扫描表 t1 的索引 a，依次取出里面的 id 值, 将 id%100 的值存入 sort_buffer 中；</li><li>扫描完成后，对 sort_buffer 的字段 m 做排序（如果 sort_buffer 内存不够用，就会利用磁盘临时文件辅助排序）；</li><li>排序完成后，就得到了一个有序数组。</li></ul><p>根据有序数组，得到数组里面的不同值，以及每个值的出现次数。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651113519486-bb3649d2-8c16-4e6a-8062-50510591e8a6.png#averageHue=%23ecede2&clientId=ud1598026-e3a9-4&from=paste&id=u6443cf73&originHeight=880&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=210067&status=done&style=none&taskId=u0c92938c-024f-4ede-8a67-6aa3e16f37b&title=" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651113533494-091befc2-665e-42da-a822-2fa5fc25cb92.png#averageHue=%23090109&clientId=ud1598026-e3a9-4&from=paste&id=u68823f55&originHeight=131&originWidth=1393&originalType=url&ratio=1&rotation=0&showTitle=false&size=26738&status=done&style=none&taskId=u04fcce2b-a93b-4148-a3cf-bb5c45ac1b9&title=" alt="image.png"><br>从 Extra 字段可以看到，这个语句的执行没有再使用临时表，而是直接用了排序算法。<br><strong>如果 group by 需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大 tmp_table_size 参数，来避免用到磁盘临时表；</strong></p><h3 id="MySQL-什么时候会使用内部临时表？"><a href="#MySQL-什么时候会使用内部临时表？" class="headerlink" title="MySQL 什么时候会使用内部临时表？"></a>MySQL 什么时候会使用内部临时表？</h3><ol><li>如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果；</li><li>join_buffer 是无序数组，sort_buffer 是有序数组，临时表是二维表结构；</li><li>如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。比如我们的例子中，union 需要用到唯一索引约束， group by 还需要用到另外一个字段来存累积计数。</li></ol><h2 id="索引失效的案例"><a href="#索引失效的案例" class="headerlink" title="索引失效的案例"></a>索引失效的案例</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">month</span>(t_modified)<span class="operator">=</span><span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">t_modified加了索引</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行会发现sql执行很慢，因为如果对字段做了函数计算，就用不上索引了，这是 MySQL 的规定。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648822518074-948569d9-c7f4-49f5-9441-51b175a23451.png#averageHue=%23f0f1e8&clientId=ud5261830-7282-4&from=paste&id=ua20d9e1f&originHeight=856&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=true&size=191123&status=done&style=none&taskId=u64ba332a-9084-4148-a92a-ecdce1abbba&title=t_modified%20%E7%B4%A2%E5%BC%95%E7%A4%BA%E6%84%8F%E5%9B%BE" alt="t_modified 索引示意图" title="t_modified 索引示意图"><br>如果你的 SQL 语句条件用的是 where t_modified&#x3D;’2018-7-1’的话，引擎就会按照上面绿色箭头的路线，快速定位到 t_modified&#x3D;’2018-7-1’需要的结果。<br><strong>但是，如果计算 month() 函数的话，你会看到传入 7 的时候，在树的第一层就不知道该怎么办了。</strong></p><p><strong>也就是说，对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong><br>但是优化器并不是放弃了这个索引，但是显然无法快速搜索到想要的值，只能全索引扫描，遍历索引树</p><p>这个例子里，放弃了树搜索功能，优化器可以选择遍历主键索引，也可以选择遍历索引 t_modified，优化器对比索引大小后发现，索引 t_modified 更小，遍历这个索引比遍历主键索引来得更快。因此最终还是会选择索引 t_modified。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648822684575-4deb9a96-f251-4f0c-a536-19871141453c.png#averageHue=%23090109&clientId=ud5261830-7282-4&from=paste&id=u523bd677&originHeight=143&originWidth=1637&originalType=url&ratio=1&rotation=0&showTitle=true&size=30107&status=done&style=none&taskId=u05bb406e-1cdf-4bce-933e-d07153bbc8c&title=explain%E7%BB%93%E6%9E%9C" alt="explain结果" title="explain结果"><br><code>不过优化器在个问题上确实有“偷懒”行为，即使是对于不改变有序性的函数，也不会考虑使用索引。比如，对于 select * from tradelog where id + 1 = 10000 这个 SQL 语句，这个加 1 操作并不会改变有序性，但是 MySQL 优化器还是不能用 id 索引快速定位到 9999 这一行。所以，需要你在写 SQL 语句的时候，手动改写成 where id = 10000 -1 才可以。</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> tradeid<span class="operator">=</span><span class="number">110717</span>;</span><br><span class="line">tradeid上有索引</span><br><span class="line">tradeid 的字段类型是 <span class="type">varchar</span>(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">tradelog 交易记录表</span><br></pre></td></tr></table></figure><p>explain 的结果却显示，这条语句需要走全表扫描。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648823298719-44df7f75-794e-4dc6-ac68-e1be2aee1bf7.png#averageHue=%23090109&clientId=ud5261830-7282-4&from=paste&id=uf55b0bbd&originHeight=142&originWidth=289&originalType=url&ratio=1&rotation=0&showTitle=false&size=6704&status=done&style=none&taskId=u73751b53-f437-460b-90a1-85cdf341157&title=" alt="image.png"><br>从图中可知，select “10” &gt; 9 返回的是 1，所以就能确认 MySQL 里的转换规则了：在 MySQL 中，字符串和数字做比较的话，是将字符串转换成数字。<br><code>字符串比较大小是逐位从高位到低位逐个比较（按ascii码） 那么“10”的“1”的ascii比“9”小，所以结果为0</code></p><p>所以上面这个sql相当于</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span>  <span class="built_in">CAST</span>(tradid <span class="keyword">AS</span> signed <span class="type">int</span>) <span class="operator">=</span> <span class="number">110717</span>;</span><br></pre></td></tr></table></figure><p>也就是说，这条语句触发了我们上面说到的规则：对索引字段做函数操作，优化器会放弃走树搜索功能。</p><h2 id="select-被阻塞"><a href="#select-被阻塞" class="headerlink" title="select 被阻塞"></a>select 被阻塞</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>发现查询长时间不返回</p><p>一般碰到这种情况的话，大概率是表 t 被锁住了。接下来分析原因的时候，一般都是首先执行一下 show processlist 命令，看看当前语句处于什么状态。</p><h3 id="等MDL锁"><a href="#等MDL锁" class="headerlink" title="等MDL锁"></a>等MDL锁</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648878603446-1b67ed04-aa0f-4961-bdb2-c048db08684d.png#averageHue=%23080109&clientId=u9da0f65c-5a8c-4&from=paste&id=u6b91757f&originHeight=213&originWidth=1312&originalType=url&ratio=1&rotation=0&showTitle=true&size=295984&status=done&style=none&taskId=ua6b64a57-39e2-4f8b-a20b-acb19d0de19&title=Waiting%20for%20table%20metadata%20lock" alt="Waiting for table metadata lock" title="Waiting for table metadata lock"><br>出现这个状态表示的是，现在有一个线程正在表 t 上请求或者持有 MDL 写锁，把 select 语句堵住了。</p><p>但是，由于在 show processlist 的结果里面，session A 的 Command 列是“Sleep”，导致查找起来很不方便。不过有了 performance_schema 和 sys 系统库以后，就方便多了。（MySQL 启动时需要设置 performance_schema&#x3D;on，相比于设置为 off 会有 10% 左右的性能损失)</p><p>通过查询 <strong>sys.schema_table_lock_waits</strong> 这张表，我们就可以直接找出造成阻塞的 process id，把这个连接用 kill 命令断开即可。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648878943676-cb1e66f6-9274-4266-8aa5-3473ff341e1b.png#averageHue=%23f7f7f7&clientId=u9da0f65c-5a8c-4&from=paste&id=ud724efe0&originHeight=251&originWidth=940&originalType=url&ratio=1&rotation=0&showTitle=false&size=83355&status=done&style=none&taskId=u8346b506-65e9-42ee-b198-0ecd2158dde&title=" alt="image.png"></p><h3 id="等flush"><a href="#等flush" class="headerlink" title="等flush"></a>等flush</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648879417166-43881340-f096-4563-b5e4-9bc5829cc62b.png#averageHue=%2308010a&clientId=u9da0f65c-5a8c-4&from=paste&id=u25a60694&originHeight=147&originWidth=1221&originalType=url&ratio=1&rotation=0&showTitle=true&size=221669&status=done&style=none&taskId=u5a5b1b06-1adc-4505-9c55-cfed57c8142&title=Waiting%20for%20table%20flush" alt="Waiting for table flush" title="Waiting for table flush"><br>这个状态表示的是，现在有一个线程正要对表 t 做 flush 操作。MySQL 里面对表做 flush 操作的用法，一般有以下两个：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flush tables t <span class="keyword">with</span> read lock;</span><br><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br></pre></td></tr></table></figure><p>这两个 flush 语句，如果指定表 t 的话，代表的是只关闭表 t；如果没有指定具体的表名，则表示关闭 MySQL 里所有打开的表。</p><p>但是正常这两个语句执行起来都很快，除非它们也被别的线程堵住了</p><p>所以，出现 Waiting for table flush 状态的可能情况是：有一个 flush tables 命令被别的语句堵住了，然后它又堵住了我们的 select 语句。<br>所以我们只要结束阻塞 flush命令的线程就可以了</p><h3 id="等行锁"><a href="#等行锁" class="headerlink" title="等行锁"></a>等行锁</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure><p>由于访问 id&#x3D;1 这个记录时要加读锁，如果这时候已经有一个事务在这行记录上持有一个写锁，我们的 select 语句就会被堵住。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648881044186-e94acc20-7f4a-4b13-8ce4-9f73b9518af8.png#averageHue=%23080109&clientId=u9da0f65c-5a8c-4&from=paste&id=uc3a1df43&originHeight=223&originWidth=1285&originalType=url&ratio=1&rotation=0&showTitle=false&size=291379&status=done&style=none&taskId=u1c9e4b89-2356-43cb-aef5-c8285c293e0&title=" alt="image.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t sys.innodb_lock_waits <span class="keyword">where</span> locked_table<span class="operator">=</span><span class="string">&#x27;`test`.`t`&#x27;</span>\G</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648883270487-dab3c3c5-e153-4d52-a60a-71f1fe51fcea.png#averageHue=%23080109&clientId=u9da0f65c-5a8c-4&from=paste&id=ued0ab6db&originHeight=669&originWidth=864&originalType=url&ratio=1&rotation=0&showTitle=true&size=580038&status=done&style=none&taskId=u3b80a197-9c94-402c-937a-19cb179068a&title=%E9%80%9A%E8%BF%87%20sys.innodb_lock_waits%20%E6%9F%A5%E8%A1%8C%E9%94%81" alt="通过 sys.innodb_lock_waits 查行锁" title="通过 sys.innodb_lock_waits 查行锁">可以看到，这个信息很全，4 号线程是造成堵塞的罪魁祸首。而干掉这个罪魁祸首的方式，就是 KILL QUERY 4 或 KILL 4。不过，这里不应该显示“KILL QUERY 4”。这个命令表示停止 4 号线程当前正在执行的语句，而这个方法其实是没有用的。因为占有行锁的是 update 语句，这个语句已经是之前执行完成了的，现在执行 KILL QUERY，无法让这个事务去掉 id&#x3D;1 上的行锁。</p><p>实际上，KILL 4 才有效，也就是说直接断开这个连接。这里隐含的一个逻辑就是，连接被断开的时候，会自动回滚这个连接里面正在执行的线程，也就释放了 id&#x3D;1 上的行锁</p><h3 id="回滚多"><a href="#回滚多" class="headerlink" title="回滚多"></a>回滚多</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>；   结果：<span class="number">1</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> lock <span class="keyword">in</span> share mode  结果：<span class="number">1000001</span></span><br><span class="line">这两个查询结果不一样</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648883585247-7e59dcec-0278-410b-82ab-1025272a021c.png#averageHue=%23f9f9f9&clientId=u9da0f65c-5a8c-4&from=paste&id=udaac8027&originHeight=322&originWidth=936&originalType=url&ratio=1&rotation=0&showTitle=false&size=52745&status=done&style=none&taskId=udb5dcded-28c0-407c-becc-849e1a9f50d&title=" alt="image.png"><br>由于sessionB更新了，sessionA才开始查询，所以sessionB生成了大量的undo log<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1648883707434-705f7d40-60d4-4ffa-8029-406518fe2664.png#averageHue=%23edefe3&clientId=u9da0f65c-5a8c-4&from=paste&id=uccb7b493&originHeight=856&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=true&size=215323&status=done&style=none&taskId=u3ead1e96-17fc-4831-b8f7-da92f1c225f&title=%E7%AC%AC%E4%B8%80%E4%B8%AAselect%E9%9C%80%E8%A6%81%E5%9B%9E%E6%BB%9A100w%E6%AC%A1%E6%89%8D%E8%83%BD%E5%B0%86%E8%BF%99%E4%B8%AA%E7%BB%93%E6%9E%9C%E8%BF%94%E5%9B%9E" alt="第一个select需要回滚100w次才能将这个结果返回" title="第一个select需要回滚100w次才能将这个结果返回"><code>带 lock in share mode 的 SQL 语句，是当前读，因此会直接读到 1000001 这个结果，所以速度很快；</code><br><code>注意，undo log 里记录的其实是“把 2 改成 1”，“把 3 改成 2”这样的操作逻辑</code></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一条sql语句是如何执行的&quot;&gt;&lt;a href=&quot;#一条sql语句是如何执行的&quot; class=&quot;headerlink&quot; title=&quot;一条sql语句是如何执行的&quot;&gt;&lt;/a&gt;一条sql语句是如何执行的&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.nlar</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="mysql" scheme="http://example.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2023/05/10/hello-world/"/>
    <id>http://example.com/2023/05/10/hello-world/</id>
    <published>2023-05-10T14:16:41.007Z</published>
    <updated>2023-06-09T07:59:17.518Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="hello" scheme="http://example.com/tags/hello/"/>
    
  </entry>
  
</feed>
