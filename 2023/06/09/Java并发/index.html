<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Java并发 | SugarGood</title>
  <meta name="description" content="# disruptor  # A进程和线程  ## 进程 我们编写的代码只是⼀个存储在硬盘的静态⽂件，通过编译后就会⽣成⼆进制可执行文件，当我们运⾏这个可执⾏⽂件后，它会被装载到内存中，接着 CPU 会执⾏程序中的每⼀条指令，那么这个运⾏中的程序，就被称为「进程」（Process）。   进程的状态  NULL -&gt; 创建状态：⼀个新进程被创建时的第⼀个状态； 创建状态 -&gt; 就绪">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发">
<meta property="og:url" content="http://example.com/2023/06/09/Java%E5%B9%B6%E5%8F%91/index.html">
<meta property="og:site_name" content="SugarGood">
<meta property="og:description" content="# disruptor  # A进程和线程  ## 进程 我们编写的代码只是⼀个存储在硬盘的静态⽂件，通过编译后就会⽣成⼆进制可执行文件，当我们运⾏这个可执⾏⽂件后，它会被装载到内存中，接着 CPU 会执⾏程序中的每⼀条指令，那么这个运⾏中的程序，就被称为「进程」（Process）。   进程的状态  NULL -&gt; 创建状态：⼀个新进程被创建时的第⼀个状态； 创建状态 -&gt; 就绪">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652014692593-7cc7e2f5-2051-4120-b45f-a72e9983d1dc.png#averageHue=%23f9f5ef&clientId=u34a44d6d-2b13-4&from=paste&height=238&id=uf1046b14&originHeight=392&originWidth=1104&originalType=binary&ratio=1&rotation=0&showTitle=false&size=82991&status=done&style=none&taskId=u2344707a-b4f7-4790-82a7-5bc483989c0&title=&width=669.0908704184983">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652014844389-9ffe9951-d05d-4fe7-9d9d-e8c62341358d.png#averageHue=%23faf9f8&clientId=u34a44d6d-2b13-4&from=paste&height=425&id=u29e48f40&originHeight=701&originWidth=1151&originalType=binary&ratio=1&rotation=0&showTitle=false&size=136033&status=done&style=none&taskId=u1ed509a8-e34a-47d3-afc5-4148bcec457&title=&width=697.575717256967">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652015066182-c65fb80f-8de5-4e33-9413-021c9d29151a.png#averageHue=%23f9f8f8&clientId=u34a44d6d-2b13-4&from=paste&height=364&id=ufaadf455&originHeight=601&originWidth=1139&originalType=binary&ratio=1&rotation=0&showTitle=false&size=52809&status=done&style=none&taskId=ubd32928e-852d-4117-a3d9-15f1712c0a6&title=&width=690.3029904045919">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652338651309-4599722a-8716-4dcf-89b0-9c5b62fafe3e.png#averageHue=%23f6f8f2&clientId=uda4812d7-352a-4&from=paste&height=369&id=ud32a6d57&originHeight=554&originWidth=1396&originalType=binary&ratio=1&rotation=0&showTitle=false&size=307339&status=done&style=none&taskId=u96a5f588-6473-4540-bd82-7d7806c7c4d&title=&width=930.6666666666666">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652342049662-9ec70bbc-86c6-431e-b0eb-22d78438368b.png#averageHue=%23fbfaf7&clientId=uda4812d7-352a-4&from=paste&height=407&id=Mmz8A&originHeight=610&originWidth=807&originalType=binary&ratio=1&rotation=0&showTitle=false&size=215921&status=done&style=none&taskId=u7b8a9d81-18d8-494e-9a3f-0f9a39db456&title=&width=538">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652099542729-3c06ed19-823d-415a-853b-1363f0c6b875.png#averageHue=%23f5f6f0&clientId=u9ed45425-92a7-4&from=paste&height=292&id=uf25da9a0&originHeight=547&originWidth=1391&originalType=binary&ratio=1&rotation=0&showTitle=false&size=281661&status=done&style=none&taskId=u4c5f7338-673d-4f92-99fe-f1fa3d791d8&title=&width=741.8666666666667">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652615305684-93eb1080-2675-4e22-a601-d6e897d8c7a0.png#averageHue=%23eeeeee&clientId=ua41d68fc-b28c-4&from=paste&height=265&id=u3b03a6ec&originHeight=398&originWidth=1487&originalType=binary&ratio=1&rotation=0&showTitle=false&size=219096&status=done&style=none&taskId=ue3616037-fcea-4a3d-8822-75377b41119&title=&width=991.3333333333334">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652618529015-3760401d-dbea-47d0-88ab-60231f945b07.png#averageHue=%23faf9f2&clientId=ua41d68fc-b28c-4&from=paste&height=159&id=u45a1a778&originHeight=238&originWidth=1423&originalType=binary&ratio=1&rotation=0&showTitle=false&size=143786&status=done&style=none&taskId=uef982398-83de-49fa-87ab-62a69a18e04&title=&width=948.6666666666666">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652853489298-79c23aa0-a5a0-4044-8128-f10337964b30.png#averageHue=%23fcfcfc&clientId=u0ee394ca-2eaa-4&from=paste&height=321&id=u2cf38110&originHeight=481&originWidth=976&originalType=binary&ratio=1&rotation=0&showTitle=false&size=119476&status=done&style=none&taskId=u02dd47a0-cef2-430d-8ae7-fde31f5781f&title=&width=650.6666666666666">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652972599848-303b15d6-c972-4d9b-89ae-db1257d53fb7.png#averageHue=%23f7f7f7&clientId=u0ead8153-855e-4&from=paste&height=375&id=u90f15228&originHeight=563&originWidth=1559&originalType=binary&ratio=1&rotation=0&showTitle=true&size=133829&status=done&style=none&taskId=u1296a2b2-2147-460c-b1f4-7daa8b67cdb&title=addConditionWaiter%E6%B5%81%E7%A8%8B&width=1039.3333333333333">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652972885079-9b76a3b1-0a91-4538-ba8b-29baf13b78b5.png#averageHue=%23f7f7f7&clientId=u0ead8153-855e-4&from=paste&height=387&id=u75ce8516&originHeight=581&originWidth=1526&originalType=binary&ratio=1&rotation=0&showTitle=false&size=116750&status=done&style=none&taskId=u9a7cf356-5583-492e-9193-c43c88527f0&title=&width=1017.3333333333334">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652972938747-55423cbf-6587-4290-9e30-72e3da115af6.png#averageHue=%23f7f7f7&clientId=u0ead8153-855e-4&from=paste&height=386&id=u305633f8&originHeight=579&originWidth=1547&originalType=binary&ratio=1&rotation=0&showTitle=false&size=109189&status=done&style=none&taskId=u186ba132-d134-4643-bb5c-0e3871b43b5&title=&width=1031.3333333333333">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652972990458-f25a1df9-5d99-4c1b-96ec-6559fa96bd4c.png#averageHue=%23f7f7f6&clientId=u0ead8153-855e-4&from=paste&height=387&id=u7a44d254&originHeight=580&originWidth=1560&originalType=binary&ratio=1&rotation=0&showTitle=false&size=136533&status=done&style=none&taskId=u04dac3b2-71a6-40aa-a625-5b58eb6d859&title=&width=1040">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652980463373-f25b7968-a431-4f0e-b315-e658a4270ee4.png#averageHue=%23f6f6f6&clientId=u0ead8153-855e-4&from=paste&height=485&id=u570bd8a4&originHeight=727&originWidth=1544&originalType=binary&ratio=1&rotation=0&showTitle=false&size=139194&status=done&style=none&taskId=ub5ac7abd-0a1a-4e3a-a122-6f547ebfab8&title=&width=1029.3333333333333">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652980745484-9980a48f-54c3-44ea-ba94-b946b9271b45.png#averageHue=%23f5f5f5&clientId=u0ead8153-855e-4&from=paste&height=469&id=u9a99b3b2&originHeight=704&originWidth=1543&originalType=binary&ratio=1&rotation=0&showTitle=true&size=137224&status=done&style=none&taskId=ub53047b9-2406-4052-8620-b2a93534228&title=%E8%BF%9B%E5%85%A5%20ConditionObject%20%E7%9A%84%20doSignal%20%E6%B5%81%E7%A8%8B%EF%BC%8C%E5%8F%96%E5%BE%97%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%20Node%EF%BC%8C%E5%8D%B3%20Thread-0%20%E6%89%80%E5%9C%A8%20Node&width=1028.6666666666667">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652980772291-d8079b72-ecdb-4718-9002-7f69b9eb682d.png#averageHue=%23f7f7f7&clientId=u0ead8153-855e-4&from=paste&height=372&id=u1fad4a00&originHeight=558&originWidth=1578&originalType=binary&ratio=1&rotation=0&showTitle=true&size=129095&status=done&style=none&taskId=ud387efbb-e461-4c8b-b8f9-46c488f9400&title=%E6%89%A7%E8%A1%8C%20transferForSignal%20%E6%B5%81%E7%A8%8B%EF%BC%8C%E5%B0%86%E8%AF%A5%20Node%20%E5%8A%A0%E5%85%A5%20AQS%20%E9%98%9F%E5%88%97%E5%B0%BE%E9%83%A8%EF%BC%8C%E5%B0%86%20Thread-0%20%E7%9A%84%20waitStatus%20%E6%94%B9%E4%B8%BA%200%EF%BC%8CThread-3%20%E7%9A%84%0D%20waitStatus%20%E6%94%B9%E4%B8%BA%20-1&width=1052">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653220859052-b9bac57e-3e71-4ef1-94b6-cef886e281fa.png#averageHue=%23e1eac4&clientId=ub17e8e3a-9055-4&from=paste&height=384&id=ud1003b47&originHeight=576&originWidth=933&originalType=binary&ratio=1&rotation=0&showTitle=false&size=141325&status=done&style=none&taskId=u42f02d98-b9cd-4938-9e75-73e40f5d420&title=&width=622">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653225812952-44993750-4d10-4c27-ba93-db7847cb5bb3.png#averageHue=%23e6f3c9&clientId=ub17e8e3a-9055-4&from=paste&height=569&id=u2e9e9b4f&originHeight=854&originWidth=1295&originalType=binary&ratio=1&rotation=0&showTitle=false&size=120519&status=done&style=none&taskId=uab94d398-cdee-4d3d-9a73-9e1f83667cc&title=&width=863.3333333333334">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653225805086-14a075e3-8110-421e-b21d-c742195c4691.png#averageHue=%23f6f6ef&clientId=ub17e8e3a-9055-4&from=paste&height=500&id=u23edce0a&originHeight=750&originWidth=1552&originalType=binary&ratio=1&rotation=0&showTitle=false&size=141630&status=done&style=none&taskId=uab3e4edb-edd0-412c-ab19-89abdbb9d96&title=&width=1034.6666666666667">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653225992674-05793ce4-344f-4ff3-b173-589ae2c830b7.png#averageHue=%23f6f6f1&clientId=ub17e8e3a-9055-4&from=paste&height=326&id=u8a7e2c4a&originHeight=489&originWidth=1545&originalType=binary&ratio=1&rotation=0&showTitle=false&size=113643&status=done&style=none&taskId=u8d1d1a08-db16-41fd-8e57-ece92b8637d&title=&width=1030">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653226218143-d29af746-7ebf-4c27-a4ef-28a184cf9498.png#averageHue=%23f6f6f2&clientId=ub17e8e3a-9055-4&from=paste&height=325&id=u91a32bbf&originHeight=487&originWidth=1562&originalType=binary&ratio=1&rotation=0&showTitle=false&size=98666&status=done&style=none&taskId=u8457dcec-c482-40af-9f1d-8c8e3b46c12&title=&width=1041.3333333333333">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653226764096-323a8c9a-031d-46f7-8f63-56a6a006ccc0.png#averageHue=%23f5f5f0&clientId=ub17e8e3a-9055-4&from=paste&height=393&id=ud3bbc83a&originHeight=589&originWidth=1536&originalType=binary&ratio=1&rotation=0&showTitle=false&size=115288&status=done&style=none&taskId=uf431852c-19e3-4566-8799-76a1526895e&title=&width=1024">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653226831987-00a4e893-7e88-4f4f-be33-488e99df4ece.png#averageHue=%23f6f6f1&clientId=ub17e8e3a-9055-4&from=paste&height=417&id=uc3bc5a65&originHeight=626&originWidth=1548&originalType=binary&ratio=1&rotation=0&showTitle=false&size=111248&status=done&style=none&taskId=uac6f72a3-56d3-4457-a6be-a5aa24ad5a8&title=&width=1032">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653226846171-18886aa1-f21a-406d-9cc6-0a593020348d.png#averageHue=%23f7f7f2&clientId=ub17e8e3a-9055-4&from=paste&height=419&id=u586ee9ab&originHeight=629&originWidth=1588&originalType=binary&ratio=1&rotation=0&showTitle=false&size=113141&status=done&style=none&taskId=ue1a92728-3fd0-406c-95c3-5ceaf53eb18&title=&width=1058.6666666666667">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653226885140-b8d8002a-0b2e-4499-8101-f3b032a97acb.png#averageHue=%23e8f5ca&clientId=ub17e8e3a-9055-4&from=paste&height=505&id=u0c0ea77d&originHeight=757&originWidth=1546&originalType=binary&ratio=1&rotation=0&showTitle=false&size=148488&status=done&style=none&taskId=ud3c1e7f7-c9eb-43a9-9dd7-dd805cdbba2&title=&width=1030.6666666666667">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653227818832-ecea2de8-6a3f-429f-8053-77bf25edfc15.png#averageHue=%23f6f6ee&clientId=ub17e8e3a-9055-4&from=paste&height=528&id=u4c8c5c64&originHeight=792&originWidth=1541&originalType=binary&ratio=1&rotation=0&showTitle=false&size=151319&status=done&style=none&taskId=uc1793a48-1c1f-46fa-8852-e1c0a969e9c&title=&width=1027.3333333333333">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653227837583-852cf25d-6769-44bd-8b50-dd22e01d7575.png#averageHue=%23e6f3c8&clientId=ub17e8e3a-9055-4&from=paste&height=546&id=u73b0f094&originHeight=819&originWidth=1211&originalType=binary&ratio=1&rotation=0&showTitle=false&size=112813&status=done&style=none&taskId=ua9320c13-f8c2-43fa-80e8-e9e191dcb3f&title=&width=807.3333333333334">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653361171453-dfdeff10-e74c-4419-b3b1-70e74979e53b.png#averageHue=%23e8f4c4&clientId=ue4f918ef-5f35-4&from=paste&height=363&id=u5284df3e&originHeight=545&originWidth=1008&originalType=binary&ratio=1&rotation=0&showTitle=false&size=92099&status=done&style=none&taskId=u9f34e6cd-af96-4e8b-ae6c-d58a110eaa3&title=&width=672">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653361205613-ece7be8f-3126-4654-96c9-dbbdf668e3a0.png#averageHue=%23f6f6f1&clientId=ue4f918ef-5f35-4&from=paste&height=185&id=u075478f9&originHeight=278&originWidth=1029&originalType=binary&ratio=1&rotation=0&showTitle=false&size=61288&status=done&style=none&taskId=ub0ce0286-a065-49c6-8d79-4e88abd1492&title=&width=686">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653370720394-3433233e-cb48-45ec-9cbf-6895fa5f5a10.png#averageHue=%23f7f6f2&clientId=ue4f918ef-5f35-4&from=paste&height=192&id=u8359cd6f&originHeight=288&originWidth=1053&originalType=binary&ratio=1&rotation=0&showTitle=false&size=55152&status=done&style=none&taskId=u9ba2e77d-7891-4294-9177-bb94b97ced9&title=&width=702">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653370835850-cc209624-b529-4384-8d90-d2bafa62835d.png#averageHue=%23e6f2c1&clientId=ue4f918ef-5f35-4&from=paste&height=229&id=u8751c0a8&originHeight=343&originWidth=1034&originalType=binary&ratio=1&rotation=0&showTitle=false&size=63556&status=done&style=none&taskId=u4842649d-b5fd-4b68-93ce-02d4f267c4a&title=&width=689.3333333333334">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653467080405-e6911d43-68af-4f50-8858-fa086f83cdde.png#averageHue=%23c3a585&clientId=ub3e8bb93-efe7-4&from=paste&height=167&id=u3f777897&originHeight=251&originWidth=1484&originalType=binary&ratio=1&rotation=0&showTitle=false&size=68586&status=done&style=none&taskId=u29b813b4-e044-405f-904a-6dac33b62c1&title=&width=989.3333333333334">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653467335343-ed581bee-e318-4237-ae65-b6ae81b0c0ef.png#averageHue=%23f7f5ec&clientId=ub3e8bb93-efe7-4&from=paste&height=428&id=u272f51d1&originHeight=642&originWidth=932&originalType=binary&ratio=1&rotation=0&showTitle=false&size=322427&status=done&style=none&taskId=u70c1f023-23a4-4574-b1be-e72e6b7256c&title=&width=621.3333333333334">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651906901594-fe06ad0b-08ab-467c-a883-4be2822f2788.png#averageHue=%23eae6a4&clientId=u4d909540-ad5c-4&from=paste&height=410&id=u1679bc2d&originHeight=677&originWidth=1397&originalType=binary&ratio=1&rotation=0&showTitle=false&size=222435&status=done&style=none&taskId=uf9d61d4a-6952-4358-91fa-bfa20269023&title=&width=846.666617730654">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651906913481-167d670a-d4bf-4bed-8ac1-2c8561745dec.png#averageHue=%23f5f4e8&clientId=u4d909540-ad5c-4&from=paste&height=466&id=u754490d1&originHeight=769&originWidth=1736&originalType=binary&ratio=1&rotation=0&showTitle=false&size=380733&status=done&style=none&taskId=uc03cbcbe-f8e3-41a7-a3db-247bcc83fb5&title=&width=1052.1211513102473">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651906923102-88ac5a15-8425-4c74-a483-43acc2c60dbf.png#averageHue=%23f4f3e8&clientId=u4d909540-ad5c-4&from=paste&height=459&id=u83e8a6cd&originHeight=757&originWidth=1758&originalType=binary&ratio=1&rotation=0&showTitle=false&size=376718&status=done&style=none&taskId=u08430a0b-b635-43a0-a4aa-c2b5b6b537a&title=&width=1065.4544838729348">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652350701634-70c3f373-1d0f-4b99-806c-19e9208836b5.png#averageHue=%23faf9f9&clientId=uda4812d7-352a-4&from=paste&height=366&id=u99e7679e&originHeight=549&originWidth=793&originalType=binary&ratio=1&rotation=0&showTitle=false&size=109204&status=done&style=none&taskId=u83c604dd-d5f7-4a92-930d-bd3d51b36f7&title=&width=528.6666666666666">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652350815190-de203eb1-6288-4674-abbe-d9786ab868dd.png#averageHue=%23f9f9f9&clientId=uda4812d7-352a-4&from=paste&height=310&id=u1243807d&originHeight=465&originWidth=803&originalType=binary&ratio=1&rotation=0&showTitle=true&size=104697&status=done&style=none&taskId=ueeb850b5-500d-4f33-9c9a-b05a75110e1&title=%E8%AF%BB&width=535.3333333333334">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651908545922-7404c5d2-1082-4ef3-b40d-3277c8ca2000.png#averageHue=%23fbfbfa&clientId=u4d909540-ad5c-4&from=paste&height=168&id=u0f2b15c0&originHeight=278&originWidth=1700&originalType=binary&ratio=1&rotation=0&showTitle=false&size=141189&status=done&style=none&taskId=u195b006a-1b89-4f0e-ab36-6b820849eac&title=&width=1030.3029707531223">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651908596904-265538e6-b281-4725-b5ba-3a0668b8dd7c.png#averageHue=%23e3e0d8&clientId=u4d909540-ad5c-4&from=paste&height=204&id=u5a684652&originHeight=336&originWidth=1663&originalType=binary&ratio=1&rotation=0&showTitle=false&size=327332&status=done&style=none&taskId=u122e144d-a27c-43e2-ab2e-5ea8eff354a&title=&width=1007.8787296249661">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652628866291-5d1105e3-d155-4e54-86a7-70fe2b61455a.png#averageHue=%23f9f8f8&clientId=ua41d68fc-b28c-4&from=paste&height=664&id=ueea74552&originHeight=996&originWidth=1017&originalType=binary&ratio=1&rotation=0&showTitle=false&size=155123&status=done&style=none&taskId=uc43a428c-6b87-4c22-b74a-24668a6ce2d&title=&width=678">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652629186783-edc71493-757b-422b-ac3d-772a379cd05e.png#averageHue=%23dee8b4&clientId=ua41d68fc-b28c-4&from=paste&height=423&id=ud6be82f9&originHeight=634&originWidth=1549&originalType=binary&ratio=1&rotation=0&showTitle=false&size=152223&status=done&style=none&taskId=u3ba51c2d-7758-4b06-a692-e5d11abce4d&title=&width=1032.6666666666667">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652629906336-b932fde5-f2e8-46fc-9955-88d3d5d84515.png#averageHue=%23fcfcdd&clientId=ua41d68fc-b28c-4&from=paste&height=298&id=uc9ed4230&originHeight=447&originWidth=1451&originalType=binary&ratio=1&rotation=0&showTitle=false&size=107835&status=done&style=none&taskId=u8145646b-0368-4657-89cc-d54cf5d6d95&title=&width=967.3333333333334">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652630480269-24cb7e01-5889-4b6c-a3d1-b4dbd53e15dd.png#averageHue=%23fcfcdd&clientId=ua41d68fc-b28c-4&from=paste&height=217&id=ueaf7f225&originHeight=325&originWidth=1426&originalType=binary&ratio=1&rotation=0&showTitle=false&size=68742&status=done&style=none&taskId=u85ad2aad-94af-4900-8de0-d3c3e5a36d0&title=&width=950.6666666666666">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652631025218-43cbe378-6e9e-47bc-adcd-0809415519bf.png#averageHue=%23fcfcdd&clientId=ua41d68fc-b28c-4&from=paste&height=251&id=u4f25057f&originHeight=377&originWidth=1390&originalType=binary&ratio=1&rotation=0&showTitle=false&size=58980&status=done&style=none&taskId=u3b8d29d8-cd70-4e62-8910-6af21652a62&title=&width=926.6666666666666">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652631102454-34f02836-d3a5-4087-a26c-46aa8575fb1d.png#averageHue=%23fcfcdd&clientId=ua41d68fc-b28c-4&from=paste&height=325&id=uf13ac630&originHeight=488&originWidth=1407&originalType=binary&ratio=1&rotation=0&showTitle=false&size=103587&status=done&style=none&taskId=uea924691-3850-4654-b6bf-73cb07f4cf0&title=&width=938">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652187200050-747a4d9a-3ac8-4fe4-980b-d9df09fa674e.png#averageHue=%23e4e5a1&clientId=ub2cb5786-dc2a-4&from=paste&height=303&id=u4a1fc741&originHeight=454&originWidth=870&originalType=binary&ratio=1&rotation=0&showTitle=false&size=210819&status=done&style=none&taskId=ud9561da1-d0e7-4e9b-89e2-baf4fe5e81a&title=&width=580">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652187357049-ba4c587d-f239-4ffe-a6e3-1de32cced6ae.png#averageHue=%23dcdc9b&clientId=ub2cb5786-dc2a-4&from=paste&height=313&id=ubd9a72d4&originHeight=469&originWidth=946&originalType=binary&ratio=1&rotation=0&showTitle=true&size=249260&status=done&style=none&taskId=ufe972293-e9ed-42f7-b019-108d6f6f023&title=%E5%8A%A0%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E4%B9%8B%E5%90%8E&width=630.6666666666666">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652187543586-c1915fd0-6d07-4b2f-ab08-430efdcaaaeb.png#averageHue=%23dddd9b&clientId=ub2cb5786-dc2a-4&from=paste&height=367&id=uc04c8646&originHeight=550&originWidth=891&originalType=binary&ratio=1&rotation=0&showTitle=false&size=331577&status=done&style=none&taskId=u5566ceb2-7a14-48f0-a4bc-3ccb8c86edc&title=&width=594">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651916739005-675c8ac0-7490-4cda-abde-6c8bc5eeb562.png#averageHue=%23f8f7f7&clientId=u4d909540-ad5c-4&from=paste&height=777&id=u3606bc88&originHeight=1282&originWidth=905&originalType=binary&ratio=1&rotation=0&showTitle=false&size=236980&status=done&style=none&taskId=u8ff03b52-0b9d-44be-8da7-75689953a9f&title=&width=548.4848167832798">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652231751456-3a19835d-a249-460f-92ae-c2a1fad65a43.png#averageHue=%23e3e8b4&clientId=u986fdba0-2901-4&from=paste&height=207&id=u3dd7e676&originHeight=311&originWidth=924&originalType=binary&ratio=1&rotation=0&showTitle=false&size=136386&status=done&style=none&taskId=ufd513d7f-6601-4497-8b0a-eea0c2c873e&title=&width=616">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651917159175-01d5800b-9d75-4278-8b57-f85ad1659b71.png#averageHue=%23f8f6f6&clientId=u4d909540-ad5c-4&from=paste&height=689&id=u173746e5&originHeight=1137&originWidth=908&originalType=binary&ratio=1&rotation=0&showTitle=false&size=215612&status=done&style=none&taskId=uc56ab351-eda1-410e-9567-51075472dc7&title=&width=550.3029984963736">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651917371100-4cc26771-5c62-4c62-9941-145c70d6e7af.png#averageHue=%23f5f4f4&clientId=u4d909540-ad5c-4&from=paste&height=661&id=u29f33815&originHeight=1091&originWidth=1621&originalType=binary&ratio=1&rotation=0&showTitle=false&size=215501&status=done&style=none&taskId=u53d262f9-efc8-4c3c-8fd6-83c42798683&title=&width=982.4241856416537">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651917379646-6e0109e8-bcee-4326-b894-d977faa0d175.png#averageHue=%23f4f4f3&clientId=u4d909540-ad5c-4&from=paste&height=613&id=u3dc6bedb&originHeight=1012&originWidth=1638&originalType=binary&ratio=1&rotation=0&showTitle=false&size=204612&status=done&style=none&taskId=u697f51a6-9611-44f0-a524-b21e1021f26&title=&width=992.7272153491849">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652337060162-a0fcea0d-a450-4433-93a6-65b0d9f33e98.png#averageHue=%23eaeee7&clientId=uda4812d7-352a-4&from=paste&height=413&id=u55a4105c&originHeight=620&originWidth=1522&originalType=binary&ratio=1&rotation=0&showTitle=false&size=449961&status=done&style=none&taskId=u11a72a2e-02a2-4b63-9698-9280efc6a4a&title=&width=1014.6666666666666">
<meta property="article:published_time" content="2023-06-09T06:04:22.420Z">
<meta property="article:modified_time" content="2023-06-09T06:15:17.212Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652014692593-7cc7e2f5-2051-4120-b45f-a72e9983d1dc.png#averageHue=%23f9f5ef&clientId=u34a44d6d-2b13-4&from=paste&height=238&id=uf1046b14&originHeight=392&originWidth=1104&originalType=binary&ratio=1&rotation=0&showTitle=false&size=82991&status=done&style=none&taskId=u2344707a-b4f7-4790-82a7-5bc483989c0&title=&width=669.0908704184983">
  <!-- Canonical links -->
  <link rel="canonical" href="http://example.com/2023/06/09/Java%E5%B9%B6%E5%8F%91/index.html">
  
    <link rel="alternate" href="/atom.xml" title="SugarGood" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 6.3.0"></head>


<body class="main-center theme-blue" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/sugarGood" target="_blank">
          <img class="img-circle img-rotate" src="/images/a.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">theo</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Think &amp; Practice</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> ChongQing, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/sugarGood" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/cofess" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81/">源码</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      <!---->
<!--  <div class="widget">-->
<!--    <h3 class="widget-title">标签云</h3>-->
<!--    <div class="widget-body tagcloud">-->
<!--      <a href="/tags/hello/" style="font-size: 13px;">hello</a> <a href="/tags/mysql/" style="font-size: 13px;">mysql</a> <a href="/tags/nacos/" style="font-size: 13px;">nacos</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 13px;">并发</a>-->
<!--    </div>-->
<!--  </div>-->
<!---->


  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/hello/" style="font-size: 13px; color: #e48b3a">hello</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 13px; color: #e48b3a">并发</a> <a href="/tags/mysql/" style="font-size: 13px; color: #e48b3a">mysql</a> <a href="/tags/nacos/" style="font-size: 13px; color: #e48b3a">nacos</a>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%BA%90%E7%A0%81/">源码</a>
              </p>
              <p class="item-title">
                <a href="/2023/07/07/%E6%B5%85%E6%9E%90nacos%E6%BA%90%E7%A0%81%E4%B8%80%20%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/" class="title">浅析nacos源码一 服务注册</a>
              </p>
              <p class="item-date">
                <time datetime="2023-07-07T09:29:10.792Z" itemprop="datePublished">2023-07-07</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/java/">java</a>
              </p>
              <p class="item-title">
                <a href="/2023/06/09/Java%E5%B9%B6%E5%8F%91/" class="title">Java并发</a>
              </p>
              <p class="item-date">
                <time datetime="2023-06-09T06:04:22.420Z" itemprop="datePublished">2023-06-09</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/java/">java</a>
              </p>
              <p class="item-title">
                <a href="/2023/05/12/Mysql/" class="title">Mysql</a>
              </p>
              <p class="item-date">
                <time datetime="2023-05-12T02:22:13.322Z" itemprop="datePublished">2023-05-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/java/">java</a>
              </p>
              <p class="item-title">
                <a href="/2023/05/10/hello-world/" class="title">Hello World</a>
              </p>
              <p class="item-date">
                <time datetime="2023-05-10T14:16:41.007Z" itemprop="datePublished">2023-05-10</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.</span> <span class="toc-text">进程的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">进程的控制结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C"><span class="toc-number">3.</span> <span class="toc-text">线程操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">创建进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">终止进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">阻塞进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%94%A4%E9%86%92%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.4.</span> <span class="toc-text">唤醒进程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">4.</span> <span class="toc-text">进程的上下文切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E2%BD%90%E8%BE%83"><span class="toc-number">1.</span> <span class="toc-text">线程与进程的⽐较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E2%BD%82%E5%88%87%E6%8D%A2"><span class="toc-number">2.</span> <span class="toc-text">线程的上下⽂切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">创建和运行线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Thread"><span class="toc-number">3.1.</span> <span class="toc-text">Thread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Runnable"><span class="toc-number">3.2.</span> <span class="toc-text">Runnable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Callable"><span class="toc-number">3.3.</span> <span class="toc-text">Callable</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">常见方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#start%E5%92%8Crun"><span class="toc-number">4.1.</span> <span class="toc-text">start和run</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sleep%E5%92%8Cyield"><span class="toc-number">4.2.</span> <span class="toc-text">sleep和yield</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#interrupt"><span class="toc-number">4.3.</span> <span class="toc-text">interrupt()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#interrupted-%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.1.</span> <span class="toc-text">interrupted()方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#isInterrupted"><span class="toc-number">4.3.2.</span> <span class="toc-text">isInterrupted()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Join"><span class="toc-number">4.4.</span> <span class="toc-text">Join</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wait-notify"><span class="toc-number">4.5.</span> <span class="toc-text">wait notify</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">4.6.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.7.</span> <span class="toc-text">sleep和wait的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#park-unpark"><span class="toc-number">4.8.</span> <span class="toc-text">park unpark</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-1"><span class="toc-number">4.9.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E6%8E%A8%E8%8D%90%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.10.</span> <span class="toc-text">不推荐的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">守护线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#monitor"><span class="toc-number"></span> <span class="toc-text">monitor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number"></span> <span class="toc-text">关闭线程池</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JUC"><span class="toc-number"></span> <span class="toc-text">JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#reetrantLock"><span class="toc-number"></span> <span class="toc-text">reetrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Condition-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">1.</span> <span class="toc-text">Condition 条件变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number"></span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPoolExecutor"><span class="toc-number"></span> <span class="toc-text">ThreadPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81"><span class="toc-number">1.</span> <span class="toc-text">线程池状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">3.</span> <span class="toc-text">工厂方法创建线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#newFixedThreadPool"><span class="toc-number">3.1.</span> <span class="toc-text">newFixedThreadPool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#newCacheThreadPool"><span class="toc-number">3.2.</span> <span class="toc-text">newCacheThreadPool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#newSingleThreadExecutor"><span class="toc-number">3.3.</span> <span class="toc-text">newSingleThreadExecutor</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fork-x2F-Join"><span class="toc-number"></span> <span class="toc-text">Fork&#x2F;Join</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS"><span class="toc-number"></span> <span class="toc-text">AQS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reetrantLock%E5%8E%9F%E7%90%86"><span class="toc-number"></span> <span class="toc-text">reetrantLock原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E5%8E%9F%E7%90%86"><span class="toc-number">0.1.</span> <span class="toc-text">可重入原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E6%89%93%E6%96%AD%E5%8E%9F%E7%90%86"><span class="toc-number">0.2.</span> <span class="toc-text">可打断原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">0.3.</span> <span class="toc-text">公平锁的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fcondition%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">0.4.</span> <span class="toc-text">条件变量condition的实现原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantReadWriteLock"><span class="toc-number"></span> <span class="toc-text">ReentrantReadWriteLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StampedLock"><span class="toc-number"></span> <span class="toc-text">StampedLock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Semaphore"><span class="toc-number"></span> <span class="toc-text">Semaphore</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">1.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CountdownLatch"><span class="toc-number"></span> <span class="toc-text">CountdownLatch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-number">1.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number"></span> <span class="toc-text">CyclicBarrier</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CompletableFuture"><span class="toc-number"></span> <span class="toc-text">CompletableFuture</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">0.1.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83-whenComplete%E3%80%81whenCompleteAsync"><span class="toc-number">0.2.</span> <span class="toc-text">回调 whenComplete、whenCompleteAsync</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C-thenApply-thenAccept-thenRun"><span class="toc-number">0.3.</span> <span class="toc-text">继续执行 thenApply thenAccept thenRun</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88-%E4%B8%A4%E4%B8%AA%E9%83%BD%E5%A4%84%E7%90%86%E5%AE%8C%E6%88%90-thenCombine-thenAcceptBoth-runAfterBoth"><span class="toc-number">0.4.</span> <span class="toc-text">组合 两个都处理完成 thenCombine thenAcceptBoth runAfterBoth</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88-%E5%8F%AA%E9%9C%80%E4%B8%80%E4%B8%AA%E5%A4%84%E7%90%86%E5%AE%8C%E6%88%90"><span class="toc-number">0.5.</span> <span class="toc-text">组合 只需一个处理完成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%BB%BB%E5%8A%A1-allOf-anyOf"><span class="toc-number">0.6.</span> <span class="toc-text">多任务 allOf anyOf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#thenCompose-%E5%B5%8C%E5%A5%97future"><span class="toc-number">0.7.</span> <span class="toc-text">thenCompose 嵌套future</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-exceptionally-handle"><span class="toc-number">0.8.</span> <span class="toc-text">异常处理 exceptionally handle</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-number"></span> <span class="toc-text">线程安全的集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">1.</span> <span class="toc-text">ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-3"><span class="toc-number">1.1.</span> <span class="toc-text">原理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number"></span> <span class="toc-text">应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number"></span> <span class="toc-text">控制线程的执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%9B%BF%E8%BE%93%E5%87%BA"><span class="toc-number"></span> <span class="toc-text">交替输出</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JMM"><span class="toc-number"></span> <span class="toc-text">JMM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number"></span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number"></span> <span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile"><span class="toc-number"></span> <span class="toc-text">volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-4"><span class="toc-number">1.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92"><span class="toc-number"></span> <span class="toc-text">指令重排</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#happens-before"><span class="toc-number"></span> <span class="toc-text">happens-before</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS"><span class="toc-number"></span> <span class="toc-text">CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LongAdder-%E5%8E%9F%E5%AD%90%E7%B4%AF%E5%8A%A0%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">LongAdder 原子累加器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E4%BC%98%E5%8C%96"><span class="toc-number"></span> <span class="toc-text">synchronized优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">1.</span> <span class="toc-text">轻量级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E8%86%A8%E8%83%80"><span class="toc-number">2.</span> <span class="toc-text">锁膨胀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">重量级锁的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96"><span class="toc-number">3.1.</span> <span class="toc-text">自旋优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">4.</span> <span class="toc-text">偏向锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E4%BC%98%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">其它优化</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-Java并发" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Java并发
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2023/06/09/Java%E5%B9%B6%E5%8F%91/" class="article-date">
	  <time datetime="2023-06-09T06:04:22.420Z" itemprop="datePublished">2023-06-09</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/java/">java</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a>
  </span>


        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数: 21.4k
<!-- 		(字) -->
		</span>
	
	


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2023/06/09/Java%E5%B9%B6%E5%8F%91/#comments" class="article-comment-link">评论</a>
            <span class="valine-comment-count" data-xid="/2023/06/09/Java%E5%B9%B6%E5%8F%91/"></span>条
        </span>

        

	<span class="article-read hidden-xs">
    	<i class="icon icon-eye-fill" aria-hidden="true"></i>
    	<span id="/2023/06/09/Java%E5%B9%B6%E5%8F%91/" class="leancloud_visitors"  data-flag-title="Java并发">
			<span class="leancloud-visitors-count">0</span>
		</span>
    </span>


      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <meta name="referrer" content="no-referrer"/>
<a name="GJCOp"></a>
# disruptor
<a name="v7F26"></a>
# A进程和线程
<a name="AoAR9"></a>
## 进程
我们编写的代码只是⼀个存储在硬盘的静态⽂件，通过编译后就会⽣成⼆进制可执行文件，当我们运⾏这个可执⾏⽂件后，它会被装载到内存中，接着 CPU 会执⾏程序中的每⼀条指令，那么这个运⾏中的程序，<br />就被称为「进程」（Process）。

<p><a name="QBqrX"></a></p>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652014692593-7cc7e2f5-2051-4120-b45f-a72e9983d1dc.png#averageHue=%23f9f5ef&clientId=u34a44d6d-2b13-4&from=paste&height=238&id=uf1046b14&originHeight=392&originWidth=1104&originalType=binary&ratio=1&rotation=0&showTitle=false&size=82991&status=done&style=none&taskId=u2344707a-b4f7-4790-82a7-5bc483989c0&title=&width=669.0908704184983" alt="image.png"></p>
<ul>
<li>NULL -&gt; 创建状态：⼀个新进程被创建时的第⼀个状态；</li>
<li>创建状态 -&gt; 就绪状态：当进程被创建完成并初始化后，⼀切就绪准备运⾏时，变为就绪状态，这个过程是很快的；</li>
<li>就绪态 -&gt; 运⾏状态：处于就绪状态的进程被操作系统的进程调度器选中后，就分配给 CPU 正式运⾏该进程；</li>
<li>运⾏状态 -&gt; 结束状态：当进程已经运⾏完成或出错时，会被操作系统作结束状态处理；</li>
<li>运⾏状态 -&gt; 就绪状态：处于运⾏状态的进程在运⾏过程中，由于分配给它的运⾏时间⽚⽤完，操作系统会把该进程变为就绪态，接着从就绪态选中另外⼀个进程运⾏；</li>
<li>运⾏状态 -&gt; 阻塞状态：当进程请求某个事件且必须等待时，例如请求 I&#x2F;O 事件；</li>
<li>阻塞状态 -&gt; 就绪状态：当进程要等待的事件完成时，它从阻塞状态变到就绪状态；</li>
</ul>
<p>如果有⼤量处于阻塞状态的进程，进程可能会占⽤着物理内存空间，显然不是我们所希望的，毕竟物理内<br />存空间是有限的，被阻塞状态的进程占⽤着物理内存就⼀种浪费物理内存的⾏为。<br />所以，在虚拟内存管理的操作系统中，通常会把阻塞状态的进程的物理内存空间换出到硬盘，等需要再次<br />运⾏ 的时候，再从硬盘换⼊到物理内存。</p>
<p>那么，就需要⼀个新的状态，来描述进程没有占⽤实际的物理内存空间的情况，这个状态就是挂起状态。<br />这跟阻塞状态是不⼀样，阻塞状态是等待某个事件的返回。<br />另外，挂起状态可以分为两种：</p>
<ul>
<li>阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；</li>
<li>就绪挂起状态：进程在外存（硬盘），但只要进⼊内存，即刻⽴刻运⾏</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652014844389-9ffe9951-d05d-4fe7-9d9d-e8c62341358d.png#averageHue=%23faf9f8&clientId=u34a44d6d-2b13-4&from=paste&height=425&id=u29e48f40&originHeight=701&originWidth=1151&originalType=binary&ratio=1&rotation=0&showTitle=false&size=136033&status=done&style=none&taskId=u1ed509a8-e34a-47d3-afc5-4148bcec457&title=&width=697.575717256967" alt="image.png"><br />导致进程挂起的原因不只是因为进程所使⽤的内存空间不在物理内存，还包括如下情况：</p>
<ul>
<li>通过 sleep 让进程间歇性挂起，其⼯作原理是设置⼀个定时器，到期后唤醒进程。</li>
<li>⽤户希望挂起⼀个程序的执⾏，⽐如在 Linux 中⽤ Ctrl+Z 挂起进程；</li>
</ul>
<p><a name="gYkQ4"></a></p>
<h3 id="进程的控制结构"><a href="#进程的控制结构" class="headerlink" title="进程的控制结构"></a>进程的控制结构</h3><p>在操作系统中，是⽤进程控制块（process control block，PCB）数据结构来描述进程的。</p>
<p>PCB 是进程存在的唯⼀标识，这意味着⼀个进程的存在，必然会有⼀个 PCB，如果进程消失了，那么<br />PCB 也会随之消失。</p>
<p><strong>PCB包含的信息:</strong></p>
<ul>
<li>进程描述信息：<ul>
<li>进程标识符：标识各个进程，每个进程都有⼀个并且唯⼀的标识符；</li>
<li>⽤户标识符：进程归属的⽤户，⽤户标识符主要为共享和保护服务；</li>
</ul>
</li>
<li>进程控制和管理信息：<ul>
<li>进程当前状态，如 new、ready、running、waiting 或 blocked 等；</li>
<li>进程优先级：进程抢占 CPU 时的优先级；</li>
</ul>
</li>
<li>资源分配清单：<ul>
<li>有关内存地址空间或虚拟地址空间的信息，所打开⽂件的列表和所使⽤的 I&#x2F;O 设备信息。</li>
</ul>
</li>
<li>CPU 相关信息：<ul>
<li>CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程</li>
<li>重新执⾏时，能从断点处继续执⾏。</li>
</ul>
</li>
</ul>
<p><strong>PCB的组织形式</strong><br />通常是通过链表的⽅式进⾏组织，把具有相同状态的进程链在⼀起，组成各种队列。⽐如：</p>
<ul>
<li>将所有处于就绪状态的进程链在⼀起，称为就绪队列；</li>
<li>把所有因等待某事件⽽处于等待状态的进程链在⼀起就组成各种阻塞队列；</li>
<li>另外，对于运⾏队列在单核 CPU 系统中则只有⼀个运⾏指针了，因为单核 CPU 在某个时间，只能运</li>
</ul>
<p>⾏⼀个程序。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652015066182-c65fb80f-8de5-4e33-9413-021c9d29151a.png#averageHue=%23f9f8f8&clientId=u34a44d6d-2b13-4&from=paste&height=364&id=ufaadf455&originHeight=601&originWidth=1139&originalType=binary&ratio=1&rotation=0&showTitle=false&size=52809&status=done&style=none&taskId=ubd32928e-852d-4117-a3d9-15f1712c0a6&title=&width=690.3029904045919" alt="image.png"><br />除了链接的组织⽅式，还有索引⽅式，它的⼯作原理：将同⼀状态的进程组织在⼀个索引表中，索引表项<br />指向相应的 PCB，不同状态对应不同的索引表。<br />⼀般会选择链表，因为可能⾯临进程创建，销毁等调度导致进程状态发⽣变化，所以链表能够更加灵活的<br />插⼊和删除。</p>
<p><a name="aP68n"></a></p>
<h3 id="线程操作"><a href="#线程操作" class="headerlink" title="线程操作"></a>线程操作</h3><p><a name="G99FL"></a></p>
<h4 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h4><p>操作系统允许⼀个进程创建另⼀个进程，⽽且允许⼦进程继承⽗进程所拥有的资源，当⼦进程被终⽌时，<br />其在⽗进程处继承的资源应当还给⽗进程。同时，终⽌⽗进程时同时也会终⽌其所有的⼦进程。</p>
<p>创建进程的过程如下：</p>
<ul>
<li>为新进程分配⼀个唯⼀的进程标识号，并申请⼀个空⽩的 PCB，PCB 是有限的，若申请失败则创建</li>
</ul>
<p>失败；</p>
<ul>
<li>为进程分配资源，此处如果资源不⾜，进程就会进⼊等待状态，以等待资源；</li>
<li>初始化 PCB；</li>
<li>如果进程的调度队列能够接纳新进程，那就将进程插⼊到就绪队列，等待被调度运⾏。</li>
</ul>
<p><a name="JVltY"></a></p>
<h4 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h4><p>进程可以有 3 种终⽌⽅式：正常结束、异常结束以及外界⼲预（信号 kill 掉）。<br />终⽌进程的过程如下：</p>
<ul>
<li>查找需要终⽌的进程的 PCB；</li>
<li>如果处于执⾏状态，则⽴即终⽌该进程的执⾏，然后将 CPU 资源分配给其他进程；</li>
<li>如果其还有⼦进程，则应将其所有⼦进程终⽌；</li>
<li>将该进程所拥有的全部资源都归还给⽗进程或操作系统；</li>
<li>将其从 PCB 所在队列中删除。</li>
</ul>
<p><a name="RXJlY"></a></p>
<h4 id="阻塞进程"><a href="#阻塞进程" class="headerlink" title="阻塞进程"></a>阻塞进程</h4><p>当进程需要等待某⼀事件完成时，它可以调⽤阻塞语句把⾃⼰阻塞等待。⽽⼀旦被阻塞等待，它只能由另<br />⼀个进程唤醒。<br />阻塞进程的过程如下：</p>
<ul>
<li>找到将要被阻塞进程标识号对应的 PCB；</li>
<li>如果该进程为运⾏状态，则保护其现场，将其状态转为阻塞状态，停⽌运⾏；</li>
<li>将该 PCB 插⼊到阻塞队列中去。</li>
</ul>
<p><a name="i0Xl0"></a></p>
<h4 id="唤醒进程"><a href="#唤醒进程" class="headerlink" title="唤醒进程"></a>唤醒进程</h4><p>进程由「运⾏」转变为「阻塞」状态是由于进程必须等待某⼀事件的完成，所以处于阻塞状态的进程是绝<br />对不可能叫醒⾃⼰的。<br />如果某进程正在等待 I&#x2F;O 事件，需由别的进程发消息给它，则只有当该进程所期待的事件出现时，才由发<br />现者进程⽤唤醒语句叫醒它。<br />唤醒进程的过程如下：</p>
<ul>
<li>在该事件的阻塞队列中找到相应进程的 PCB；</li>
<li>将其从阻塞队列中移出，并置其状态为就绪状态；</li>
<li>把该 PCB 插⼊到就绪队列中，等待调度程序调度；</li>
<li>进程的阻塞和唤醒是⼀对功能相反的语句，<strong>如果某个进程调用了阻塞语句，则必有⼀个与之对应的唤醒语</strong></li>
</ul>
<p><strong>句</strong>。</p>
<p><a name="iQYbW"></a></p>
<h3 id="进程的上下文切换"><a href="#进程的上下文切换" class="headerlink" title="进程的上下文切换"></a>进程的上下文切换</h3><p>各个进程之间是共享 CPU 资源的，在不同的时候进程之间需要切换，让不同的进程可以在 CPU 执⾏，那<br />么这个⼀个进程切换到另⼀个进程运⾏，称为进程的上下⽂切换。</p>
<p>大多数操作系统都是多任务，通常⽀持⼤于 CPU 数量的任务同时运⾏。实际上，这些任务并不是同时运行的，只是因为系统在很短的时间内，让各个任务分别在 CPU 运行，于是就造成同时运⾏的错觉。</p>
<p>任务是交给 CPU 运⾏的，那么在每个任务运⾏前，CPU 需要知道任务从哪⾥加载，⼜从哪⾥开始运⾏。</p>
<p>所以，操作系统需要事先帮 CPU 设置好 CPU 寄存器和程序计数器。</p>
<p>程序计数器则是⽤来存储 CPU 正在执⾏的指令位置、或者即将执⾏的下⼀条指令位置。</p>
<p>CPU 寄存器和程序计数是 CPU 在运⾏任何任务前，所必须依赖的环境，这些环境就叫做 CPU上下文。</p>
<p>CPU 上下文切换就是先把前⼀个任务的 CPU 上下⽂（CPU 寄存器和程序计数器）保存起来，然后加载新<br />任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运⾏新任务。<br />系统内核会存储保持下来的上下⽂信息，当此任务再次被分配给 CPU 运⾏时，CPU 会重新加载这些上下<br />文，这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</p>
<p><a name="FDiRH"></a></p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是进程当中的⼀条执⾏流程。</p>
<p>同⼀个进程内多个线程之间可以共享代码段、数据段、打开的⽂件等资源，但每个线程各⾃都有⼀套独⽴<br />的寄存器和栈，这样可以确保线程的控制流是相对独立的。</p>
<p><a name="fykuV"></a></p>
<h3 id="线程与进程的⽐较"><a href="#线程与进程的⽐较" class="headerlink" title="线程与进程的⽐较"></a>线程与进程的⽐较</h3><ul>
<li>进程是资源（包括内存、打开的⽂件等）分配的单位，线程是 CPU 调度的单位；</li>
<li>进程拥有⼀个完整的资源平台，⽽线程只独享必不可少的资源，如寄存器和栈；</li>
<li>线程同样具有就绪、阻塞、执⾏三种基本状态，同样具有状态之间的转换关系；</li>
<li>线程能减少并发执⾏的时间和空间开销。</li>
</ul>
<p><a name="vQCEs"></a></p>
<h3 id="线程的上下⽂切换"><a href="#线程的上下⽂切换" class="headerlink" title="线程的上下⽂切换"></a>线程的上下⽂切换</h3><p>所谓操作系统的任务调度，实际上的调度对象是线程，⽽进程只是给线程提供了虚拟内存、全局变<br />量等资源。</p>
<ul>
<li>当两个线程不是属于同⼀个进程，则切换的过程就跟进程上下⽂切换⼀样；</li>
<li>当两个线程是属于同⼀个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不</li>
</ul>
<p>动，只需要切换线程的私有数据、寄存器等不共享的数据。<br><a name="RFnCM"></a></p>
<h3 id="创建和运行线程"><a href="#创建和运行线程" class="headerlink" title="创建和运行线程"></a>创建和运行线程</h3><p><a name="SGvVw"></a></p>
<h4 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法的参数是给线程指定名字，推荐</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="comment">// run 方法内实现了要执行的任务</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">t1.start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name="xjfOJ"></a></p>
<h4 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task2, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t2.start(); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> () -&gt; log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task2, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t2.start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>runnable底层就是调用了thread的run方法。<br />用 Runnable 更容易与线程池等高级 API 配合<br />用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</p>
<p><a name="GP4S5"></a></p>
<h4 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;()&#123;</span><br><span class="line">    @0verride</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Log.debug( <span class="string">&quot;running...&quot;</span>);</span><br><span class="line">        Thread.sleep( millis: <span class="number">2000</span>);<span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task,name: <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">log.debug(<span class="string">&quot;0&quot;</span>, task.get());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a name="eKLdY"></a></p>
<h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><p><a name="lp8vj"></a></p>
<h4 id="start和run"><a href="#start和run" class="headerlink" title="start和run"></a>start和run</h4><p>直接调用 run 是在主线程中执行了 run，没有启动新的线程<br />使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</p>
<p><a name="zls4c"></a></p>
<h4 id="sleep和yield"><a href="#sleep和yield" class="headerlink" title="sleep和yield"></a>sleep和yield</h4><p><strong>sleep:</strong></p>
<ul>
<li>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）</li>
<li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li>
<li>睡眠结束后的线程未必会立刻得到执行</li>
<li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li>
</ul>
<p><strong>yield:</strong><br />1. 调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程<br />2. 具体的实现依赖于操作系统的任务调度器</p>
<p><a name="uFkan"></a></p>
<h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h4><p><strong>interrupt()并不能真正的停止线程，只是更换了线程状态标志。线程还会继续执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyThread7</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread7</span>();</span><br><span class="line"> </span><br><span class="line">thread.start();</span><br><span class="line">System.out.println(thread.getName() + <span class="string">&quot;线程的中断状态：&quot;</span> + thread.isInterrupted());</span><br><span class="line">thread.interrupt(); <span class="comment">// 由主线程中断了一个子线程</span></span><br><span class="line">System.out.println(thread.getName() + <span class="string">&quot;线程的中断状态：&quot;</span> + thread.isInterrupted());</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">Thread-<span class="number">0</span>线程的中断状态：<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">Thread-<span class="number">0</span>线程的中断状态：<span class="literal">true</span>	</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>在Core Java中有这样一句话：&quot;没有任何语言方面的需求要求一个被中断的程序应该终止。中断一个线程只是为了引起该线程的注意，被中断线程可以决定如何应对中断 &quot;。这句话启发了我们如何正确的中断一个线程，中断一个线程的本质就是中断run()方法的执行，也就是说run()不再执行后，这个线程就结束了。所以，通过中断状态标志位来控制run()方法中逻辑代码的运行，就可以很好的保证线程的中断。</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;    </span><br><span class="line">        <span class="keyword">try</span>&#123;    </span><br><span class="line">             <span class="comment">//这里的while循环不断的检查中断状态，一旦状态转为true，</span></span><br><span class="line">             <span class="comment">//也就是执行了interrupt方法，那么逻辑代码不再执行。   </span></span><br><span class="line">             <span class="keyword">while</span>(!Thread.currentThread().isInterrupted() &amp;&amp; more work to <span class="keyword">do</span>) &#123;    </span><br><span class="line">                    <span class="comment">// do more work; </span></span><br><span class="line">             &#125;   </span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;    </span><br><span class="line">                    <span class="comment">// thread was interrupted during sleep or wait    </span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;    </span><br><span class="line">                   <span class="comment">// cleanup, if required    </span></span><br><span class="line">        &#125;    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p><strong>使用线程对象的stop()方法停止线程</strong><br />stop方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁。<br />所以一般的lock()方法 无法响应中断，而像lockInterruptibly()、tryLock()等方法就会检测线程中断状态，一旦发现线程处于旦中断状态则立即抛出** InterruptedException**</p>
<p>那阻塞状态的线程如果终止呢? 答案 抛出异常！</p>
<p>我们在sleep方法中看到过，它抛出了一个InterruptedException，当一个线程使用了sleep方法（wait、join）处于阻塞状态时，再使用interrupt就会触发sleep方法抛出InterruptedException异常（实际上是给阻塞的线程发出中断信号，阻塞线程检查到中断标识,就会抛出异常），进而导致线程中断。</p>
<p><strong>打断 sleep 的线程, 会清空打断状态。(将标志位改为false)</strong><br /><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43237362/article/details/104416273"><br /></a><br><a name="UnYbh"></a></p>
<h5 id="interrupted-方法"><a href="#interrupted-方法" class="headerlink" title="interrupted()方法"></a>interrupted()方法</h5><p><strong>作用是测试当前线程是否已经中断，线程的中断状态也是由该方法清除</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().interrupt();</span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程的中断状态：&quot;</span> + Thread.currentThread().interrupted());</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程的中断状态：&quot;</span> + Thread.currentThread().interrupted());</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">main线程的中断状态：<span class="literal">true</span></span><br><span class="line">main线程的中断状态：<span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主线程被打断，使用interrupted()方法查看中断状态，发现标志位改为了true；再次使用interrupted()查看中断状态，发现标志位改为false。在第一次使用interrupted()方法时，它返回标志位，同时清除标志位（置为false），导致下一次的返回值变为false。所以interrupted()方法有清除标志位的功能<br /><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43237362/article/details/104416273"><br /></a><br><a name="IXiJe"></a></p>
<h5 id="isInterrupted"><a href="#isInterrupted" class="headerlink" title="isInterrupted()"></a>isInterrupted()</h5><p>测试此线程是否已被中断。线程的中断状态不受此方法的影响</p>
<p><a name="VQNu6"></a></p>
<h4 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h4><p><strong>等待调用join的线程结束，才继续向下运行。</strong></p>
<p><a name="S6HW0"></a></p>
<h4 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait notify"></a>wait notify</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652338651309-4599722a-8716-4dcf-89b0-9c5b62fafe3e.png#averageHue=%23f6f8f2&clientId=uda4812d7-352a-4&from=paste&height=369&id=ud32a6d57&originHeight=554&originWidth=1396&originalType=binary&ratio=1&rotation=0&showTitle=false&size=307339&status=done&style=none&taskId=u96a5f588-6473-4540-bd82-7d7806c7c4d&title=&width=930.6666666666666" alt="image.png"></p>
<ul>
<li>Owner线程发现条件不满足，调用wait方法，即可进入WaitSet变为WAITING状态</li>
<li>BLOCKED和WAITING的线程都处于阻塞状态，<strong>不占用CPU时间片</strong></li>
<li>BLOCKED线程会在Owner线程释放锁时唤醒</li>
<li>WAITNG线程会在Owner线程调用notify或notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，<strong>仍需进入EntryList重新竞争</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="keyword">while</span>(条件不成立)&#123;</span><br><span class="line">        lock.wait( );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//干活</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">另一个线程</span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    lock.notifyAll( );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name="OlK6D"></a></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><a name="nP6HL"></a></p>
<h4 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h4><ul>
<li>sleep是Thread方法，而wait是Object的方法</li>
<li>sleep不需要强制和synchronized配合使用，但wait需要和synchronized一起用</li>
<li>sleep在睡眠的同时，不会释放对象锁的，但wait在等待的时候会释放对象锁。</li>
</ul>
<p><a name="Rcpgi"></a></p>
<h4 id="park-unpark"><a href="#park-unpark" class="headerlink" title="park unpark"></a>park unpark</h4><p>它们是LockSupport类中的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暂停当前线程</span></span><br><span class="line">LockSupport.park( );</span><br><span class="line"><span class="comment">//恢复某个线程的运行</span></span><br><span class="line">LockSupport.unpark(暂停线程对象)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652342049662-9ec70bbc-86c6-431e-b0eb-22d78438368b.png#averageHue=%23fbfaf7&clientId=uda4812d7-352a-4&from=paste&height=407&id=Mmz8A&originHeight=610&originWidth=807&originalType=binary&ratio=1&rotation=0&showTitle=false&size=215921&status=done&style=none&taskId=u7b8a9d81-18d8-494e-9a3f-0f9a39db456&title=&width=538" alt="image.png"><br />与Object的 wait &amp; notify相比</p>
<ul>
<li>wait，notify和notifyAll必须配合Object Monitor一起使用，而park，unpark不必</li>
<li>park &amp; unpark是以线程为单位来【阻塞】和【唤醒】线程，而notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】</li>
<li>park &amp; unpark可以先unpark，而wait &amp; notify 不能先notify</li>
</ul>
<p><strong>原理:</strong><br />调用park就是要看需不需要停下来歇息</p>
<ul>
<li>如果备用干粮耗尽，那么钻进帐篷歇息</li>
<li>如果备用干粮充足，那么不需停留，继续前进</li>
</ul>
<p>调用unpark，就好比令干粮充足</p>
<ul>
<li>如果这时线程还在帐篷，就唤醒让他继续前进</li>
<li>如果这时线程还在运行，那么下次他调用park时，仅是消耗掉备用干粮，不需停留继续刖进</li>
<li>因为背包空间有限，多次调用unpark仅会补充一份备用干粮</li>
</ul>
<p><a name="EYNYf"></a></p>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><p><a name="dAzv2"></a></p>
<h4 id="不推荐的方法"><a href="#不推荐的方法" class="headerlink" title="不推荐的方法"></a>不推荐的方法</h4><p>这些方法已过时，容易破坏同步代码块，造成线程死锁</p>
<ul>
<li>stop() 停止线程运行</li>
<li>suspend() 挂起（暂停）线程运行</li>
<li>resume() 恢复线程运行</li>
</ul>
<p><a name="crgLq"></a></p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p>
<p><a name="AaLjj"></a></p>
<h2 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h2><p>每个Java对象都可以关联一个Monitor对象，如果使用synchronized给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向Monitor对象的指针。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652099542729-3c06ed19-823d-415a-853b-1363f0c6b875.png#averageHue=%23f5f6f0&clientId=u9ed45425-92a7-4&from=paste&height=292&id=uf25da9a0&originHeight=547&originWidth=1391&originalType=binary&ratio=1&rotation=0&showTitle=false&size=281661&status=done&style=none&taskId=u4c5f7338-673d-4f92-99fe-f1fa3d791d8&title=&width=741.8666666666667" alt="image.png"></p>
<ul>
<li>刚开始Monitor中Owner为null</li>
<li>当Thread-2 执行synchronized(obj)就会将Monitor的所有者Owner置为Thread-2，Monitor中只能有一个Owner</li>
<li>在Thread-2上锁的过程中，如果Thread-3，Thread-4，Thread-5也来执行synchronized(obj)，就会进入EntryList BLOCKED</li>
<li>Thread-2执行完同步代码块的内容，然后唤醒EntryList 中等待的线程来竞争锁，竞争的时是非公平的</li>
<li>图中 WaitSet中的Thread-0，Thread-1是之前获得过锁，调用了wait()方法的线程。</li>
<li>一个对象对应一个monitor</li>
</ul>
<p><a name="V24EM"></a></p>
<h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2><p><a name="Tgg5X"></a></p>
<h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><p><a name="RdCCA"></a></p>
<h2 id="reetrantLock"><a href="#reetrantLock" class="headerlink" title="reetrantLock"></a>reetrantLock</h2><p>相对于synchronized它具备如下特点</p>
<ul>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置为公平锁</li>
<li>支持多个条件变量</li>
<li>和synchronized一样，都支持可重入</li>
<li>不公平锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取锁</span></span><br><span class="line">reentrantLock .lock( );</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//临界区</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">reentrantLock.unlock( );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a name="sr4OZ"></a></p>
<h3 id="Condition-条件变量"><a href="#Condition-条件变量" class="headerlink" title="Condition 条件变量"></a>Condition 条件变量</h3><p>ReentrantLock的条件变量比 synchronized强大之处在于，它是支持多个条件变量的，这就好比 synchronized是那些不满足条件的线程都在一间休息室等消息，而ReentrantLock支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒。</p>
<p>使用流程</p>
<ul>
<li>await 前需要获得锁</li>
<li>await 执行后，会释放锁，进入conditionObject 等待</li>
<li>await的线程被唤醒（回打断、或超时）取重新竞争lock锁</li>
<li>竞争 lock 锁成功后，从await后继续执行</li>
</ul>
<p>对应唤醒方法 signal();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitCigaretteQueue</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitbreakfastQueue</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">hasCigrette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">hasBreakfast</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             lock.lock();</span><br><span class="line">             <span class="keyword">while</span> (!hasCigrette) &#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     waitCigaretteQueue.await();</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">                 log.debug(<span class="string">&quot;等到了它的烟&quot;</span>);</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             lock.unlock();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             lock.lock();</span><br><span class="line">             <span class="keyword">while</span> (!hasBreakfast) &#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     waitbreakfastQueue.await();</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             log.debug(<span class="string">&quot;等到了它的早餐&quot;</span>);</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             lock.unlock();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;).start();</span><br><span class="line">     sleep(<span class="number">1</span>);</span><br><span class="line">     sendBreakfast();</span><br><span class="line">     sleep(<span class="number">1</span>);</span><br><span class="line">     sendCigarette();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendCigarette</span><span class="params">()</span> &#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         log.debug(<span class="string">&quot;送烟来了&quot;</span>);</span><br><span class="line">         hasCigrette = <span class="literal">true</span>;</span><br><span class="line">         waitCigaretteQueue.signal();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendBreakfast</span><span class="params">()</span> &#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         log.debug(<span class="string">&quot;送早餐来了&quot;</span>);</span><br><span class="line">         hasBreakfast = <span class="literal">true</span>;</span><br><span class="line">         waitbreakfastQueue.signal();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a name="StHTV"></a></p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.n8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.log.LogDelegateFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestPool&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPool</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPool</span>(<span class="number">1</span>,</span><br><span class="line">                <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="number">1</span>, (queue, task)-&gt;&#123;</span><br><span class="line">            <span class="comment">// 1. 死等</span></span><br><span class="line"><span class="comment">//            queue.put(task);</span></span><br><span class="line">            <span class="comment">// 2) 带超时等待</span></span><br><span class="line"><span class="comment">//            queue.offer(task, 1500, TimeUnit.MILLISECONDS);</span></span><br><span class="line">            <span class="comment">// 3) 让调用者放弃任务执行</span></span><br><span class="line"><span class="comment">//            log.debug(&quot;放弃&#123;&#125;&quot;, task);</span></span><br><span class="line">            <span class="comment">// 4) 让调用者抛出异常</span></span><br><span class="line"><span class="comment">//            throw new RuntimeException(&quot;任务执行失败 &quot; + task);·</span></span><br><span class="line">            <span class="comment">// 5) 让调用者自己执行任务</span></span><br><span class="line">            task.run();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();reject</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, j);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span> <span class="comment">// 拒绝策略</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">RejectPolicy</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">(BlockingQueue&lt;T&gt; queue, T task)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.ThreadPool&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程集合</span></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> coreSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取任务时的超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        <span class="comment">// 当任务数没有超过 coreSize 时，直接交给 worker 对象执行</span></span><br><span class="line">        <span class="comment">// 如果任务数超过 coreSize 时，加入任务队列暂存</span></span><br><span class="line">        <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">            <span class="keyword">if</span>(workers.size() &lt; coreSize) &#123;</span><br><span class="line">                <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(task);</span><br><span class="line">                log.debug(<span class="string">&quot;新增 worker&#123;&#125;, &#123;&#125;&quot;</span>, worker, task);</span><br><span class="line">                workers.add(worker);</span><br><span class="line">                worker.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//                taskQueue.put(task);</span></span><br><span class="line">                <span class="comment">// 1) 死等</span></span><br><span class="line">                <span class="comment">// 2) 带超时等待</span></span><br><span class="line">                <span class="comment">// 3) 让调用者放弃任务执行</span></span><br><span class="line">                <span class="comment">// 4) 让调用者抛出异常</span></span><br><span class="line">                <span class="comment">// 5) 让调用者自己执行任务</span></span><br><span class="line">                taskQueue.tryPut(rejectPolicy, task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPool</span><span class="params">(<span class="type">int</span> coreSize, <span class="type">long</span> timeout, TimeUnit timeUnit, <span class="type">int</span> queueCapcity, RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="built_in">this</span>.timeout = timeout;</span><br><span class="line">        <span class="built_in">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="built_in">this</span>.taskQueue = <span class="keyword">new</span> <span class="title class_">BlockingQueue</span>&lt;&gt;(queueCapcity);</span><br><span class="line">        <span class="built_in">this</span>.rejectPolicy = rejectPolicy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            <span class="comment">// 1) 当 task 不为空，执行任务</span></span><br><span class="line">            <span class="comment">// 2) 当 task 执行完毕，再接着从任务队列获取任务并执行</span></span><br><span class="line"><span class="comment">//            while(task != null || (task = taskQueue.take()) != null) &#123;</span></span><br><span class="line">            <span class="keyword">while</span>(task != <span class="literal">null</span> || (task = taskQueue.poll(timeout, timeUnit)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;正在执行...&#123;&#125;&quot;</span>, task);</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (workers) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;worker 被移除&#123;&#125;&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">                workers.remove(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.BlockingQueue&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockingQueue</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 1. 任务队列</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 生产者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">fullWaitSet</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 消费者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">emptyWaitSet</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capcity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlockingQueue</span><span class="params">(<span class="type">int</span> capcity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capcity = capcity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带超时阻塞获取</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将 timeout 统一转换为 纳秒</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 返回值是剩余时间</span></span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nanos = emptyWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞获取</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">take</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emptyWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(T task)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capcity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;等待加入任务队列 &#123;&#125; ...&quot;</span>, task);</span><br><span class="line">                    fullWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带超时时间阻塞添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(T task, <span class="type">long</span> timeout, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> timeUnit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capcity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    log.debug(<span class="string">&quot;等待加入任务队列 &#123;&#125; ...&quot;</span>, task);</span><br><span class="line">                    nanos = fullWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue.size();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryPut</span><span class="params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断队列是否满</span></span><br><span class="line">            <span class="keyword">if</span>(queue.size() == capcity) &#123;</span><br><span class="line">                rejectPolicy.reject(<span class="built_in">this</span>, task);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 有空闲</span></span><br><span class="line">                log.debug(<span class="string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);</span><br><span class="line">                queue.addLast(task);</span><br><span class="line">                emptyWaitSet.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="mHmgu"></a></p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p><a name="eUkjQ"></a></p>
<h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>ThreadPoolExecutor使用int的高3位来表示状态，低29位表示线程数量<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652615305684-93eb1080-2675-4e22-a601-d6e897d8c7a0.png#averageHue=%23eeeeee&clientId=ua41d68fc-b28c-4&from=paste&height=265&id=u3b03a6ec&originHeight=398&originWidth=1487&originalType=binary&ratio=1&rotation=0&showTitle=false&size=219096&status=done&style=none&taskId=ue3616037-fcea-4a3d-8822-75377b41119&title=&width=991.3333333333334" alt="image.png"></p>
<p><a name="ru0jS"></a></p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, (核心线程数)</span></span><br><span class="line">                              <span class="type">int</span> maximumPoolSize, (最大线程数) </span><br><span class="line">                              <span class="type">long</span> keepAliveTime,(生存时间)</span><br><span class="line">                              TimeUnit unit,(生存时间-时间单位)</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,(阻塞队列)</span><br><span class="line">                              ThreadFactory threadFactory,(线程工厂)</span><br><span class="line">                              RejectedExecutionHandler handler) (拒绝策略)</span><br></pre></td></tr></table></figure>
<p>当核心线程和阻塞队列都被占满时，就会先创建救急线程来执行任务，如果救急线程都不够了，才会使用拒绝策略。<br />救急线程数&#x3D;maximumPoolSize-corePoolSize；<br />当救急线程空闲下来，存活的时间&#x3D;keepAliveTime；</p>
<p><strong>拒绝策略：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652618529015-3760401d-dbea-47d0-88ab-60231f945b07.png#averageHue=%23faf9f2&clientId=ua41d68fc-b28c-4&from=paste&height=159&id=u45a1a778&originHeight=238&originWidth=1423&originalType=binary&ratio=1&rotation=0&showTitle=false&size=143786&status=done&style=none&taskId=uef982398-83de-49fa-87ab-62a69a18e04&title=&width=948.6666666666666" alt="image.png"></p>
<ul>
<li>AbortPolicy让调用者抛出RejectedExecutionException异常，这是默认策略</li>
<li>CallerRunsPolicy让调用者运行任务</li>
<li>DiscardPolicy 放弃本次任务</li>
<li>DiscardOldestPolicy放弃队列中最早的任务，本任务取而代之。</li>
</ul>
<p><strong>其他框架拒绝策略实现</strong></p>
<ul>
<li>Dubbo的实现，在抛出RejectedExecutionException异常之前会记录日志,并dump线程栈信息，方便定位问题</li>
<li>Netty 的实现，是创建一个新线程来执行任务</li>
<li>ActiveMQ的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略 </li>
<li>PinPoint的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li>
</ul>
<p><a name="C23hI"></a></p>
<h3 id="工厂方法创建线程池"><a href="#工厂方法创建线程池" class="headerlink" title="工厂方法创建线程池"></a>工厂方法创建线程池</h3><p><a name="f6PBD"></a></p>
<h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>,TimeUnit.MILLISECONDs,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>核心线程数&#x3D;&#x3D;最大线程数（没有救急线程被创建)，因此也无需超时时间<br />阻塞队列是无界的，可以放任意数量的任务</p>
<p><a name="ouVaY"></a></p>
<h4 id="newCacheThreadPool"><a href="#newCacheThreadPool" class="headerlink" title="newCacheThreadPool"></a>newCacheThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>,Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>,TimeUnit.SECONDs,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>核心线程数是0，最大线程数是Integer.MAX_VALUE，救急线程的空闲生存时间是60s，意味着</p>
<ul>
<li>全部都是救急线程（60s后可以回收)</li>
<li>救急线程可以无限创建</li>
</ul>
<p>队列采用了SynchronousQueue实现特点是，它没有容量，没有线程来取是放不进去的(一手交钱、一手交货)</p>
<p><a name="pgIji"></a></p>
<h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Executorservice <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">     (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">                             <span class="number">0L</span>,TimeUnit.MILLISECONDs,</span><br><span class="line">                             <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作</p>
<ul>
<li><p>Executors.newSingleThreadExecutor()线程个数始终为1，不能修改</p>
<ul>
<li>FinalizableDelegatedExecutorService应用的是装饰器模式，只对外暴露了ExecutorService接口，因此不能调用ThreadPoolExecutor 中特有的方法</li>
</ul>
</li>
<li><p>Executors.newFixedThreadPool(1)初始时为1，以后还可以修改</p>
<ul>
<li>对外暴露的是ThreadPoolExecutor对象，可以强转后调用setCorePoolSize等方法进行修改</li>
</ul>
</li>
</ul>
<p><a name="QrC4d"></a></p>
<h2 id="Fork-x2F-Join"><a href="#Fork-x2F-Join" class="headerlink" title="Fork&#x2F;Join"></a>Fork&#x2F;Join</h2><p>Fork&#x2F;Join是JDK1.7加入的新的线程池实现，它体现的是一种分治思想。适用于能够进行任务拆分的cpu密集型运算。</p>
<p>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列、都可以用分治思想进行求解。</p>
<p>Fork&#x2F;Join在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率。</p>
<p>Fork&#x2F;Join默认会创建与cpu核心数大小相同的线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">4</span>);</span><br><span class="line"><span class="comment">//        System.out.println(pool.invoke(new AddTask1(5)));</span></span><br><span class="line">        System.out.println(pool.invoke(<span class="keyword">new</span> <span class="title class_">AddTask3</span>(<span class="number">1</span>, <span class="number">5</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简单拆分 每次加法拆一个线程</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.AddTask&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddTask1</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddTask1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> + n + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;join() &#123;&#125;&quot;</span>, n);</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">AddTask1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask1</span>(n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//拆分</span></span><br><span class="line">        t1.fork();</span><br><span class="line">        log.debug(<span class="string">&quot;fork() &#123;&#125; + &#123;&#125;&quot;</span>, n, t1);</span><br><span class="line">        <span class="comment">//join:得到这次拆分的结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> n + t1.join();</span><br><span class="line">        log.debug(<span class="string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, n, t1, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分法拆分</span></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.AddTask&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddTask3</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> begin;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddTask3</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.begin = begin;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> + begin + <span class="string">&quot;,&quot;</span> + end + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;join() &#123;&#125;&quot;</span>, begin);</span><br><span class="line">            <span class="keyword">return</span> begin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end - begin == <span class="number">1</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, begin, end, end + begin);</span><br><span class="line">            <span class="keyword">return</span> end + begin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (end + begin) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">AddTask3</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask3</span>(begin, mid);</span><br><span class="line">        t1.fork();</span><br><span class="line">        <span class="type">AddTask3</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask3</span>(mid + <span class="number">1</span>, end);</span><br><span class="line">        t2.fork();</span><br><span class="line">        log.debug(<span class="string">&quot;fork() &#123;&#125; + &#123;&#125; = ?&quot;</span>, t1, t2);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> t1.join() + t2.join();</span><br><span class="line">        log.debug(<span class="string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, t1, t2, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><a name="BB3Fs"></a></p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>全称是AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652853489298-79c23aa0-a5a0-4044-8128-f10337964b30.png#averageHue=%23fcfcfc&clientId=u0ee394ca-2eaa-4&from=paste&height=321&id=u2cf38110&originHeight=481&originWidth=976&originalType=binary&ratio=1&rotation=0&showTitle=false&size=119476&status=done&style=none&taskId=u02dd47a0-cef2-430d-8ae7-fde31f5781f&title=&width=650.6666666666666" alt="image.png"><br />AQS使用一个violatile的int类型的成员变量<strong>state</strong>来表示同步状态，通过内置的<strong>FIFO队列</strong>来完成资源获取的排队工作，将每条要抢占资源的线程封装成一个Node节点来完成锁的分配，通过CAS完成对state值的修改</p>
<p>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore&#x2F;CountDownLatch）。</p>
<p>ReetrantLock之类的自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p>
<ul>
<li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
<li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>
<li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返w回false。</li>
<li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>
</ul>
<p>自定义同步器内部会有一个AbstractQueuedSynchronizer的子类对象sync来使用aqs的内部API完成锁相关的操作。</p>
<p>Node结点是对每一个等待获取资源的线程的封装，其包含了需要同步的线程本身及其等待状态，如是否被阻塞、是否等待唤醒、是否已经被取消等。变量waitStatus则表示当前Node结点的等待状态，共有5种取CANCELLED、SIGNAL、CONDITION、PROPAGATE、0。</p>
<ul>
<li>CANCELLED(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</li>
<li>SIGNAL(-1)：<strong>表示后继结点在等待当前结点唤醒</strong>。后继结点入队时，会将前继结点的状态更新为SIGNAL。</li>
<li>CONDITION(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。</li>
<li>PROPAGATE(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li>
<li>0：新结点入队时的默认状态<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响<br /><strong>tryAcquire(int)：</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">//AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><a name="c5HZ8"></a></p>
<h2 id="reetrantLock原理"><a href="#reetrantLock原理" class="headerlink" title="reetrantLock原理"></a>reetrantLock原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync是ReentrantLock的一个属性对象  aqs的子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;<span class="comment">//reetrantLock中有两个sync实现类 </span></span><br><span class="line">        ......</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//非公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                <span class="comment">//设置aps中一个变量为当前线程，记录当前抢占到锁的线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假如有三个线程ABC ,线程A首先拿到了锁，线程B执行lock方法时就会走到<strong>acquire</strong>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是调用的sync父类-aqs的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;</span><br><span class="line">            selfInt	<span class="title function_">errupt</span><span class="params">()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a name="T3MMS"></a></p>
<h4 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h4><p>见代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里调用进入非公平锁的tryAcquire</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 具体代码在这里</span></span><br><span class="line">	<span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="comment">//若当前无其他线程抢占锁，则抢占；这里体现了非公平锁。</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">           <span class="comment">//如果已获取锁的线程再调用lock()则state值+1，这里就是可重入的原理</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 都不是则返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//显然 此时应该返回false 就会走后面的判断</span></span><br><span class="line"><span class="comment">//acquireQueued(addWaiter(Node.EXCLUSIVE), arg) 先看 addwaiter方法</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    	<span class="comment">// 创建一个节点 mode</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">// 刚开始tail是null，如果tail有值了就将node插入队尾；</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                    pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若队列为空，则插入节点</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果队列中有节点，队尾就不会为空，就将当前节点作为尾节点，此时队列为空，走enq方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 死循环</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// 初始下tail为null，因此创建一个头节点</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;<span class="comment">// 第二次循环，队列不为空，就将该节点插入队尾</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>enq插入节点是死循环:<br />第一次循环，由于tail为空，他先创建一个空的node节点，作为头节点，此时waitStatus&#x3D;0，然后将head指向该头节点，并将tail指针也指向head;<br />第二次循环，他将待插入node节点（线程B）的前置指针指向tail指向的节点（头节点），然后CAS将tail指向当前待插入节点（线程B），再让原来的tail指向的节点（头节点）的next域指向当前节点，这样就完成了节点（线程B）插入队尾，完成链式结构，跳出循环；<br /><code>此时head依然是虚拟头节点，tail指向刚插入的节点</code></p>
<p>现在就要进入前面acquire的AQS.acquireQueued(node, 1)方法了 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();<span class="comment">//获取节点的前置节点，线程B获取到的是头节点</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">//由于线程A占用，尝试获取失败</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())<span class="comment">// 线程B会进入这里</span></span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第一次循环：首先predecessor()取出的就是前置节点，p就是链表中的头节点，然后进入判断，当前确实是头节点，然后再次尝试tryAcquire()，由于线程A并没有释放锁，因此，只能进入shouldParkAfterFailedAcquire()方法；	</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;<span class="comment">// 头节点的waitStatus=0</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)<span class="comment">// -1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<span class="comment">// 将头节点的waitStatus设置成-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//AQS.shouldParkAfterFailedAcquire(头节点，当前节点)，由于头节点的waitStatus等于0，</span></span><br><span class="line"><span class="comment">//因此这里最终将头节点的waitStatus设置成-1，并返回false；</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后进行第二次循环，再次进入shouldParkAfterFailedAcquire(),这一次由于ws&#x3D;-1，因此返回true，并进入parkAndCheckInterrupt()方法；这里会调用LockSupport.park()将线程挂起，此刻线程B就阻塞再这里了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">       LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">       <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接着线程C调用lock()方法<br />省略前面的步骤，跳到addWaiter方法。<br />此刻addWaiter()方法的执行和线程B就有区别了，因为CLH队列有节点了，他直接将创建好的Node插入队尾并返回；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    	<span class="comment">// 创建一个节点 线程C</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">         <span class="comment">// 此时队列右节点，进入if</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 插入线程C节点到队尾并返回</span></span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 线程C不走这里</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接着是acquireQueued()方法这里由于线程C的前置节点不是头节点，因此直接进入shouldParkAfterFailedAcquire()将线程B的状态改为-1；这里线程C把线程B节点的status改为了-1；</p>
<p>线程A调用unlock()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行ReentrantLock.unlock()</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// AQS.release()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 执行ReentrantLock.tryRelease()</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//c==0才会返回true 实现锁重入</span></span><br><span class="line">                free = <span class="literal">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//这里呢，线程A就先去获取AQS的state，并对应减去1个，并设置当前占有线程为null，</span></span><br><span class="line"><span class="comment">//然后找到头节点去调用unparkSuccessor(head);</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;<span class="comment">// 头节点是-1</span></span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);<span class="comment">// 头节点设置为0</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;<span class="comment">// 线程B</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。</span></span><br><span class="line"><span class="comment">        * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，</span></span><br><span class="line"><span class="comment">        * 稍后就会被保安大叔赶走了(GC回收)！</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="literal">null</span>) </span><br><span class="line">            LockSupport.unpark(s.thread);<span class="comment">//唤醒线程B</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//此刻进入unparkSuccessor(头节点)中，他将头节点的状态从-1设置为0，然后唤醒线程B；</span></span><br></pre></td></tr></table></figure>
<p>线程B唤醒后就会执行acquireQueued第三次循环<br />第三次循环时，执行tryAcquire 如果此时又来了一个线程获取锁，就会和线程B竞争，看获取到。这就是非公平的体现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();<span class="comment">//获取节点的前置节点，线程B获取到的是头节点</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">//目前锁无占用，进入此处</span></span><br><span class="line">                    setHead(node); <span class="comment">// 重新设置头节点</span></span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted; <span class="comment">// 被改为true</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())<span class="comment">// 线程B从这里唤醒</span></span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改头节点</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHead</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        head = node;</span><br><span class="line">        node.thread = <span class="literal">null</span>;</span><br><span class="line">        node.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a name="VMTzC"></a></p>
<h4 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h4><p><strong>不可打断模式</strong><br />在此模式下，即使它被打断，仍会驻留在AQS队列中，等获得锁后方能继续运行（是继续运行!只是打断标记被设置为true)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())<span class="comment">// 线程B会进入这里</span></span><br><span class="line">                    <span class="comment">//线程在这里阻塞,如果外面调用打断方法会唤醒线程  看下面的方法</span></span><br><span class="line">                    <span class="comment">//就会将interrupted置为true,然后继续for循环</span></span><br><span class="line">                    <span class="comment">//后面的循环又会park住</span></span><br><span class="line">                    <span class="comment">//当之前获取到锁的线程释放锁，唤醒park</span></span><br><span class="line">                    <span class="comment">// 此时下面的方法会返回false跳出if, 此时interrupted为true</span></span><br><span class="line">                    <span class="comment">//正常没有打断的情况。parkAndCheckInterrupt返回的都是false就不会进入if语句</span></span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//打断后 返回true但是线程中断标志位为false。返回true会执行后面的if语句,</span></span><br><span class="line">        <span class="comment">//如果不清除打断标记，那线程中断标志位就为true,park会失效，无法阻塞。</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是调用的sync父类-aqs的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;</span><br><span class="line">            <span class="comment">//被打断后 acquireQueued返回true  会执行selfInterrupt方法 执行中断</span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name="jIeXF"></a></p>
<h4 id="公平锁的原理"><a href="#公平锁的原理" class="headerlink" title="公平锁的原理"></a>公平锁的原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">     acquire(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (</span><br><span class="line">         !tryAcquire(arg) &amp;&amp;</span><br><span class="line">         acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">         ) &#123;</span><br><span class="line">             selfInterrupt();</span><br><span class="line">         &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 与非公平锁主要区别在于 tryAcquire 方法的实现</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">     <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">     <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</span></span><br><span class="line">         <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">             compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">             setExclusiveOwnerThread(current);</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">         <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">         setState(nextc);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">     <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">     Node s;</span><br><span class="line">     <span class="comment">// h != t 时表示队列中有 Node</span></span><br><span class="line">     <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">     (</span><br><span class="line">         <span class="comment">// (s = h.next) == null 表示队列中还有没有老二</span></span><br><span class="line">         (s = h.next) == <span class="literal">null</span> ||</span><br><span class="line">            <span class="comment">// 或者队列中老二线程不是此线程</span></span><br><span class="line">         s.thread != Thread.currentThread()</span><br><span class="line">     );</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name="owzuC"></a></p>
<h4 id="条件变量condition的实现原理"><a href="#条件变量condition的实现原理" class="headerlink" title="条件变量condition的实现原理"></a>条件变量condition的实现原理</h4><p>每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">condition.await();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ConditionObject <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">//new ConditionObject()是aqs的方法 返回其内部的ConditionObject对象 是condition类的实现类</span></span><br><span class="line">    </span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>** 开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程  **</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//aqs中ConditionObject对象对condition类await方法的实现  ConditionObject是aqs里面的一个子class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">            <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);		</span><br><span class="line">            <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用addConditionWaiter方法</span></span><br><span class="line"> <span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">//firstWaiter lastWaiter 是条件队列ConditionObject首尾指针</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">            <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">            <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">                t = lastWaiter;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">                firstWaiter = node;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t.nextWaiter = node;</span><br><span class="line">            lastWaiter = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//创建新的 Node 状态为 -2（Node.CONDITION），关联 执行await方法的线程，加入等待队列尾部</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652972599848-303b15d6-c972-4d9b-89ae-db1257d53fb7.png#averageHue=%23f7f7f7&clientId=u0ead8153-855e-4&from=paste&height=375&id=u90f15228&originHeight=563&originWidth=1559&originalType=binary&ratio=1&rotation=0&showTitle=true&size=133829&status=done&style=none&taskId=u1296a2b2-2147-460c-b1f4-7daa8b67cdb&title=addConditionWaiter%E6%B5%81%E7%A8%8B&width=1039.3333333333333" alt="addConditionWaiter流程" title="addConditionWaiter流程"><br /> 接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullyRelease</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> savedState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                node.waitStatus = Node.CANCELLED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//释放锁之后，唤起等待队列里的线程来竞争锁 假设thread-1竞争成功</span></span><br></pre></td></tr></table></figure>
<p> <img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652972885079-9b76a3b1-0a91-4538-ba8b-29baf13b78b5.png#averageHue=%23f7f7f7&clientId=u0ead8153-855e-4&from=paste&height=387&id=u75ce8516&originHeight=581&originWidth=1526&originalType=binary&ratio=1&rotation=0&showTitle=false&size=116750&status=done&style=none&taskId=u9a7cf356-5583-492e-9193-c43c88527f0&title=&width=1017.3333333333334" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652972938747-55423cbf-6587-4290-9e30-72e3da115af6.png#averageHue=%23f7f7f7&clientId=u0ead8153-855e-4&from=paste&height=386&id=u305633f8&originHeight=579&originWidth=1547&originalType=binary&ratio=1&rotation=0&showTitle=false&size=109189&status=done&style=none&taskId=u186ba132-d134-4643-bb5c-0e3871b43b5&title=&width=1031.3333333333333" alt="image.png"><br />接着  Thread-0就会park 阻塞<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652972990458-f25a1df9-5d99-4c1b-96ec-6559fa96bd4c.png#averageHue=%23f7f7f6&clientId=u0ead8153-855e-4&from=paste&height=387&id=u7a44d254&originHeight=580&originWidth=1560&originalType=binary&ratio=1&rotation=0&showTitle=false&size=136533&status=done&style=none&taskId=u04dac3b2-71a6-40aa-a625-5b58eb6d859&title=&width=1040" alt="image.png"></p>
<p><strong>接下来看signal流程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将等待时间最长的线程（如果存在）从该条件的等待队列移动到拥有锁的等待队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">                doSignal(first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//将first移除条件队列</span></span><br><span class="line">                <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)</span><br><span class="line">                    lastWaiter = <span class="literal">null</span>;</span><br><span class="line">                first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//transferForSignal将firrst转移到等待锁的队列</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                     (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * cas设置当前节点的waitStauts为1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入队列</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">        <span class="comment">//将前驱节点的状态改成-1 代表有责任唤醒下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>假设Thread-1唤醒Thread-0<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652980463373-f25b7968-a431-4f0e-b315-e658a4270ee4.png#averageHue=%23f6f6f6&clientId=u0ead8153-855e-4&from=paste&height=485&id=u570bd8a4&originHeight=727&originWidth=1544&originalType=binary&ratio=1&rotation=0&showTitle=false&size=139194&status=done&style=none&taskId=ub5ac7abd-0a1a-4e3a-a122-6f547ebfab8&title=&width=1029.3333333333333" alt="image.png"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652980745484-9980a48f-54c3-44ea-ba94-b946b9271b45.png#averageHue=%23f5f5f5&clientId=u0ead8153-855e-4&from=paste&height=469&id=u9a99b3b2&originHeight=704&originWidth=1543&originalType=binary&ratio=1&rotation=0&showTitle=true&size=137224&status=done&style=none&taskId=ub53047b9-2406-4052-8620-b2a93534228&title=%E8%BF%9B%E5%85%A5%20ConditionObject%20%E7%9A%84%20doSignal%20%E6%B5%81%E7%A8%8B%EF%BC%8C%E5%8F%96%E5%BE%97%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%20Node%EF%BC%8C%E5%8D%B3%20Thread-0%20%E6%89%80%E5%9C%A8%20Node&width=1028.6666666666667" alt="进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node" title="进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652980772291-d8079b72-ecdb-4718-9002-7f69b9eb682d.png#averageHue=%23f7f7f7&clientId=u0ead8153-855e-4&from=paste&height=372&id=u1fad4a00&originHeight=558&originWidth=1578&originalType=binary&ratio=1&rotation=0&showTitle=true&size=129095&status=done&style=none&taskId=ud387efbb-e461-4c8b-b8f9-46c488f9400&title=%E6%89%A7%E8%A1%8C%20transferForSignal%20%E6%B5%81%E7%A8%8B%EF%BC%8C%E5%B0%86%E8%AF%A5%20Node%20%E5%8A%A0%E5%85%A5%20AQS%20%E9%98%9F%E5%88%97%E5%B0%BE%E9%83%A8%EF%BC%8C%E5%B0%86%20Thread-0%20%E7%9A%84%20waitStatus%20%E6%94%B9%E4%B8%BA%200%EF%BC%8CThread-3%20%E7%9A%84%0D%20waitStatus%20%E6%94%B9%E4%B8%BA%20-1&width=1052" alt="执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的
 waitStatus 改为 -1" title="执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的
 waitStatus 改为 -1"></p>
<p><a name="RAdza"></a></p>
<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>当读操作远远高于写操作时，这时候使用 读写锁 让 读-读 可以并发，提高性能。 类似于数据库中的 select …<br />from … lock in share mode</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataContainer</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> Object data;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">     <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">r</span> <span class="operator">=</span> rw.readLock();</span><br><span class="line">     <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">w</span> <span class="operator">=</span> rw.writeLock();</span><br><span class="line">     <span class="keyword">public</span> Object <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">         log.debug(<span class="string">&quot;获取读锁...&quot;</span>);</span><br><span class="line">         r.lock();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             log.debug(<span class="string">&quot;读取&quot;</span>);</span><br><span class="line">             sleep(<span class="number">1</span>);</span><br><span class="line">             <span class="keyword">return</span> data;</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             log.debug(<span class="string">&quot;释放读锁...&quot;</span>);</span><br><span class="line">             r.unlock();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">         log.debug(<span class="string">&quot;获取写锁...&quot;</span>);</span><br><span class="line">         w.lock();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             log.debug(<span class="string">&quot;写入&quot;</span>);</span><br><span class="line">             sleep(<span class="number">1</span>);</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             log.debug(<span class="string">&quot;释放写锁...&quot;</span>);</span><br><span class="line">             w.unlock();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>读锁不支持条件变量 <br />重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待  <br /> 重入时降级支持：即持有写锁的情况下去获取读锁 </p>
<p><a name="BOVLN"></a></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>读写锁用的是同一个sync锁(aqs的子类)，因此等待队列、state也用的同一个</p>
<p>现在假设有两个线程t1、t2，t1要加写锁，t2加读锁</p>
<p>l ) t1成功上锁，流程与ReentrantLock加锁相比没有特殊之处，不同是写锁状态占了state的低16位，而读锁使用的是state的高16位。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653220859052-b9bac57e-3e71-4ef1-94b6-cef886e281fa.png#averageHue=%23e1eac4&clientId=ub17e8e3a-9055-4&from=paste&height=384&id=ud1003b47&originHeight=576&originWidth=933&originalType=binary&ratio=1&rotation=0&showTitle=false&size=141325&status=done&style=none&taskId=u42f02d98-b9cd-4938-9e75-73e40f5d420&title=&width=622" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">  sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">     <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">     <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">     <span class="comment">//写锁</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line">     <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">         <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">         <span class="comment">// Reentrant acquire</span></span><br><span class="line">         setState(c + acquires);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">         !compareAndSetState(c, c + acquires))</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">         setExclusiveOwnerThread(current);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2 ) t2执行r.lock，这时进入读锁的sync.acquireShared(1)流程，首先会进入tryAcquireShared流程。如果有写锁占据，那么tryAcquireShared返回-1表示失败<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653225812952-44993750-4d10-4c27-ba93-db7847cb5bb3.png#averageHue=%23e6f3c9&clientId=ub17e8e3a-9055-4&from=paste&height=569&id=u2e9e9b4f&originHeight=854&originWidth=1295&originalType=binary&ratio=1&rotation=0&showTitle=false&size=120519&status=done&style=none&taskId=uab94d398-cdee-4d3d-9a73-9e1f83667cc&title=&width=863.3333333333334" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">         sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">     &#125;   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">       <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">       <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">           getExclusiveOwnerThread() != current)</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> sharedCount(c);</span><br><span class="line">       <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">           r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">           compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">           <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">               firstReader = current;</span><br><span class="line">               firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">               firstReaderHoldCount++;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;</span><br><span class="line">               <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                   cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                   readHolds.set(rh);</span><br><span class="line">               rh.count++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br><span class="line">tryAcquireShared返回值表示:</span><br><span class="line">-<span class="number">1</span>表示失败</span><br><span class="line"><span class="number">0</span>表示成功，但后继节点不会继续唤醒</span><br><span class="line">正数表示成功，而且数值是还有几个后继节点需要唤醒，读写锁返回<span class="number">1</span></span><br><span class="line"></span><br><span class="line">这时tryAcquireShared返回-<span class="number">1</span> 执行doAcquireShared方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653225805086-14a075e3-8110-421e-b21d-c742195c4691.png#averageHue=%23f6f6ef&clientId=ub17e8e3a-9055-4&from=paste&height=500&id=u23edce0a&originHeight=750&originWidth=1552&originalType=binary&ratio=1&rotation=0&showTitle=false&size=141630&status=done&style=none&taskId=uab3e4edb-edd0-412c-ab19-89abdbb9d96&title=&width=1034.6666666666667" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后续t3 r.lock,t4 w.lock<br />这种状态下，假设又有t3加读锁和t4加写锁，这期间t1仍然持有锁，就变成了下面的样子<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653225992674-05793ce4-344f-4ff3-b173-589ae2c830b7.png#averageHue=%23f6f6f1&clientId=ub17e8e3a-9055-4&from=paste&height=326&id=u8a7e2c4a&originHeight=489&originWidth=1545&originalType=binary&ratio=1&rotation=0&showTitle=false&size=113643&status=done&style=none&taskId=u8d1d1a08-db16-41fd-8e57-ece92b8637d&title=&width=1030" alt="image.png"><br />t1.unlock()<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653226218143-d29af746-7ebf-4c27-a4ef-28a184cf9498.png#averageHue=%23f6f6f2&clientId=ub17e8e3a-9055-4&from=paste&height=325&id=u91a32bbf&originHeight=487&originWidth=1562&originalType=binary&ratio=1&rotation=0&showTitle=false&size=98666&status=done&style=none&taskId=u8457dcec-c482-40af-9f1d-8c8e3b46c12&title=&width=1041.3333333333333" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">   sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">      <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (free)</span><br><span class="line">          setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">      setState(nextc);</span><br><span class="line">      <span class="keyword">return</span> free;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>解锁之后 会再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一  </p>
<p>这时 t2 已经恢复运行，接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// Record old head for check below</span></span><br><span class="line">        setHead(node);</span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653226764096-323a8c9a-031d-46f7-8f63-56a6a006ccc0.png#averageHue=%23f5f5f0&clientId=ub17e8e3a-9055-4&from=paste&height=393&id=ud3bbc83a&originHeight=589&originWidth=1536&originalType=binary&ratio=1&rotation=0&showTitle=false&size=115288&status=done&style=none&taskId=uf431852c-19e3-4566-8799-76a1526895e&title=&width=1024" alt="image.png">事情还没完，在 setHeadAndPropagate 方法内还会检查下一个节点是否是 shared，如果是则调用<br />doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒老二，这时 t3 在 doAcquireShared 内<br />parkAndCheckInterrupt() 处恢复运行</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653226831987-00a4e893-7e88-4f4f-be33-488e99df4ece.png#averageHue=%23f6f6f1&clientId=ub17e8e3a-9055-4&from=paste&height=417&id=uc3bc5a65&originHeight=626&originWidth=1548&originalType=binary&ratio=1&rotation=0&showTitle=false&size=111248&status=done&style=none&taskId=uac6f72a3-56d3-4457-a6be-a5aa24ad5a8&title=&width=1032" alt="image.png"><br /> 这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一  <br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653226846171-18886aa1-f21a-406d-9cc6-0a593020348d.png#averageHue=%23f7f7f2&clientId=ub17e8e3a-9055-4&from=paste&height=419&id=u586ee9ab&originHeight=629&originWidth=1588&originalType=binary&ratio=1&rotation=0&showTitle=false&size=113141&status=done&style=none&taskId=ue1a92728-3fd0-406c-95c3-5ceaf53eb18&title=&width=1058.6666666666667" alt="image.png"><br /> 这时 t3 已经恢复运行，接下来 t3 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点  <br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653226885140-b8d8002a-0b2e-4499-8101-f3b032a97acb.png#averageHue=%23e8f5ca&clientId=ub17e8e3a-9055-4&from=paste&height=505&id=u0c0ea77d&originHeight=757&originWidth=1546&originalType=binary&ratio=1&rotation=0&showTitle=false&size=148488&status=done&style=none&taskId=ud3c1e7f7-c9eb-43a9-9dd7-dd805cdbba2&title=&width=1030.6666666666667" alt="image.png"><br /> 下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点  </p>
<p><strong>t2 r.unlock，t3 r.unlock</strong><br />t2 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但由于计数还不为零  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">      <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">          <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">          <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">              firstReader = <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">else</span> </span><br><span class="line">              firstReaderHoldCount--;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;</span><br><span class="line">          <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">              rh = readHolds.get();</span><br><span class="line">          <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> rh.count;</span><br><span class="line">          <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">              readHolds.remove();</span><br><span class="line">              <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">          &#125;</span><br><span class="line">          --rh.count;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">          <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c - SHARED_UNIT;</span><br><span class="line">          <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">              <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">              <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">              <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">              <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>t3 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，这回计数为零了，进入 doReleaseShared() 将头节点从 -1 改为 0 并唤醒老二，即  <br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653227818832-ecea2de8-6a3f-429f-8053-77bf25edfc15.png#averageHue=%23f6f6ee&clientId=ub17e8e3a-9055-4&from=paste&height=528&id=u4c8c5c64&originHeight=792&originWidth=1541&originalType=binary&ratio=1&rotation=0&showTitle=false&size=151319&status=done&style=none&taskId=uc1793a48-1c1f-46fa-8852-e1c0a969e9c&title=&width=1027.3333333333333" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后 t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是老二，并且没有其他 竞争，tryAcquire(1) 成功，修改头结点，流程结束  <br />其实写锁就是独占锁 也就是独占模式 和reentrantLock走的同一套流程，(重写tryAcquire)<br />读锁时共享锁 共享模式。(重写tryAcquireShare)</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653227837583-852cf25d-6769-44bd-8b50-dd22e01d7575.png#averageHue=%23e6f3c8&clientId=ub17e8e3a-9055-4&from=paste&height=546&id=u73b0f094&originHeight=819&originWidth=1211&originalType=binary&ratio=1&rotation=0&showTitle=false&size=112813&status=done&style=none&taskId=ua9320c13-f8c2-43fa-80e8-e9e191dcb3f&title=&width=807.3333333333334" alt="image.png"><br><a name="kQoLr"></a></p>
<h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><p>该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataContainerStamped</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">DataContainerStamped</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.data = data;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> readTime)</span> &#123;</span><br><span class="line">     <span class="comment">//StampedLock应该是利用了偏向锁+乐观锁的概念,读读之间的加锁，不会频繁cas操作，只有当</span></span><br><span class="line">     <span class="comment">//有写锁加上时，才会锁升级成读锁</span></span><br><span class="line">     <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line">     log.debug(<span class="string">&quot;optimistic read locking...&#123;&#125;&quot;</span>, stamp);</span><br><span class="line">     sleep(readTime);</span><br><span class="line">     <span class="keyword">if</span> (lock.validate(stamp)) &#123;</span><br><span class="line">         log.debug(<span class="string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);</span><br><span class="line">         <span class="keyword">return</span> data;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 锁升级 - 读锁</span></span><br><span class="line">     log.debug(<span class="string">&quot;updating to read lock... &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         stamp = lock.readLock();</span><br><span class="line">         log.debug(<span class="string">&quot;read lock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">         sleep(readTime);</span><br><span class="line">         log.debug(<span class="string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);</span><br><span class="line">         <span class="keyword">return</span> data;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         log.debug(<span class="string">&quot;read unlock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">         lock.unlockRead(stamp);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> newData)</span> &#123;</span><br><span class="line">     <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">     log.debug(<span class="string">&quot;write lock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         sleep(<span class="number">2</span>);</span><br><span class="line">         <span class="built_in">this</span>.data = newData;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         log.debug(<span class="string">&quot;write unlock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">         lock.unlockWrite(stamp);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name="iULxs"></a></p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量，用来限制能同时访问共享资源的线程上线。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="comment">// 1. 创建 semaphore 对象</span></span><br><span class="line">     <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">     <span class="comment">// 2. 10个线程同时运行</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">             <span class="comment">// 3. 获取许可</span></span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 semaphore.acquire();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">                 sleep(<span class="number">1</span>);</span><br><span class="line">                 log.debug(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                 <span class="comment">// 4. 释放许可</span></span><br><span class="line">                 semaphore.release();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;).start();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name="abRXB"></a></p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>Semaphore内部同样有一个aqs同步器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">        NonfairSync(<span class="type">int</span> <span class="keyword">permits</span>) &#123;</span><br><span class="line">            <span class="comment">//sync的构造</span></span><br><span class="line">            <span class="built_in">super</span>(<span class="keyword">permits</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Sync(<span class="type">int</span> <span class="keyword">permits</span>) &#123;</span><br><span class="line">    setState(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Semaphore 有点像一个停车场，permits 就好像停车位数量，当线程获得了 permits 就像是获得了停车位，然后 停车场显示空余车位减一 刚开始，permits（state）为 3，这时 5 个线程来获取资源。（semaphore.acquire()）<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653361171453-dfdeff10-e74c-4419-b3b1-70e74979e53b.png#averageHue=%23e8f4c4&clientId=ue4f918ef-5f35-4&from=paste&height=363&id=u5284df3e&originHeight=545&originWidth=1008&originalType=binary&ratio=1&rotation=0&showTitle=false&size=92099&status=done&style=none&taskId=u9f34e6cd-af96-4e8b-ae6c-d58a110eaa3&title=&width=672" alt="image.png">·</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认调用非公平锁的tryAcquireShared</span></span><br><span class="line"> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nonfairTryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假设其中 Thread-1，Thread-2，Thread-4 cas 竞争成功，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列<br />park 阻塞。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653361205613-ece7be8f-3126-4654-96c9-dbbdf668e3a0.png#averageHue=%23f6f6f1&clientId=ue4f918ef-5f35-4&from=paste&height=185&id=u075478f9&originHeight=278&originWidth=1029&originalType=binary&ratio=1&rotation=0&showTitle=false&size=61288&status=done&style=none&taskId=ub0ce0286-a065-49c6-8d79-4e88abd1492&title=&width=686" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这时 Thread-4 释放了 permits，状态如下  (release方法)<br /> <img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653370720394-3433233e-cb48-45ec-9cbf-6895fa5f5a10.png#averageHue=%23f7f6f2&clientId=ue4f918ef-5f35-4&from=paste&height=192&id=u8359cd6f&originHeight=288&originWidth=1053&originalType=binary&ratio=1&rotation=0&showTitle=false&size=55152&status=done&style=none&taskId=u9ba2e77d-7891-4294-9177-bb94b97ced9&title=&width=702" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">     sync.releaseShared(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">         doReleaseShared();</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//唤醒队列中的节点</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">         <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">             <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">             <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                     <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                 unparkSuccessor(h);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                      !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                 <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p> 接下来 Thread-0 竞争成功 (doAcquireSharedInterruptibly方法 for循环执行)，permits 再次设置为 0，设置自己为 head 节点，断开原来的 head 节点，unpark 接 下来的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态  <br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653370835850-cc209624-b529-4384-8d90-d2bafa62835d.png#averageHue=%23e6f2c1&clientId=ue4f918ef-5f35-4&from=paste&height=229&id=u8751c0a8&originHeight=343&originWidth=1034&originalType=binary&ratio=1&rotation=0&showTitle=false&size=63556&status=done&style=none&taskId=u4842649d-b5fd-4b68-93ce-02d4f267c4a&title=&width=689.3333333333334" alt="image.png"></p>
<p><a name="Ei1vB"></a></p>
<h2 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h2><p> 用来进行线程同步协作，等待所有线程完成倒计时。 其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">     <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">         log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">         sleep(<span class="number">1</span>);</span><br><span class="line">         latch.countDown();</span><br><span class="line">     log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">     &#125;).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">         log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">         sleep(<span class="number">2</span>);</span><br><span class="line">         latch.countDown();</span><br><span class="line">         log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">     &#125;).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">         log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">         sleep(<span class="number">1.5</span>);</span><br><span class="line">         latch.countDown();</span><br><span class="line">         log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">     &#125;).start();</span><br><span class="line">     log.debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">     latch.await();</span><br><span class="line">     log.debug(<span class="string">&quot;wait end...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name="BMmck"></a></p>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>CountdownLatch内部同样维护一个aqs同步器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将aqs内部成员变量设置为指定值</span></span><br><span class="line"><span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);   </span><br><span class="line"></span><br><span class="line"><span class="comment">//每次countDown都会-1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            <span class="comment">//唤醒主线程await方法</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//倒计时未结束也就是state还未=0时 执行这个方法 进入阻塞队列 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="OhyJh"></a></p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程执<br />行到某个需要“同步”的时刻调用 await() 方法进行等待，<strong>当等待的线程数满足『计数个数』时</strong>，继续执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">cb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>，()-&gt;&#123; <span class="comment">//当await的线程全部运行完后，就会执行后面的方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;线程1 线程2 finish....&quot;</span>);</span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;线程1开始..&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         cb.await(); <span class="comment">// 当个数不足时，等待</span></span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(<span class="string">&quot;线程1继续向下运行...&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;线程2开始..&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">     <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">2000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         cb.await(); <span class="comment">// 2 秒后，await线程个数够2，继续运行</span></span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(<span class="string">&quot;线程2继续向下运行...&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//CyclicBarrier可以重复使用 当await调用两次 计数  变成0后，又可以再次await 再恢复成2</span></span><br></pre></td></tr></table></figure>
<p><a name="pu5xT"></a></p>
<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p><a name="sNDOU"></a></p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync(Runnable runnable);</span><br><span class="line">CompletableFuture.runAsync(Runnable runnable, Executor executor);</span><br><span class="line"></span><br><span class="line">CompletableFuture.supplyAsync(Supplier supplier);</span><br><span class="line">CompletableFuture.supplyAsync(Supplier supplier, Executor executor)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过上面几个方法可以创建一个CompletableFuture</span></span><br><span class="line">  CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; start,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">&quot; exit,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).whenComplete((res, e) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;future01回调方法执行 ==》&quot;</span> + res + <span class="string">&quot;，线程id：&quot;</span> + Thread.currentThread().getId()+<span class="string">&quot;--&quot;</span>+e);</span><br><span class="line">        &#125;);    </span><br><span class="line">        System.out.println(<span class="string">&quot;run result-&gt;&quot;</span>+cf.get());<span class="comment">//阻塞</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main thread exit,time-&gt;&quot;</span>+System.currentTimeMillis());</span><br><span class="line"><span class="comment">//runAsync 方法接收的是 Runnable 的实例，意味着它没有返回值</span></span><br><span class="line"><span class="comment">//supplyAsync 方法对应的是有返回值的情况  不是callable 是一个供给型接口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">https:<span class="comment">//www.cnblogs.com/dtdx/p/14238516.html</span></span><br></pre></td></tr></table></figure>
<p><br />    <br><a name="yOxsG"></a></p>
<h4 id="回调-whenComplete、whenCompleteAsync"><a href="#回调-whenComplete、whenCompleteAsync" class="headerlink" title="回调 whenComplete、whenCompleteAsync"></a>回调 whenComplete、whenCompleteAsync</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//当CompletableFuture的计算结果完成，或者抛出异常的时候，可以执行特定的Action。主要是下面的方法：</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> Throwable&gt; action)</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> Throwable&gt; action)</span></span><br><span class="line"><span class="comment">//whenComplete：是执行当前任务的线程执行继续执行 whenComplete 的任务。</span></span><br><span class="line"><span class="comment">//whenCompleteAsync：是执行把 whenCompleteAsync 这个任务继续提交给线程池来进行执行。</span></span><br></pre></td></tr></table></figure>


<p><a name="nqKBp"></a></p>
<h4 id="继续执行-thenApply-thenAccept-thenRun"><a href="#继续执行-thenApply-thenAccept-thenRun" class="headerlink" title="继续执行 thenApply thenAccept thenRun"></a>继续执行 thenApply thenAccept thenRun</h4><p>thenApply 方法：当一个线程依赖另一个线程时，获取上一个任务返回的结果，并返回当前任务的返回值。</p>
<p>thenAccept方法：消费处理结果。接收任务的处理结果，并消费处理，无返回结果。</p>
<p>thenRun方法：只要上面的任务执行完成，就开始执行thenRun，只是处理完任务后，执行 thenRun的后续操作  <br />带有Async默认是异步执行的。这里所谓的异步指的是不在当前线程内执行。  thenRunAsync</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; future01 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;future01执行，线程id：&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;).thenRun(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;thenRun执行，无法获取上一步执行结果，无返回值&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(future01.get());</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; future02 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;future01执行，线程id：&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;).thenAccept((res) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;thenAccept，上一步执行结果: &quot;</span> + res +<span class="string">&quot;，无返回值&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(future02.get());</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Long&gt; future03 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;future03执行，线程id：&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;).thenApply((res) -&gt; &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;thenApply，上一步执行结果: &quot;</span> + res + <span class="string">&quot;，有返回值: &quot;</span> + i);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;); </span><br></pre></td></tr></table></figure>
<p><br />    <br><a name="hSKQJ"></a></p>
<h4 id="组合-两个都处理完成-thenCombine-thenAcceptBoth-runAfterBoth"><a href="#组合-两个都处理完成-thenCombine-thenAcceptBoth-runAfterBoth" class="headerlink" title="组合 两个都处理完成 thenCombine thenAcceptBoth runAfterBoth"></a>组合 两个都处理完成 thenCombine thenAcceptBoth runAfterBoth</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">thenCombine：组合两个future，获取两个future任务的返回结果，并返回当前任务的返回值</span><br><span class="line"></span><br><span class="line">thenAcceptBoth：组合两个future，获取两个future任务的返回结果，然后处理任务，没有返回值。</span><br><span class="line"></span><br><span class="line">runAfterBoth：组合两个future，不需要获取future的结果，只需两个future处理完任务后，处理该任务</span><br><span class="line">    CompletableFuture&lt;Void&gt; future03 = future01.runAfterBoth(future02, () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务3开始。。。&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; future04 = future01.thenAcceptBoth(future02, (f1, f2) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务4开始。。。之前的结果 &quot;</span>+f1+<span class="string">&quot;==&gt;&quot;</span>+f2);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Long&gt; future05 = future01.thenCombine(future02, (f1, f2) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务5开始。。。之前的结果 &quot;</span>+f1+<span class="string">&quot;==&gt;&quot;</span>+f2);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p><a name="FIQBW"></a></p>
<h4 id="组合-只需一个处理完成"><a href="#组合-只需一个处理完成" class="headerlink" title="组合 只需一个处理完成"></a>组合 只需一个处理完成</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">applyToEither：组合两个future，只需一个future任务的返回结果，并返回当前任务的返回值</span><br><span class="line"></span><br><span class="line">acceptEither：组合两个future，只需一个future任务的返回结果，然后处理任务，没有返回值。</span><br><span class="line"></span><br><span class="line">runAfterEither：组合两个future，不需要获取future的结果，只需一个future处理完任务后，处理该任务</span><br><span class="line">    </span><br><span class="line">CompletableFuture&lt;Void&gt; future03 = future01.runAfterEither(future02, () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务3开始。。。&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; future04 = future01.acceptEither(future02, (res) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务4开始。。。之前的结果 &quot;</span>+res);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Long&gt; future05 = future01.applyToEither(future02, (res) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务5开始。。。之前的结果 &quot;</span>+res);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p><a name="gVS3p"></a></p>
<h4 id="多任务-allOf-anyOf"><a href="#多任务-allOf-anyOf" class="headerlink" title="多任务 allOf anyOf"></a>多任务 allOf anyOf</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">allOf：等待所有任务完成 才会执行future03</span><br><span class="line"></span><br><span class="line">anyOf：只要有一个任务完成，都会执行future03</span><br><span class="line">    </span><br><span class="line">    CompletableFuture&lt;Void&gt; future03 = CompletableFuture.allOf(future01, future02);</span><br><span class="line">    CompletableFuture&lt;Object&gt; future04 = CompletableFuture.anyOf(future01, future02);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;anyOf 任意一个异步任务执行完成&quot;</span>+future04.get());</span><br><span class="line">    System.out.println(<span class="string">&quot;allOf 等待所有异步任务执行完成&quot;</span>+future03.get());</span><br></pre></td></tr></table></figure>


<p><a name="FTzgT"></a></p>
<h4 id="thenCompose-嵌套future"><a href="#thenCompose-嵌套future" class="headerlink" title="thenCompose 嵌套future"></a>thenCompose 嵌套future</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;CompletableFuture&lt;Double&gt;&gt; result = getUserDetail(userId)</span><br><span class="line">.thenApply(user -&gt; getCreditRating(user));  <span class="comment">// getCreditRating也是一个CompletableFuture 返回了一个嵌套的CompletableFuture </span></span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Double&gt; result = getUserDetail(userId)<span class="comment">//正确写法</span></span><br><span class="line">.thenCompose(user -&gt; getCreditRating(user));</span><br><span class="line">因此，规则就是-如果你的回调函数返回一个CompletableFuture，但是你想从CompletableFuture链中获取一个直接合并后的结果，这时候你可以使用thenCompose()。</span><br></pre></td></tr></table></figure>
<p><a name="APk33"></a></p>
<h4 id="异常处理-exceptionally-handle"><a href="#异常处理-exceptionally-handle" class="headerlink" title="异常处理 exceptionally handle"></a>异常处理 exceptionally handle</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">exceptionally()回调给你一个从原始Future中生成的错误恢复的机会。你可以在这里记录这个异常并返回一个默认值。</span><br><span class="line">CompletableFuture&lt;String&gt; maturityFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span>(age &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Age can not be negative&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(age &gt; <span class="number">18</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Adult&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Child&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).exceptionally(ex -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Oops! We have an exception - &quot;</span> + ex.getMessage());</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Unknown!&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">handle()从异常恢复，无论一个异常是否发生它都会被调用。</span><br><span class="line"><span class="type">Integer</span> <span class="variable">age</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;String&gt; maturityFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(age &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Age can not be negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(age &gt; <span class="number">18</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Adult&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Child&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).handle((res, ex) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(ex != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Oops! We have an exception - &quot;</span> + ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Unknown!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><a name="WiSUM"></a></p>
<h2 id="线程安全的集合类"><a href="#线程安全的集合类" class="headerlink" title="线程安全的集合类"></a><br />线程安全的集合类</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653467080405-e6911d43-68af-4f50-8858-fa086f83cdde.png#averageHue=%23c3a585&clientId=ub3e8bb93-efe7-4&from=paste&height=167&id=u3f777897&originHeight=251&originWidth=1484&originalType=binary&ratio=1&rotation=0&showTitle=false&size=68586&status=done&style=none&taskId=u29b813b4-e044-405f-904a-6dac33b62c1&title=&width=989.3333333333334" alt="image.png"><br /><strong>遗留的安全集合</strong> 方法都是由synchronized修饰的，效率不高，不推荐使用。</p>
<p><strong>修饰的安全集合</strong>,就是将原本不安全的集合类，传进去。通过装饰者模式，给每个线程不安全的集合类的方法，外层套一个synchronized。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1653467335343-ed581bee-e318-4237-ae65-b6ae81b0c0ef.png#averageHue=%23f7f5ec&clientId=ub3e8bb93-efe7-4&from=paste&height=428&id=u272f51d1&originHeight=642&originWidth=932&originalType=binary&ratio=1&rotation=0&showTitle=false&size=322427&status=done&style=none&taskId=u70c1f023-23a4-4574-b1be-e72e6b7256c&title=&width=621.3333333333334" alt="image.png"></p>
<p><strong>JUC安全集合</strong><br><a name="Cg5Kp"></a></p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p><a name="oGkkv"></a></p>
<h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认为 0</span></span><br><span class="line"><span class="comment">// 当初始化时, 为 -1</span></span><br><span class="line"><span class="comment">// 当扩容时, 为 -(1 + 扩容线程数)</span></span><br><span class="line"><span class="comment">// 当初始化或扩容完成后，为 下一次的扩容的阈值大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整个 ConcurrentHashMap 就是一个 Node[]</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash 表</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容时的 新 hash 表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ReservationNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为 treebin 的头节点, 存储 root 和 first</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeBin</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为 treebin 的节点, 存储 parent, left, right</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Node[] 中第 i 个 Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="title function_">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// cas 修改 Node[] 中第 i 个 Node 的值, c 为旧值, v 为新值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 直接修改 Node[] 中第 i 个 Node 的值, v 为新值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title function_">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i, Node&lt;K,V&gt; v)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">     <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel) <span class="comment">// Use at least as many bins</span></span><br><span class="line">         initialCapacity = concurrencyLevel; <span class="comment">// as estimated threads</span></span><br><span class="line">     <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + (<span class="type">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// tableSizeFor 仍然是保证计算出最终size的大小是 2^n, 即 16,32,64 ... 用于后面的hash计算</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= (<span class="type">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">     MAXIMUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);</span><br><span class="line">     <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">        <span class="comment">// spread 方法能确保返回结果是正数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">        <span class="comment">//table就是hash表</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            <span class="comment">//根据key的hashcode和tab长度取模 找到对应的头节点 赋给e</span></span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果头结点已经是要查找的 key (hashcode相同)</span></span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">                <span class="comment">//头结点的key等于当前的key </span></span><br><span class="line">                <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果找到的头节点e的hash值小于0代表该bin正在扩容(头节点是forwardingNode)</span></span><br><span class="line">            <span class="comment">//或者是treebin() 调用对应的find方法来查找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//正常遍历链表</span></span><br><span class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//onlyIfAbsent 是否不覆盖旧值 false表示覆盖新值</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">//不允许null的可以,hashmap就允许</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">//保证正整数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">// f是链表头节点</span></span><br><span class="line">        <span class="comment">// fh是链表头结点的 hash</span></span><br><span class="line">        <span class="comment">// i是链表在 table 中的下标</span></span><br><span class="line">        <span class="comment">// n是table的长度</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//初始化table  使用了cas </span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//找到key的hashcode对应下标处的头节点 如果不存在则创建一个</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//cas创建 如果其他线程占用了,cas失败了 就继续循环</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//帮忙扩容  (头结点的hash值表示正在扩容)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//帮忙之后 进入下一次循环</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="comment">//进入这个else表示不在扩容，不在初始化，发生了hash冲突</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//此时加锁了 锁住了这个桶的头节点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//确认链表的头节点没有被移动</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//找到了相同的key值</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="comment">//覆盖掉旧值</span></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">//没有找到key 新增追加到链表尾</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//红黑树 (TreeBin 红黑树的头节点)</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// putTreeVal 会看 key 是否已经在树中, 是, 则返回对应的 TreeNode</span></span><br><span class="line">                        <span class="comment">//然后更新操作,否 做新增操作</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//代表有hash冲突</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果链表长度&gt;=树化阙值(8) 就会将链表转为红黑树</span></span><br><span class="line">                <span class="comment">//(先扩容 到64 如果还是大于8 就会转换)</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加 size 计数</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">       <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">               Thread.<span class="keyword">yield</span>(); </span><br><span class="line">           <span class="comment">//尝试将sizeCtl设置为-1 表示初始化table</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">               <span class="comment">//创建table,其他线程会在while()循环中yield 直至table创建</span></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                       <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                       Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                       table = tab = nt;</span><br><span class="line">                       sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   sizeCtl = sc;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> tab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>




<p><a name="WZSd3"></a></p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p><a name="qhXl3"></a></p>
<h2 id="控制线程的执行顺序"><a href="#控制线程的执行顺序" class="headerlink" title="控制线程的执行顺序"></a>控制线程的执行顺序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">t2runned</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!t2runned) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,name: <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Lock) &#123;</span><br><span class="line">        Log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        t2runned = <span class="literal">true</span>;</span><br><span class="line">        lock.notify();</span><br><span class="line">    &#125;,name: <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        </span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//park unpark</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    Log.debug(<span class="string">&quot;1&quot;</span><span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;,name: &quot;</span>t1<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">t1.start();</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">new Thread(() -&gt;&#123;</span></span><br><span class="line"><span class="string">    log.debug(&quot;</span><span class="number">2</span><span class="string">&quot;);</span></span><br><span class="line"><span class="string">    LockSupport.unpark(t1);</span></span><br><span class="line"><span class="string">&#125;, name: &quot;</span>t2<span class="string">&quot; ).start();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p><a name="ub2J4"></a></p>
<h2 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">waitNotify</span> &#123;</span><br><span class="line">    <span class="comment">//等待标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> flag;</span><br><span class="line">    <span class="comment">//循环次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopNumber;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">waitNotify</span><span class="params">(<span class="type">int</span> flag, <span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">        <span class="built_in">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, <span class="type">int</span> waitFlag， <span class="type">int</span> nextFlag)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(flag != waitFlag) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printstackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.print(str);</span><br><span class="line">                    </span><br><span class="line">                    flag = nextFlag;</span><br><span class="line">                    <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span> &#123;</span><br><span class="line">    <span class="type">waitNotify</span> <span class="variable">wn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">waitNotify</span>(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">        wn.print(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">        wn.print(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">        wn.print(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Awaitsignal</span> <span class="variable">awaitsignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Awaitsignal</span>(loopNumber:<span class="number">5</span>);</span><br><span class="line">    <span class="type">condition</span> <span class="variable">a</span> <span class="operator">=</span> awaitsignal.newCondition();</span><br><span class="line">    <span class="type">condition</span> <span class="variable">b</span> <span class="operator">=</span> awaitsignal.newCondition();</span><br><span class="line">    <span class="type">condition</span> <span class="variable">c</span> <span class="operator">=</span> awaitsignal.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        awaitSignal.print(<span class="string">&quot;a&quot;</span>,a,b);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        awaitSignal.print(<span class="string">&quot;b&quot;</span>,b,c);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        awaitSignal.print(<span class="string">&quot;c&quot;</span>,c,a);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    </span><br><span class="line">    a.signal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Awaitsignal</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopNumber;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Awaitsignal</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//参数1打印内容.参数2进入哪一件休息室 参数3 下一间休息室</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str，Condition current，Condition next)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">             lock();</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 current.await();</span><br><span class="line">                 System.out.print(str);</span><br><span class="line">                 next.signal():</span><br><span class="line">             &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                 unlock();</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name="Jf0oT"></a></p>
<h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p>简单的说，JMM定义了一套在多线程读写共享数据时（成员变量、数组)时，对数据的可见性、有序性、和原子性的规则和保障。</p>
<p><a name="UKALM"></a></p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>通过synchronized保证原子性。</p>
<p><a name="yen15"></a></p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651906901594-fe06ad0b-08ab-467c-a883-4be2822f2788.png#averageHue=%23eae6a4&clientId=u4d909540-ad5c-4&from=paste&height=410&id=u1679bc2d&originHeight=677&originWidth=1397&originalType=binary&ratio=1&rotation=0&showTitle=false&size=222435&status=done&style=none&taskId=uf9d61d4a-6952-4358-91fa-bfa20269023&title=&width=846.666617730654" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651906913481-167d670a-d4bf-4bed-8ac1-2c8561745dec.png#averageHue=%23f5f4e8&clientId=u4d909540-ad5c-4&from=paste&height=466&id=u754490d1&originHeight=769&originWidth=1736&originalType=binary&ratio=1&rotation=0&showTitle=false&size=380733&status=done&style=none&taskId=uc03cbcbe-f8e3-41a7-a3db-247bcc83fb5&title=&width=1052.1211513102473" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651906923102-88ac5a15-8425-4c74-a483-43acc2c60dbf.png#averageHue=%23f4f3e8&clientId=u4d909540-ad5c-4&from=paste&height=459&id=u83e8a6cd&originHeight=757&originWidth=1758&originalType=binary&ratio=1&rotation=0&showTitle=false&size=376718&status=done&style=none&taskId=u08430a0b-b635-43a0-a4aa-c2b5b6b537a&title=&width=1065.4544838729348" alt="image.png"><br />可以通过volatile关键字来解决这个问题<br><a name="lkN90"></a></p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条<strong>Lock前缀</strong>的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p>
<p>volatile的两条实现原则:<br /><strong>Lock前缀指令会引起处理器缓存回写到内存</strong><br /><strong>一个处理器的缓存回写到内存会导致其他处理器的缓存无效</strong></p>
<p><strong>volatile只能保证可见性，并不能保证原子性。</strong><br />synchronized两者都能保证，但是是重量级操作，性能相对较低。</p>
<p><strong>volatile也能禁止指令重排</strong></p>
<p><a name="WOLDL"></a></p>
<h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p><strong>内存屏障:</strong></p>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>在每个volatile写操作的后面插人一个StoreLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652350701634-70c3f373-1d0f-4b99-806c-19e9208836b5.png#averageHue=%23faf9f9&clientId=uda4812d7-352a-4&from=paste&height=366&id=u99e7679e&originHeight=549&originWidth=793&originalType=binary&ratio=1&rotation=0&showTitle=false&size=109204&status=done&style=none&taskId=u83c604dd-d5f7-4a92-930d-bd3d51b36f7&title=&width=528.6666666666666" alt="image.png"><br />StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作已经对任意处理器可见了。<br />这是因为StoreStore屏障将保障上面<strong>所有的普通写在volatile写之前刷新到主内存</strong></p>
<p>volatile写后面的StoreLoad屏障。此屏障的作用是避免<strong>volatile写与后面可能有的volatile读&#x2F;写操作重排序</strong>  </p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652350815190-de203eb1-6288-4674-abbe-d9786ab868dd.png#averageHue=%23f9f9f9&clientId=uda4812d7-352a-4&from=paste&height=310&id=u1243807d&originHeight=465&originWidth=803&originalType=binary&ratio=1&rotation=0&showTitle=true&size=104697&status=done&style=none&taskId=ueeb850b5-500d-4f33-9c9a-b05a75110e1&title=%E8%AF%BB&width=535.3333333333334" alt="读" title="读"><br /> LoadLoad屏障用来禁止处理器把上面的volatile读与下面的<strong>普通读</strong>重排序  <br /> LoadStore屏障用来禁止处理器把上面的volatile读与下面的<strong>普通写</strong>重排序。<br><a name="uo8po"></a></p>
<h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><p>对与单例模式 懒汉法实现，双重check方法，在多线程环境下可能会因为指令重排出现问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">singleton</span><span class="params">( )</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    Wpublic staticjsingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//实例没创建，才会进入内部的synchronized代码块</span></span><br><span class="line">    <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">        <span class="comment">//也许有其它线程已经创建实例，所以再判断一次</span></span><br><span class="line">            <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>( );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>INSTANCE &#x3D; new Singleton()对应的字节码为:<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651908545922-7404c5d2-1082-4ef3-b40d-3277c8ca2000.png#averageHue=%23fbfbfa&clientId=u4d909540-ad5c-4&from=paste&height=168&id=u0f2b15c0&originHeight=278&originWidth=1700&originalType=binary&ratio=1&rotation=0&showTitle=false&size=141189&status=done&style=none&taskId=u195b006a-1b89-4f0e-ab36-6b820849eac&title=&width=1030.3029707531223" alt="image.png"><br />其中47两步的顺序不是固定的，也许jvm 会优化为:先将引用地址赋值给INSTANCE变量后，再执行构造方法(因为对结果不会造成影响)，如果两个线程t1，t2按如下时间序列执行:</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651908596904-265538e6-b281-4725-b5ba-3a0668b8dd7c.png#averageHue=%23e3e0d8&clientId=u4d909540-ad5c-4&from=paste&height=204&id=u5a684652&originHeight=336&originWidth=1663&originalType=binary&ratio=1&rotation=0&showTitle=false&size=327332&status=done&style=none&taskId=u122e144d-a27c-43e2-ab2e-5ea8eff354a&title=&width=1007.8787296249661" alt="image.png"><br /><strong>这时t1还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么t2拿到的是将是一个未初始化完毕的单例。</strong></p>
<p><strong>对INSTANCE使用volatile修饰即可，可以禁用指令重排，但要注意在JDK 5以上的版本的volatile才会真正有效</strong></p>
<p><a name="X3uJ9"></a></p>
<h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>happens-before规定了哪些写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结:</p>
<p><strong>线程对volatile变量的写，对接下来其它线程对该变量的读可见</strong></p>
<p><strong>线程解锁m之前对变量的写，对于接下来对m加锁的其它线程对该变量的读可见</strong><br /><code>也就是说线程1锁住M对象，然后对一个变量A做了修改，另一个需要锁M对象的锁在获取到锁之后,对于变量A的修改是可见的</code></p>
<p><strong>线程start前对变量的写，对该线程开始后对该变量的读可见</strong></p>
<p><strong>线程结束前对变量的写，对其它线程得知它结束后的读可见(比如其它线程调用t1.isAlive()或t1.join()等待它结束)</strong></p>
<p><strong>线程t1打断t2( interrupt)前对变量A的写，对于其他线程得知t2被打断后对变量A的读可见（通过t2.interrupted或 t2.isInterrupted)</strong></p>
<p><strong>对变量默认值(0, false,null)的写，对其它线程对该变量的读可见</strong></p>
<p><a name="u8zRV"></a></p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS即Compare and Swap，它体现的一种乐观锁的思想，比如多个线程要对一个共享的整型变量执行+1操作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要不断尝试</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span>旧值=共享变量;<span class="comment">//比如拿到了当前值0</span></span><br><span class="line">    <span class="type">int</span>结果=旧值+<span class="number">1</span>;<span class="comment">//在旧值О的基础上增加1，正确结果是1</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这时候如果别的线程把共享变量改成了5，本线程的正确结果1就作废了，这时候compareAndSwap返回	false，重新尝试，直到:compareAndSwap返回true，表示我本线程做修改的同时，别的线程没有干扰</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//旧值会先和共享变量比较  相同时才会返回true，然后将结果更新到共享变量上。</span></span><br><span class="line">    <span class="keyword">if</span>(compareAndSwap (旧值，结果))&#123;</span><br><span class="line">        <span class="comment">//成功，退出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>获取共享变量时，为了保证该变量的可见性，需要使用volatile修饰</strong>。结合CAS和volatile可以实现无锁并发，适用于竞争不激烈、多核CPU的场景下。|<br />因为没有使用synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一<br />但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</p>
<p>juc (java.util.concurrent）中提供了原子操作类，可以提供线程安全的操作，例如: AtomicInteger、AtomicBoolean等，它们底层就是采用<strong>CAS技术+volatile</strong>来实现的。</p>
<p><a name="aIJC2"></a></p>
<h3 id="LongAdder-原子累加器"><a href="#LongAdder-原子累加器" class="headerlink" title="LongAdder 原子累加器"></a>LongAdder 原子累加器</h3><p>LongAdder累计相比于AtomicInteger效率提升很大。</p>
<p>性能提升的原因很简单，就是在有竞争时，设置多个累加单元，Therad-0累加Cel[0]，而Thread-l 累加Cell[1]..最后将结果汇总。这样它们在累加时操作的不同的Cell变量，因此减少了CAS重试失败，从而提高性能。</p>
<p><strong>原理</strong><br />LongAdder类有几个关键域</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//累加单元数组，懒惰初始化</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> cell[] cells;</span><br><span class="line"><span class="comment">//基础值，如果没有竞争，则用cas累加这个域</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> base;</span><br><span class="line"><span class="comment">//在 cells 创建或扩容时，置为1，表示加锁 (cas锁)</span></span><br><span class="line"><span class="keyword">transient</span> volatileiit cellsBusy;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要用于实践！！！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockCas</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (state.compareAndSet(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">         log.debug(<span class="string">&quot;unlock...&quot;</span>);</span><br><span class="line">         state.set(<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>原理之伪共享</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防止缓存行伪共享</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line"> <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line"> Cell(<span class="type">long</span> x) &#123; value = x; &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 最重要的方法, 用来 cas 方式进行累加, prev 表示旧值, next 表示新值</span></span><br><span class="line"> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">cas</span><span class="params">(<span class="type">long</span> prev, <span class="type">long</span> next)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="built_in">this</span>, valueOffset, prev, next);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 省略不重要代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>缓存和内存的速度对比<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652628866291-5d1105e3-d155-4e54-86a7-70fe2b61455a.png#averageHue=%23f9f8f8&clientId=ua41d68fc-b28c-4&from=paste&height=664&id=ueea74552&originHeight=996&originWidth=1017&originalType=binary&ratio=1&rotation=0&showTitle=false&size=155123&status=done&style=none&taskId=uc43a428c-6b87-4c22-b74a-24668a6ce2d&title=&width=678" alt="image.png"><br />因为 CPU 与 内存的速度差异很大，需要靠预读数据至缓存来提升效率。 而缓存以缓存行为单位，每个缓存行对应着一块内存，一般是 64 byte（8 个 long） <br />缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中 <br />CPU 要保证数据的一致性，如果某个 CPU 核心更改了数据，其它 CPU 核心对应的整个缓存行必须失效</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652629186783-edc71493-757b-422b-ac3d-772a379cd05e.png#averageHue=%23dee8b4&clientId=ua41d68fc-b28c-4&from=paste&height=423&id=ud6be82f9&originHeight=634&originWidth=1549&originalType=binary&ratio=1&rotation=0&showTitle=false&size=152223&status=done&style=none&taskId=u3ba51c2d-7758-4b06-a692-e5d11abce4d&title=&width=1032.6666666666667" alt="image.png"><br />因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因<br />此缓存行可以存下 2 个的 Cell 对象。这样问题来了：<br />Core-0 要修改 Cell[0]<br />Core-1 要修改 Cell[1]<br />无论谁修改成功，都会导致对方 Core 的缓存行失效，比如 Core-0 中 Cell[0]&#x3D;6000, Cell[1]&#x3D;8000 要累加<br />Cell[0]&#x3D;6001, Cell[1]&#x3D;8000 ，这时会让 Core-1 的缓存行失效  这样就会影响效率。</p>
<p>@sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的前后各增加 128 字节大小的<br />padding，从而让 CPU 将对象预读至缓存时占用不同的缓存行，这样，<strong>不会造成对方缓存行的失效</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">     <span class="comment">// as 为累加单元数组</span></span><br><span class="line">     <span class="comment">// b 为基础值</span></span><br><span class="line">     <span class="comment">// x 为累加值</span></span><br><span class="line">     Cell[] as; <span class="type">long</span> b, v; <span class="type">int</span> m; Cell a;</span><br><span class="line">     <span class="comment">// 进入 if 的两个条件</span></span><br><span class="line">     <span class="comment">// 1. as 有值, 表示已经发生过竞争, 进入 第二个if</span></span><br><span class="line">     <span class="comment">// 2. cas 给 base 累加时失败了, 表示 base 发生了竞争, 进入 if</span></span><br><span class="line">     <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">         <span class="comment">// uncontended 表示 cell 没有竞争</span></span><br><span class="line">         <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">         <span class="keyword">if</span> (</span><br><span class="line">             <span class="comment">// as 还没有创建</span></span><br><span class="line">             as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">             <span class="comment">// 当前线程对应的 cell 还没有创建</span></span><br><span class="line">             (a = as[getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">             <span class="comment">// cas 给当前线程的 cell 累加失败 uncontended=false ( a 为当前线程的 cell )</span></span><br><span class="line">             !(uncontended = a.cas(v = a.value, v + x))</span><br><span class="line">             ) &#123;</span><br><span class="line">             <span class="comment">// 进入 cell 数组创建、cell 创建的流程</span></span><br><span class="line">             longAccumulate(x, <span class="literal">null</span>, uncontended);</span><br><span class="line">         &#125;	</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652629906336-b932fde5-f2e8-46fc-9955-88d3d5d84515.png#averageHue=%23fcfcdd&clientId=ua41d68fc-b28c-4&from=paste&height=298&id=uc9ed4230&originHeight=447&originWidth=1451&originalType=binary&ratio=1&rotation=0&showTitle=false&size=107835&status=done&style=none&taskId=u8145646b-0368-4657-89cc-d54cf5d6d95&title=&width=967.3333333333334" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">longAccumulate</span><span class="params">(<span class="type">long</span> x, LongBinaryOperator fn,</span></span><br><span class="line"><span class="params">                             <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line">     <span class="type">int</span> h;</span><br><span class="line">     <span class="comment">// 当前线程还没有对应的 cell, 需要随机生成一个 h 值用来将当前线程绑定到 cell</span></span><br><span class="line">     <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 初始化 probe</span></span><br><span class="line">         ThreadLocalRandom.current();</span><br><span class="line">         <span class="comment">// h 对应新的 probe 值, 用来对应 cell</span></span><br><span class="line">         h = getProbe();</span><br><span class="line">         wasUncontended = <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// collide 为 true 表示需要扩容</span></span><br><span class="line">     <span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         Cell[] as; Cell a; <span class="type">int</span> n; <span class="type">long</span> v;</span><br><span class="line">         <span class="comment">// 已经有了 cells</span></span><br><span class="line">         <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line">                 <span class="comment">// 为 cellsBusy 加锁, 创建 cell, cell 的初始累加值为 x</span></span><br><span class="line">                 <span class="comment">// 成功则 break, 否则继续 continue 循环</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 有竞争, 改变线程对应的 cell 来重试 cas</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)</span><br><span class="line">                 wasUncontended = <span class="literal">true</span>;</span><br><span class="line">             <span class="comment">// cas 尝试累加, fn 配合 LongAccumulator 不为 null, 配合 LongAdder 为 null</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="comment">//如果 cells 长度已经超过了最大长度(CPU核心数), 或者已经扩容, </span></span><br><span class="line">             <span class="comment">//改变线程对应的 cell 来重试 cas</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                 collide = <span class="literal">false</span>;</span><br><span class="line">             <span class="comment">// 确保 collide 为 false 进入此分支, 就不会进入下面的 else if 进行扩容了</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                 collide = <span class="literal">true</span>;</span><br><span class="line">             <span class="comment">// 加锁</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">             <span class="comment">// 加锁成功, 扩容</span></span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 改变线程对应的 cell</span></span><br><span class="line">             h = advanceProbe(h);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 还没有 cells, 尝试给 cellsBusy 加锁</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">             <span class="comment">// 加锁成功, 初始化 cells, 最开始长度为 2, 并填充一个 cell</span></span><br><span class="line">             <span class="comment">// 成功则 break;</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 上两种情况失败, 尝试给 base 累加 如果再失败 就无法执行break 再次循环</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652630480269-24cb7e01-5889-4b6c-a3d1-b4dbd53e15dd.png#averageHue=%23fcfcdd&clientId=ua41d68fc-b28c-4&from=paste&height=217&id=ueaf7f225&originHeight=325&originWidth=1426&originalType=binary&ratio=1&rotation=0&showTitle=false&size=68742&status=done&style=none&taskId=u85ad2aad-94af-4900-8de0-d3c3e5a36d0&title=&width=950.6666666666666" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652631025218-43cbe378-6e9e-47bc-adcd-0809415519bf.png#averageHue=%23fcfcdd&clientId=ua41d68fc-b28c-4&from=paste&height=251&id=u4f25057f&originHeight=377&originWidth=1390&originalType=binary&ratio=1&rotation=0&showTitle=false&size=58980&status=done&style=none&taskId=u3b8d29d8-cd70-4e62-8910-6af21652a62&title=&width=926.6666666666666" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652631102454-34f02836-d3a5-4087-a26c-46aa8575fb1d.png#averageHue=%23fcfcdd&clientId=ua41d68fc-b28c-4&from=paste&height=325&id=uf13ac630&originHeight=488&originWidth=1407&originalType=binary&ratio=1&rotation=0&showTitle=false&size=103587&status=done&style=none&taskId=uea924691-3850-4654-b6bf-73cb07f4cf0&title=&width=938" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">     Cell[] as = cells; Cell a;</span><br><span class="line">     <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> base;</span><br><span class="line">     <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">             <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">             sum += a.value;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a name="mDuvU"></a></p>
<h2 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h2><p>Java HotSpot虚拟机中，每个对象都有对象头（包括class指针和Mark Word) 。Mark Word平时存储这个对象的哈希码、分代年龄，当加锁时，这些信息就根据情况被替换为标记位、线程锁记录指针、重量级锁指针、线程ID等内容。<br><a name="MnfKi"></a></p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652187200050-747a4d9a-3ac8-4fe4-980b-d9df09fa674e.png#averageHue=%23e4e5a1&clientId=ub2cb5786-dc2a-4&from=paste&height=303&id=u4a1fc741&originHeight=454&originWidth=870&originalType=binary&ratio=1&rotation=0&showTitle=false&size=210819&status=done&style=none&taskId=ud9561da1-d0e7-4e9b-89e2-baf4fe5e81a&title=&width=580" alt="image.png"><br />让锁记录中Object reference指向锁对象，并尝试用cas替换Object的Mark Word，<br />也会将Mark Word的值存入锁记录（lock record）。 <code>lock record 后面的 00 表示轻量级锁 01表示正常状态 前面30位表示锁记录地址</code></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652187357049-ba4c587d-f239-4ffe-a6e3-1de32cced6ae.png#averageHue=%23dcdc9b&clientId=ub2cb5786-dc2a-4&from=paste&height=313&id=ubd9a72d4&originHeight=469&originWidth=946&originalType=binary&ratio=1&rotation=0&showTitle=true&size=249260&status=done&style=none&taskId=ufe972293-e9ed-42f7-b019-108d6f6f023&title=%E5%8A%A0%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E4%B9%8B%E5%90%8E&width=630.6666666666666" alt="加轻量级锁之后" title="加轻量级锁之后"><br />如果cas 失败，有两种情况</p>
<ul>
<li>如果是其它线程已经持有了该Object的轻量级锁，这时表明有竞争，进入锁膨胀过程</li>
<li>如果是自己执行了synchronized<strong>锁重入</strong>，那么再添加一条Lock Recorrd 作为重入的计数</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652187543586-c1915fd0-6d07-4b2f-ab08-430efdcaaaeb.png#averageHue=%23dddd9b&clientId=ub2cb5786-dc2a-4&from=paste&height=367&id=uc04c8646&originHeight=550&originWidth=891&originalType=binary&ratio=1&rotation=0&showTitle=false&size=331577&status=done&style=none&taskId=u5566ceb2-7a14-48f0-a4bc-3ccb8c86edc&title=&width=594" alt="image.png"></p>
<p>当退出synchronized代码块（解锁时）如果有取值为null的锁记录，表示有重入，这时重置锁记录，表示<br />重入计数减一。</p>
<p>当退出synchronized代码块（解锁时）锁记录的值不为null，这时使用cas将Mark Word 的值恢复给对象头</p>
<ul>
<li>成功，则解锁成功</li>
<li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651916739005-675c8ac0-7490-4cda-abde-6c8bc5eeb562.png#averageHue=%23f8f7f7&clientId=u4d909540-ad5c-4&from=paste&height=777&id=u3606bc88&originHeight=1282&originWidth=905&originalType=binary&ratio=1&rotation=0&showTitle=false&size=236980&status=done&style=none&taskId=u8ff03b52-0b9d-44be-8da7-75689953a9f&title=&width=548.4848167832798" alt="image.png"><br><a name="QMYW6"></a></p>
<h3 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h3><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻<br />量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p>
<ul>
<li>为Object对象申请 Monitor锁，让object指向重量级锁地址</li>
<li>然后自己进入Monitor的EntryList BLOCKED</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652231751456-3a19835d-a249-460f-92ae-c2a1fad65a43.png#averageHue=%23e3e8b4&clientId=u986fdba0-2901-4&from=paste&height=207&id=u3dd7e676&originHeight=311&originWidth=924&originalType=binary&ratio=1&rotation=0&showTitle=false&size=136386&status=done&style=none&taskId=ufd513d7f-6601-4497-8b0a-eea0c2c873e&title=&width=616" alt="image.png"><br />当Thread-0退出同步块解锁时，使用cas将Mark Word 的值恢复给对象头，会失败。这时会进入重量级解锁流程，即按照Monitor地址找到Monitor对象，设置Owner为null，唤醒EntryList中 BLOCKED线程。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651917159175-01d5800b-9d75-4278-8b57-f85ad1659b71.png#averageHue=%23f8f6f6&clientId=u4d909540-ad5c-4&from=paste&height=689&id=u173746e5&originHeight=1137&originWidth=908&originalType=binary&ratio=1&rotation=0&showTitle=false&size=215612&status=done&style=none&taskId=uc56ab351-eda1-410e-9567-51075472dc7&title=&width=550.3029984963736" alt="image.png"><br><a name="G2Bf4"></a></p>
<h3 id="重量级锁的优化"><a href="#重量级锁的优化" class="headerlink" title="重量级锁的优化"></a>重量级锁的优化</h3><p><a name="tY10t"></a></p>
<h4 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h4><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退<br />出了同步块，释放了锁），这时当前线程就可以**避免阻塞 减少上下文切换	**。</p>
<p>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能<br />性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</p>
<p>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</p>
<p>自旋成功<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651917371100-4cc26771-5c62-4c62-9941-145c70d6e7af.png#averageHue=%23f5f4f4&clientId=u4d909540-ad5c-4&from=paste&height=661&id=u29f33815&originHeight=1091&originWidth=1621&originalType=binary&ratio=1&rotation=0&showTitle=false&size=215501&status=done&style=none&taskId=u53d262f9-efc8-4c3c-8fd6-83c42798683&title=&width=982.4241856416537" alt="image.png"><br />自旋失败<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1651917379646-6e0109e8-bcee-4326-b894-d977faa0d175.png#averageHue=%23f4f4f3&clientId=u4d909540-ad5c-4&from=paste&height=613&id=u3dc6bedb&originHeight=1012&originWidth=1638&originalType=binary&ratio=1&rotation=0&showTitle=false&size=204612&status=done&style=none&taskId=u697f51a6-9611-44f0-a524-b21e1021f26&title=&width=992.7272153491849" alt="image.png"><br><a name="qkABq"></a></p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。Java 6 中引入了偏向锁<br />来做进一步优化：只有第一次使用 CAS 将<strong>线程 ID</strong> 设置到对象的 Mark Word 头(不是设置锁记录地址了)，之后发现这个线程 ID是自己的就表示没有竞争，不用重新 CAS。 </p>
<ul>
<li>撤销偏向需要将持锁线程升级为轻量级锁，这个过程中所有线程需要暂停（STW）</li>
<li>访问对象的 hashCode 也会撤销偏向锁 <ul>
<li>因为hashCode本来是存到mark里的，然后由于加锁到了线程中，此时其他对象想获取这个对象的hashcode就拿不到了。</li>
</ul>
</li>
<li>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，</li>
<li>重偏向会重置对象的 Thread ID</li>
<li>撤销偏向和重偏向都是批量进行的，以类为单位</li>
<li>如果撤销偏向到达某个阈值，整个类的所有对象都会变为不可偏向的</li>
<li>可以主动使用 -XX:-UseBiasedLocking 禁用偏向锁</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1652337060162-a0fcea0d-a450-4433-93a6-65b0d9f33e98.png#averageHue=%23eaeee7&clientId=uda4812d7-352a-4&from=paste&height=413&id=u55a4105c&originHeight=620&originWidth=1522&originalType=binary&ratio=1&rotation=0&showTitle=false&size=449961&status=done&style=none&taskId=u11a72a2e-02a2-4b63-9698-9280efc6a4a&title=&width=1014.6666666666666" alt="image.png"><br />一个对象创建时：</p>
<ul>
<li>如果开启了偏向锁（默认开启），那么对象创建后，markword值为0x05即最后3位为101,这时它的</li>
</ul>
<p>thread、epoch、age都为0。</p>
<ul>
<li>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加VM参数- XX:BiasedLockingStartupDelay&#x3D;g来禁用延迟。</li>
<li>如果没有开启偏向锁，那么对象创建后，markword值为Ox01即最后3位为00l,这时它的hashcode、age</li>
</ul>
<p>都为0，第一次用到hashcode时才会赋值。synchronized<br><a name="cAAU1"></a></p>
<h3 id="其它优化"><a href="#其它优化" class="headerlink" title="其它优化"></a>其它优化</h3><ul>
<li>减少上锁时间</li>
<li>减少锁的粒度</li>
<li>锁粗化<ul>
<li>多次循环进入同步块不如同步块内多次循环</li>
</ul>
</li>
<li>锁消除<ul>
<li>JVM 会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候就会被即时编译器忽略掉所有同步操作</li>
</ul>
</li>
</ul>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://example.com/2023/06/09/Java%E5%B9%B6%E5%8F%91/" title="Java并发" target="_blank" rel="external">http://example.com/2023/06/09/Java并发/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/sugarGood" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/a.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/sugarGood" target="_blank"><span class="text-dark">theo</span><small class="ml-1x">Think &amp; Practice</small></a></h3>
        <div>一个大帅比。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2023/07/07/%E6%B5%85%E6%9E%90nacos%E6%BA%90%E7%A0%81%E4%B8%80%20%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/" title="浅析nacos源码一 服务注册"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2023/05/12/Mysql/" title="Mysql"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">    <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>





</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/sugarGood" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/cofess" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: true,
    notify: true,
    appId: 'QEI0gu3ZchE5x4TcybdvG8iL-gzGzoHsz',
    appKey: 'bqHluNWepzDS18qbu1Nk8m7Q',
    placeholder: '留下你的评论o(*￣▽￣*)ブ',
    avatar: 'monsterid',
    meta: meta,
    pageSize: '10' || 10,
    visitor: true
  });
  </script>

     



  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>