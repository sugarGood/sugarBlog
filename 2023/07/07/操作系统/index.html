<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>操作系统 | SugarGood</title>
  <meta name="description" content="硬件结构 CPU程序执行流程CPU包括三个部分，运算单元、数据单元、控制单元。运算单元负责计算，数据单元负责暂时存放数据和运算结果，控制单元可以获取指令并执行，这个指令会指导运算单元取出数据单元中的某几个数据，计算出个结果，然后放在数据单元的某个地方。进程都有自己的内存空间，互相隔离，程序会分别加载到进程 A 和进程 B 的内存空间里面，形成各自的代码段，程序运行的过程中要操作的数据和产生的计">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://example.com/2023/07/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="SugarGood">
<meta property="og:description" content="硬件结构 CPU程序执行流程CPU包括三个部分，运算单元、数据单元、控制单元。运算单元负责计算，数据单元负责暂时存放数据和运算结果，控制单元可以获取指令并执行，这个指令会指导运算单元取出数据单元中的某几个数据，计算出个结果，然后放在数据单元的某个地方。进程都有自己的内存空间，互相隔离，程序会分别加载到进程 A 和进程 B 的内存空间里面，形成各自的代码段，程序运行的过程中要操作的数据和产生的计">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1658108481093-ff902c2d-8f99-4d9f-be3c-c9a8b6854798.png#averageHue=%23fbfaf8&clientId=u739dcde0-0393-4&from=paste&id=u67bf76aa&originHeight=995&originWidth=2144&originalType=url&ratio=1&rotation=0&showTitle=false&size=256116&status=done&style=none&taskId=u997ab074-e526-4304-97fe-7cf3a7530d6&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1658109685523-99e05f73-7cbd-4e88-9139-c81a98a636cc.png#averageHue=%23f5f5f4&clientId=u739dcde0-0393-4&from=paste&id=u8e0421c7&originHeight=1882&originWidth=2749&originalType=url&ratio=1&rotation=0&showTitle=false&size=1117095&status=done&style=none&taskId=u14c4b454-74f5-4009-8093-42ecec9245c&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1658128501282-be50495c-ffc4-492d-a969-17270459cc49.png#averageHue=%2382724c&clientId=u78fc5d54-4d3a-4&from=paste&id=ud26be429&originHeight=346&originWidth=371&originalType=url&ratio=1&rotation=0&showTitle=false&size=93510&status=done&style=none&taskId=uc09f41ab-c670-431f-a1e0-405f6f2c51c&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1658132149435-c0468dc9-efda-43f0-afd2-d40a78274d58.png#averageHue=%23e6d08e&clientId=u08cee8eb-da17-4&from=paste&id=uddcc0f3f&originHeight=92&originWidth=662&originalType=url&ratio=1&rotation=0&showTitle=false&size=49782&status=done&style=none&taskId=u6f01201f-5cb5-4903-ab4f-35bf403c74e&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1658130411449-4c14a0b5-8896-476d-9f7e-31e4f4dd8c7e.png#averageHue=%23f0f1f4&clientId=u08cee8eb-da17-4&from=paste&id=u399da666&originHeight=747&originWidth=1413&originalType=url&ratio=1&rotation=0&showTitle=false&size=102006&status=done&style=none&taskId=ue09581f3-a49d-4759-8b25-8d89e0bdcd0&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1658134018373-106a51d6-310a-4217-b148-fb75720c4d72.png#averageHue=%23fae0c2&clientId=u08cee8eb-da17-4&from=paste&id=u9dbcafbe&originHeight=881&originWidth=1325&originalType=url&ratio=1&rotation=0&showTitle=false&size=159302&status=done&style=none&taskId=u40e9798e-70e3-470e-8c0a-d703d4b4705&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1658193473149-a87e0d40-38f5-4dcc-8981-5b0e6aff8250.png#averageHue=%23fae0c2&clientId=uce291bc7-fd85-4&from=paste&id=ue2cb7727&originHeight=881&originWidth=1325&originalType=url&ratio=1&rotation=0&showTitle=false&size=159302&status=done&style=none&taskId=u554d99b6-58ba-4b30-81e4-9ab901797fd&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1660283943514-81d677a4-68d1-4502-8fc5-b4332c1ac516.png#averageHue=%23e1ecbd&clientId=ua1b0c207-8061-4&from=paste&id=u7d7dc3ef&originHeight=542&originWidth=662&originalType=url&ratio=1&rotation=0&showTitle=false&size=164555&status=done&style=none&taskId=u61356c25-b86a-45f7-8fd6-41c4238cff0&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1658298145573-904b801f-6e1f-44ee-b59b-b53f4f63bc48.png#averageHue=%23f9f7f6&clientId=ubfdf34e8-a15a-4&from=paste&id=ud610a3c5&originHeight=827&originWidth=1209&originalType=url&ratio=1&rotation=0&showTitle=false&size=279568&status=done&style=none&taskId=u746e556f-eef0-4903-ac23-37d5265c3af&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1658308476019-c4ccab4d-cf1d-4d11-abe3-cdb75735ade9.png#averageHue=%23dee9b8&clientId=ubfdf34e8-a15a-4&from=paste&height=465&id=uaa97b55d&originHeight=697&originWidth=1037&originalType=binary&ratio=1&rotation=0&showTitle=false&size=236916&status=done&style=none&taskId=u4c7a2722-0e9b-4c52-93f1-703a09ff674&title=&width=691.3333333333334">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1660720641311-25f33404-4b50-4eca-bf25-04a66dc682bb.png#averageHue=%23ecd9bc&clientId=u6937f787-0bc4-4&from=paste&id=uce9f7eec&originHeight=1697&originWidth=872&originalType=url&ratio=1&rotation=0&showTitle=false&size=1084042&status=done&style=none&taskId=uab5b8a5e-0cda-479f-a122-764a41ffdf5&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1660720851351-d9310ac5-d4c7-4d71-830c-6ebad8a4a136.png#averageHue=%23f7f7f1&clientId=u6937f787-0bc4-4&from=paste&id=u6246a0be&originHeight=669&originWidth=1037&originalType=url&ratio=1&rotation=0&showTitle=false&size=124882&status=done&style=none&taskId=uc22f8e9c-5b8c-4727-94fb-31b47cb7076&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1660747005578-8d3dd2f5-0664-44df-bab3-b46bb3c3dca2.png#averageHue=%2368f0ac&clientId=uf26dec86-65d0-4&from=paste&id=ub8c4f098&originHeight=1011&originWidth=1280&originalType=url&ratio=1&rotation=0&showTitle=false&size=200108&status=done&style=none&taskId=ub268530e-d7fb-49a0-bce0-f6b7c4525be&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1660748894106-bfc6fe82-53ca-4a90-a90e-f1edf5fee770.png#averageHue=%23fcfbfb&clientId=uf26dec86-65d0-4&from=paste&id=u87b02586&originHeight=332&originWidth=1053&originalType=url&ratio=1&rotation=0&showTitle=false&size=99668&status=done&style=none&taskId=ufd44be13-bfc4-49fb-afcd-9530fc89a4c&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661266836460-57292f63-aef0-4797-9313-5bc573ac2f2a.png#averageHue=%23f9f6ee&clientId=uc2fcb605-deac-4&from=paste&id=u2729d287&originHeight=539&originWidth=831&originalType=url&ratio=1&rotation=0&showTitle=false&size=45087&status=done&style=none&taskId=u3e602bb8-6d8c-4355-a4bc-4e44db23c2d&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661266907308-38c2ea49-41f8-4490-8ace-cf07effc459c.png#averageHue=%23f8e3aa&clientId=uc2fcb605-deac-4&from=paste&id=u3c2b48f3&originHeight=1004&originWidth=1382&originalType=url&ratio=1&rotation=0&showTitle=false&size=100068&status=done&style=none&taskId=u06e15ff3-97a0-432a-bbbc-164048024da&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661267194343-ea2bfb69-d05a-4c3a-a577-7d2be3e9cff4.png#averageHue=%23f7ede3&clientId=uc2fcb605-deac-4&from=paste&id=ud65df96a&originHeight=651&originWidth=1055&originalType=url&ratio=1&rotation=0&showTitle=false&size=91801&status=done&style=none&taskId=uf33e17f5-0d50-46e6-b4cb-77257143b50&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661267331680-742ae639-9027-4061-a3ea-88745550bc1a.png#averageHue=%23f7f3ee&clientId=uc2fcb605-deac-4&from=paste&id=u5b4cb3cc&originHeight=806&originWidth=1518&originalType=url&ratio=1&rotation=0&showTitle=false&size=256996&status=done&style=none&taskId=u3c618a8a-6443-4be0-91a2-f9ddc6de788&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661267823290-269606a3-79f9-48b3-b777-ce445feb3393.png#averageHue=%23a6a896&clientId=uc2fcb605-deac-4&from=paste&id=uec7f2852&originHeight=561&originWidth=935&originalType=url&ratio=1&rotation=0&showTitle=false&size=67937&status=done&style=none&taskId=u67018518-9ee7-4429-89a5-5dad70ffd54&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661268723377-9aed58b5-03cf-4282-9637-95cb265b6062.png#averageHue=%23faf8f4&clientId=uc2fcb605-deac-4&from=paste&id=ua7b8e6f4&originHeight=797&originWidth=1067&originalType=url&ratio=1&rotation=0&showTitle=false&size=65731&status=done&style=none&taskId=u5a6f4374-9698-44b3-b2c8-900aa8afc72&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661269765882-fb61b2ae-cc13-4a78-9d4b-bf29a7ddfa2c.png#averageHue=%23f7f3f1&clientId=uc2fcb605-deac-4&from=paste&id=ufef493e6&originHeight=1146&originWidth=1686&originalType=url&ratio=1&rotation=0&showTitle=false&size=218062&status=done&style=none&taskId=u183f9759-4ecb-47a4-a9a4-7aeab8c3336&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661270315954-971fbc12-a035-41fe-97dd-355e8889172a.png#averageHue=%23fcfaf7&clientId=uc2fcb605-deac-4&from=paste&id=ue7f84328&originHeight=1427&originWidth=1931&originalType=url&ratio=1&rotation=0&showTitle=false&size=304099&status=done&style=none&taskId=u778774b7-af29-4176-be8a-23e6e7a9623&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661270506591-c69dcacb-2495-46d8-9404-f61eef7a6adc.png#averageHue=%23f8f5ea&clientId=uc2fcb605-deac-4&from=paste&id=u5452a73f&originHeight=509&originWidth=1008&originalType=url&ratio=1&rotation=0&showTitle=false&size=45194&status=done&style=none&taskId=u2717e7cf-90ea-4885-841a-202db92b3e3&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661270804782-56609b02-6bf5-4417-a61c-d1e4172a0889.png#averageHue=%23f5eddc&clientId=uc2fcb605-deac-4&from=paste&id=ubdf18997&originHeight=699&originWidth=1452&originalType=url&ratio=1&rotation=0&showTitle=true&size=120443&status=done&style=none&taskId=u8e3ecc75-b344-4b05-a89c-72400a9a256&title=%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%AF%B9%E5%BA%94%E4%B8%80%E4%B8%AA%E6%AE%B5%E8%A1%A8">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1662022764354-e7684e53-bbfe-414d-bd27-2169f29e9e69.png#averageHue=%23f8f7f6&clientId=ub403381c-2d8f-4&from=paste&id=ucfa33393&originHeight=507&originWidth=738&originalType=url&ratio=1&rotation=0&showTitle=false&size=51720&status=done&style=none&taskId=uc5e528e9-2cd0-4350-95e3-8abb51a0a92&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1662022234073-57c97716-ad91-4abb-86bf-ce1210d3c755.png#averageHue=%23f8f5f2&clientId=ub403381c-2d8f-4&from=paste&id=u2acd9bdf&originHeight=718&originWidth=656&originalType=url&ratio=1&rotation=0&showTitle=false&size=72347&status=done&style=none&taskId=u735c70bd-4783-4a55-9172-f8684c065db&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1662022440871-22a7000c-431b-494a-a467-4fb89b4990b7.png#averageHue=%23e79545&clientId=ub403381c-2d8f-4&from=paste&id=u1bb42a54&originHeight=491&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&size=77498&status=done&style=none&taskId=ufa7a9f66-8426-4141-bff5-1882aa0cc48&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1662081398461-d8f94216-fa21-4015-898a-f6ff5c97f906.png#averageHue=%23fcf9f7&clientId=uba07c7e4-e8c0-4&from=paste&id=u725aa4e0&originHeight=1307&originWidth=977&originalType=url&ratio=1&rotation=0&showTitle=false&size=100273&status=done&style=none&taskId=ua7c3b5f2-c4f9-495d-b6ae-9a3fa368919&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661869911227-bc8d9799-e1a8-4b27-a856-b0b34689f5f2.png#averageHue=%23e8c199&clientId=u3a69160e-ae01-4&from=paste&height=295&id=RY05r&originHeight=442&originWidth=1166&originalType=binary&ratio=1&rotation=0&showTitle=false&size=202295&status=done&style=none&taskId=ud4f0fea1-a00d-4682-b8b4-8fc6e85a23f&title=&width=777.3333333333334">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661870034714-8401bb6b-b185-45c9-9068-6634b1cf53ee.png#averageHue=%23e4e7e5&clientId=u3a69160e-ae01-4&from=paste&id=rZ5dS&originHeight=426&originWidth=950&originalType=url&ratio=1&rotation=0&showTitle=false&size=166548&status=done&style=none&taskId=uc43dadf4-1067-405d-8200-6031f36756f&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661872346985-6b053849-3975-44ba-b66b-2442e19cea01.png#averageHue=%23f5c18b&clientId=u3a69160e-ae01-4&from=paste&id=uInIy&originHeight=1324&originWidth=894&originalType=url&ratio=1&rotation=0&showTitle=false&size=244505&status=done&style=none&taskId=udb7a77e1-1b85-4830-817b-37f20923b24&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661872564958-dc09a877-197d-44a0-b39f-d8f9ccf48326.png#averageHue=%23f3f3f1&clientId=u3a69160e-ae01-4&from=paste&id=jWZmA&originHeight=837&originWidth=1287&originalType=url&ratio=1&rotation=0&showTitle=false&size=222694&status=done&style=none&taskId=uab02453d-1fe9-45cc-96e5-5b9931466e1&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661872573796-719645b8-7177-46d4-9a56-8d5fd5678ddc.png#averageHue=%23f3f2f1&clientId=u3a69160e-ae01-4&from=paste&id=h4vgS&originHeight=837&originWidth=1337&originalType=url&ratio=1&rotation=0&showTitle=false&size=229560&status=done&style=none&taskId=u9dc6301c-b90f-4c57-a598-a17208b7166&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1663574637403-65c9e2c3-a804-4444-b396-aac295714103.png#averageHue=%23cee2bf&clientId=uf2374c8c-772d-4&from=paste&id=u7354da57&originHeight=377&originWidth=737&originalType=url&ratio=1&rotation=0&showTitle=false&size=127925&status=done&style=none&taskId=u38ac353c-ae0d-42b8-b169-4fcdc20e318&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1663574699923-a5354717-fc5a-4b6f-ad75-e90c76fa4613.png#averageHue=%23f4f3ee&clientId=uf2374c8c-772d-4&from=paste&id=u38707ee8&originHeight=212&originWidth=1187&originalType=url&ratio=1&rotation=0&showTitle=false&size=68359&status=done&style=none&taskId=u6d9d5b9c-6fb3-4646-bfa2-63a6acc9b39&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1663664351303-5c516f90-4f06-4bfd-89e3-d2553ab9d4dd.png#averageHue=%23faf8f4&clientId=uc45b8507-4deb-4&from=paste&id=u6ba45a17&originHeight=722&originWidth=1166&originalType=url&ratio=1&rotation=0&showTitle=false&size=234606&status=done&style=none&taskId=ua15abc8d-2464-4e08-9acf-cbc74102a9c&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1663836615865-96b97ff4-fe8d-4f5c-866e-2ea847a34a9d.png#averageHue=%23efe3be&clientId=ucc9c2ff3-2f2e-4&from=paste&id=u7fffcdc0&originHeight=173&originWidth=572&originalType=url&ratio=1&rotation=0&showTitle=false&size=49073&status=done&style=none&taskId=uff5ff36e-f36e-44d1-be24-878a348ca07&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1663837898706-a9b7b4fb-9039-4951-8297-cb2cfbbe057a.png#averageHue=%23c1c3c1&clientId=ucc9c2ff3-2f2e-4&from=paste&id=u3b9b88c4&originHeight=426&originWidth=950&originalType=url&ratio=1&rotation=0&showTitle=false&size=113144&status=done&style=none&taskId=ub91374bb-f577-44f5-b8a3-d4ff01fe777&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1668412435060-6ae5c0fa-e1ea-4d29-beba-3d86987da793.png#averageHue=%23fafaf9&clientId=u305a72ef-6277-4&from=paste&id=uc631c4ee&originHeight=860&originWidth=1832&originalType=url&ratio=1&rotation=0&showTitle=false&size=335379&status=done&style=none&taskId=u2cc43902-e605-466f-a9f6-50babc39511&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/22451783/1674026566361-c0acd248-9e0e-46a9-b059-dc12c8c6709a.png#averageHue=%23f7f2e6&clientId=uaa416c7c-0376-4&from=paste&id=u3910856a&originHeight=678&originWidth=1100&originalType=url&ratio=1&rotation=0&showTitle=false&size=230228&status=done&style=none&taskId=u8ab3bf6f-355d-46e4-8813-9d439ed537e&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/22451783/1674027026494-f25dde8e-a983-422e-a9a7-f3447a6a5469.png#averageHue=%23f0eee1&clientId=uaa416c7c-0376-4&from=paste&id=uda46c372&originHeight=686&originWidth=1160&originalType=url&ratio=1&rotation=0&showTitle=false&size=267137&status=done&style=none&taskId=u9d44cd20-8b12-469b-ae37-3233cff912c&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/22451783/1675666447142-86a6d349-a6dc-40fd-a17e-16a823adae0c.png#averageHue=%23f8f5eb&clientId=u6973ef98-2165-4&from=paste&id=uaf0a3b89&originHeight=722&originWidth=407&originalType=url&ratio=1&rotation=0&showTitle=false&size=76145&status=done&style=none&taskId=u9e268dd3-3e9e-4cda-b7ae-d0066440d36&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/22451783/1675667340595-b293c656-a8bf-468e-897b-3c113c2d901a.png#averageHue=%23eceed2&clientId=u6973ef98-2165-4&from=paste&id=u3ee09042&originHeight=527&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=142018&status=done&style=none&taskId=udfb904a8-17f9-4802-9f0e-3df79f2d836&title=">
<meta property="article:published_time" content="2023-07-07T13:29:41.317Z">
<meta property="article:modified_time" content="2023-07-07T13:33:46.315Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="OS">
<meta property="article:tag" content="计算机基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2022/png/22451783/1658108481093-ff902c2d-8f99-4d9f-be3c-c9a8b6854798.png#averageHue=%23fbfaf8&clientId=u739dcde0-0393-4&from=paste&id=u67bf76aa&originHeight=995&originWidth=2144&originalType=url&ratio=1&rotation=0&showTitle=false&size=256116&status=done&style=none&taskId=u997ab074-e526-4304-97fe-7cf3a7530d6&title=">
  <!-- Canonical links -->
  <link rel="canonical" href="http://example.com/2023/07/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
  
    <link rel="alternate" href="/atom.xml" title="SugarGood" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 6.3.0"></head>


<body class="main-center theme-blue" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/sugarGood" target="_blank">
          <img class="img-circle img-rotate" src="/images/a.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">theo</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Think &amp; Practice</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> ChongQing, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/sugarGood" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://gitee.com/sugarGood" target="_blank" title="Gitee" data-toggle=tooltip data-placement=top><i class="icon icon-gitee"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p> 文章目录在文章左下角哦
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81/">源码</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>


    
      <!---->
<!--  <div class="widget">-->
<!--    <h3 class="widget-title">标签云</h3>-->
<!--    <div class="widget-body tagcloud">-->
<!--      <a href="/tags/JUC/" style="font-size: 13px;">JUC</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 13px;">Java基础</a> <a href="/tags/OS/" style="font-size: 13px;">OS</a> <a href="/tags/mysql/" style="font-size: 13px;">mysql</a> <a href="/tags/nacos/" style="font-size: 13px;">nacos</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 13px;">计算机基础</a>-->
<!--    </div>-->
<!--  </div>-->
<!---->


  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/nacos/" style="font-size: 13px; color: #e48b3a">nacos</a> <a href="/tags/mysql/" style="font-size: 13px; color: #e48b3a">mysql</a> <a href="/tags/OS/" style="font-size: 13px; color: #e48b3a">OS</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 13px; color: #e48b3a">计算机基础</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 13px; color: #e48b3a">Java基础</a> <a href="/tags/JUC/" style="font-size: 13px; color: #e48b3a">JUC</a>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
              </p>
              <p class="item-title">
                <a href="/2023/07/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="title">操作系统</a>
              </p>
              <p class="item-date">
                <time datetime="2023-07-07T13:29:41.317Z" itemprop="datePublished">2023-07-07</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%BA%90%E7%A0%81/">源码</a>
              </p>
              <p class="item-title">
                <a href="/2023/07/07/%E6%B5%85%E6%9E%90nacos%E6%BA%90%E7%A0%81%E4%B8%80%20%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/" class="title">浅析nacos源码一 服务注册</a>
              </p>
              <p class="item-date">
                <time datetime="2023-07-07T09:29:10.792Z" itemprop="datePublished">2023-07-07</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
              </p>
              <p class="item-title">
                <a href="/2023/06/26/Java%E5%B9%B6%E5%8F%91/" class="title">Java并发</a>
              </p>
              <p class="item-date">
                <time datetime="2023-06-26T02:24:54.879Z" itemprop="datePublished">2023-06-26</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
              </p>
              <p class="item-title">
                <a href="/2023/06/26/Mysql/" class="title">Mysql</a>
              </p>
              <p class="item-date">
                <time datetime="2023-06-26T02:24:54.879Z" itemprop="datePublished">2023-06-26</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">硬件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">CPU程序执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF"><span class="toc-number">1.1.1.</span> <span class="toc-text">总线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E8%B7%AF%E4%BD%8D%E5%AE%BD%E4%B8%8E-CPU-%E4%BD%8D%E5%AE%BD"><span class="toc-number">1.1.2.</span> <span class="toc-text">线路位宽与 CPU 位宽</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E8%B7%AF%E4%BD%8D%E5%AE%BD"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">线路位宽</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU%E4%BD%8D%E5%AE%BD"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">CPU位宽</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#a-x3D-1-2%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">a&#x3D;1+2的执行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E9%80%9F%E5%BA%A6"><span class="toc-number">1.1.4.</span> <span class="toc-text">指令的执行速度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">CPU数据存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-Cache"><span class="toc-number">1.2.2.</span> <span class="toc-text">CPU Cache</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.2.2.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#L2-%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">L2 高速缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#L3-%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">L3 高速缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-number">1.2.3.</span> <span class="toc-text">内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSD-x2F-HDD-%E7%A1%AC%E7%9B%98"><span class="toc-number">1.2.4.</span> <span class="toc-text">SSD&#x2F;HDD 硬盘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.5.</span> <span class="toc-text">存储器的层次关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96"><span class="toc-number">1.2.6.</span> <span class="toc-text">cpu数据读取</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">读取步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5"><span class="toc-number">1.2.7.</span> <span class="toc-text">cpu数据写入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.2.8.</span> <span class="toc-text">cpu缓存一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E5%97%85%E6%8E%A2"><span class="toc-number">1.2.8.1.1.</span> <span class="toc-text">总线嗅探</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MESI%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.2.8.1.2.</span> <span class="toc-text">MESI协议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E4%BC%AA%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.9.</span> <span class="toc-text">CPU伪共享问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.10.</span> <span class="toc-text">CPU如何选择线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E5%AF%86%E9%9B%86%E5%9E%8B%E5%92%8CIO%E5%AF%86%E9%9B%86%E5%9E%8B"><span class="toc-number">1.2.11.</span> <span class="toc-text">CPU密集型和IO密集型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">1.3.</span> <span class="toc-text">中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.3.1.</span> <span class="toc-text">中断是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="toc-number">1.3.2.</span> <span class="toc-text">软中断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98"><span class="toc-number">1.4.</span> <span class="toc-text">磁盘</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8"><span class="toc-number">2.1.</span> <span class="toc-text">内核</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">3.1.</span> <span class="toc-text">虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5"><span class="toc-number">3.1.1.</span> <span class="toc-text">内存分段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">内存碎片</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5"><span class="toc-number">3.1.2.</span> <span class="toc-text">内存分页</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">3.1.3.</span> <span class="toc-text">多级页表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLB"><span class="toc-number">3.1.4.</span> <span class="toc-text">TLB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.1.5.</span> <span class="toc-text">段页式内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-number">3.1.6.</span> <span class="toc-text">CPU数据读取流程总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E5%88%86%E9%85%8D"><span class="toc-number">3.2.</span> <span class="toc-text">惰性分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.1.</span> <span class="toc-text">程序的局部性原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD-PageFault"><span class="toc-number">3.3.</span> <span class="toc-text">缺页中断 PageFault</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#swap%E5%88%86%E5%8C%BA"><span class="toc-number">3.4.</span> <span class="toc-text">swap分区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#overcommit"><span class="toc-number">3.5.</span> <span class="toc-text">overcommit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OOM-killer"><span class="toc-number">3.5.1.</span> <span class="toc-text">OOM killer:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6"><span class="toc-number">3.5.2.</span> <span class="toc-text">内存回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#-1"><span class="toc-number">3.5.2.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%E5%91%A2%EF%BC%9F"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">哪些内容可以被回收呢？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#malloc-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">3.6.</span> <span class="toc-text">malloc 动态内存分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LRU%E7%AE%97%E6%B3%95"><span class="toc-number">3.7.</span> <span class="toc-text">LRU算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E8%AF%BB%E5%A4%B1%E6%95%88%E5%92%8C%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93"><span class="toc-number">3.8.</span> <span class="toc-text">预读失效和缓存污染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%84%E8%AF%BB%EF%BC%9F"><span class="toc-number">3.8.1.</span> <span class="toc-text">什么是预读？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%A2%84%E8%AF%BB%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="toc-number">3.8.2.</span> <span class="toc-text">如何避免预读失效？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93"><span class="toc-number">3.8.3.</span> <span class="toc-text">缓存污染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93"><span class="toc-number">3.8.4.</span> <span class="toc-text">如何解决缓存污染</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">4.1.1.</span> <span class="toc-text">进程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97-PCB"><span class="toc-number">4.1.2.</span> <span class="toc-text">进程控制块(PCB)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.3.</span> <span class="toc-text">进程的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">创建进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">终止进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.1.3.3.</span> <span class="toc-text">阻塞进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%94%A4%E9%86%92%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.1.3.4.</span> <span class="toc-text">唤醒进程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">4.1.4.</span> <span class="toc-text">进程的上下文切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%AF%94%E8%BE%83"><span class="toc-number">4.2.1.</span> <span class="toc-text">线程和进程比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">4.2.2.</span> <span class="toc-text">线程上下文切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.3.</span> <span class="toc-text">线程的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6"><span class="toc-number">4.3.</span> <span class="toc-text">调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%8E%9F%E5%88%99"><span class="toc-number">4.3.1.</span> <span class="toc-text">调度原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.2.</span> <span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%EF%BC%88First-Come-First-Serve-FCFS"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">先来先服务（First Come First Serve, FCFS)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%EF%BC%88Shortest-Job-First-SJF%EF%BC%89"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">最短作业优先（Shortest Job First, SJF）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88-%EF%BC%88Highest-Response-Ratio-Next-HRRN%EF%BC%89"><span class="toc-number">4.3.2.3.</span> <span class="toc-text">高响应比优先 （Highest Response Ratio Next, HRRN）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%EF%BC%88Round-Robin-RR%EF%BC%89"><span class="toc-number">4.3.2.4.</span> <span class="toc-text">时间片轮转（Round Robin, RR）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%88Highest-Priority-First%EF%BC%8CHPF%EF%BC%89"><span class="toc-number">4.3.2.5.</span> <span class="toc-text">最高优先级（Highest Priority First，HPF）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%EF%BC%88Multilevel-Feedback-Queue%EF%BC%89"><span class="toc-number">4.3.2.6.</span> <span class="toc-text">多级反馈队列（Multilevel Feedback Queue）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">4.4.</span> <span class="toc-text">进程间通信</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.</span> <span class="toc-text">网络系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DMA%E6%8A%80%E6%9C%AF"><span class="toc-number">5.1.</span> <span class="toc-text">DMA技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">5.2.</span> <span class="toc-text">零拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93"><span class="toc-number">5.2.1.</span> <span class="toc-text">传统文件传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D-1"><span class="toc-number">5.2.2.</span> <span class="toc-text">零拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap-write"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">mmap + write</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sendfile"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">sendfile</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PageCache"><span class="toc-number">5.3.</span> <span class="toc-text">PageCache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Select-poll-epoll"><span class="toc-number">5.4.</span> <span class="toc-text">Select poll epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket"><span class="toc-number">5.4.1.</span> <span class="toc-text">Socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-x2F-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">5.4.2.</span> <span class="toc-text">I&#x2F;O多路复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select-x2F-poll"><span class="toc-number">5.4.3.</span> <span class="toc-text">select&#x2F;poll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll"><span class="toc-number">5.4.4.</span> <span class="toc-text">epoll</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reactor"><span class="toc-number">5.5.</span> <span class="toc-text">Reactor</span></a></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-操作系统" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      操作系统
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2023/07/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="article-date">
	  <time datetime="2023-07-07T13:29:41.317Z" itemprop="datePublished">2023-07-07</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/OS/" rel="tag">OS</a>, <a class="article-tag-link-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag">计算机基础</a>
  </span>


        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数: 24.7k
<!-- 		(字) -->
		</span>
	
	


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2023/07/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/#comments" class="article-comment-link">评论</a>
            <span class="valine-comment-count" data-xid="/2023/07/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"></span>条
        </span>

        

	<span class="article-read hidden-xs">
    	<i class="icon icon-eye-fill" aria-hidden="true"></i>
    	<span id="/2023/07/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="leancloud_visitors"  data-flag-title="操作系统">
			<span class="leancloud-visitors-count">0</span>
		</span>
    </span>


      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <meta name="referrer" content="no-referrer"/>

<h1 id="硬件结构"><a href="#硬件结构" class="headerlink" title="硬件结构"></a>硬件结构</h1><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1658108481093-ff902c2d-8f99-4d9f-be3c-c9a8b6854798.png#averageHue=%23fbfaf8&clientId=u739dcde0-0393-4&from=paste&id=u67bf76aa&originHeight=995&originWidth=2144&originalType=url&ratio=1&rotation=0&showTitle=false&size=256116&status=done&style=none&taskId=u997ab074-e526-4304-97fe-7cf3a7530d6&title=" alt="image.png"></p>
<h2 id="CPU程序执行流程"><a href="#CPU程序执行流程" class="headerlink" title="CPU程序执行流程"></a>CPU程序执行流程</h2><p>CPU包括三个部分，运算单元、数据单元、控制单元。<br>运算单元负责计算，数据单元负责暂时存放数据和运算结果，控制单元可以获取指令并执行，这个指令会指导运算单元取出数据单元中的某几个数据，计算出个结果，然后放在数据单元的某个地方。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1658109685523-99e05f73-7cbd-4e88-9139-c81a98a636cc.png#averageHue=%23f5f5f4&clientId=u739dcde0-0393-4&from=paste&id=u8e0421c7&originHeight=1882&originWidth=2749&originalType=url&ratio=1&rotation=0&showTitle=false&size=1117095&status=done&style=none&taskId=u14c4b454-74f5-4009-8093-42ecec9245c&title=" alt="image.png"><br>进程都有自己的内存空间，互相隔离，程序会分别加载到进程 A 和进程 B 的内存空间里面，形成各自的代码段，程序运行的过程中要操作的数据和产生的计算结果，都会放在数据段里面。<br><strong>计算流程：</strong><br>CPU中有一个指令指针寄存器，它里面存放的是下一条指令在内存中的地址。控制单元会不停地将代码段的指令拿进来，先放入指令寄存器。指令一般分为两部分，一部分是做什么操作，一部分是操作哪些数据。要执行这条指令，就要把第一部分交给运算单元，第二部分交给数据单元。数据单元根据数据的地址从数据段里读到数据寄存器里。运算单元做完运算，产生的结果会暂存在数据单元的数据寄存器里。最终，会有指令将数据写回内存中的数据段。</p>
<p>那 CPU 执行程序的过程如下：</p>
<ul>
<li>第一步，CPU 读取「程序计数器」的值，这个值是指令的内存地址，然后 CPU 的「控制单元」操作「地址总线」指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过「数据总线」将指令数据传给 CPU，CPU 收到内存传来的数据后，将这个指令数据存入到「指令寄存器」。</li>
<li>第二步，CPU 分析「指令寄存器」中的指令，确定指令的类型和参数，如果是计算类型的指令，就把指令交给「逻辑运算单元」运算；如果是存储类型的指令，则交由「控制单元」执行；</li>
<li>第三步，CPU 执行完指令后，「程序计数器」的值自增，表示指向下一条指令。这个自增的大小，由 CPU 的位宽决定，比如 32 位的 CPU，指令是 4 个字节，需要 4 个内存地址存放，因此「程序计数器」的值会自增 4；</li>
</ul>
<p>简单总结一下就是，一个程序执行的时候，CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。<br>CPU 从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个不断循环的过程被称为 <strong>CPU 的指令周期</strong>。</p>
<p>当有多个进程需要执行时，CPU 里有两个寄存器，专门保存当前处理进程的代码段的起始地址，以及数据段的起始地址。进程切换就是通过这个定位到进程上次执行到的位置。</p>
<p>常见的寄存器种类：</p>
<ul>
<li>通用寄存器，用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。</li>
<li>程序计数器，用来存储 CPU 要执行下一条指令「所在的内存地址」，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令的地址。</li>
<li>指令寄存器，用来存放程序计数器指向的指令，也就是指令本身，指令被执行完成之前，指令都存储在这里。</li>
</ul>
<h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>总线是用于 CPU 和内存以及其他设备之间的通信，总线可分为 3 种：</p>
<ul>
<li><strong>地址总线</strong>，用于指定 CPU 将要操作的内存地址；</li>
<li><strong>数据总线</strong>，用于读写内存的数据；</li>
<li><strong>控制总线</strong>，用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线；</li>
</ul>
<p>当 CPU 要读写内存数据的时候，一般需要通过下面这三个总线：</p>
<ul>
<li>首先要通过「地址总线」来指定内存的地址；</li>
<li>然后通过「控制总线」控制是读或写命令；</li>
<li>最后通过「数据总线」来传输数据；</li>
</ul>
<p>	</p>
<p><strong>地址总线的位数，决定了能访问的地址范围到底有多广。而数据总线的位数，决定了一次能拿多少个数据进来</strong>。</p>
<p><strong>内存容量为4GB，即内存单元的地址宽度为32位。字长为32位即要求数据总线的宽度为32位，因此地址总线和数据总线的宽度都为32</strong>。2的32次方等于1024<em>1024</em>1024*4 &#x3D; 4GB</p>
<h3 id="线路位宽与-CPU-位宽"><a href="#线路位宽与-CPU-位宽" class="headerlink" title="线路位宽与 CPU 位宽"></a>线路位宽与 CPU 位宽</h3><h4 id="线路位宽"><a href="#线路位宽" class="headerlink" title="线路位宽"></a>线路位宽</h4><p>数据是如何通过线路传输的呢？其实是通过操作电压，低电压表示 0，高压电压则表示 1。</p>
<p>高低高这样的信号，其实就是 101 二进制数据。如果只有一条线路，就意味着每次只能传递 1 bit 的数据，即 0 或 1，那么传输 101 这个数据，就需要 3 次才能传输完成，这样的效率非常低。</p>
<p>这样一位一位传输的方式，称为串行，下一个 bit 必须等待上一个 bit 传输完成才能进行传输。当然，想一次多传一些数据，增加线路即可，这时数据就可以并行传输。</p>
<p>为了避免低效率的串行传输的方式，线路的位宽最好一次就能访问到所有的内存地址。</p>
<p>如果地址总线只有 1 条，那每次只能表示 「0 或 1」这两种地址，所以 CPU 能操作的内存地址最大数量为 2（2^1）个（注意，不要理解成同时能操作 2 个内存地址）；<br>如果地址总线有 2 条，那么能表示 00、01、10、11 这四种地址，所以 CPU 能操作的内存地址最大数量为 4（2^2）个。</p>
<h4 id="CPU位宽"><a href="#CPU位宽" class="headerlink" title="CPU位宽"></a>CPU位宽</h4><p>CPU位宽越大，一次可以计算的bit数就越多。<br>CPU 的位宽最好不要小于线路位宽，32 位 CPU 一次最多只能操作 32 位宽的地址总线和数据总线。<br> 64 位 CPU 性能并不比 32 位 CPU 高很多，很少应用需要算超过 32 位的数字，所以如果计算的数额不超过 32 位数字的情况下，32 位和 64 位 CPU 之间没什么区别的，只有当计算超过 32 位数字的情况下，64 位的优势才能体现出来。</p>
<h3 id="a-x3D-1-2的执行过程"><a href="#a-x3D-1-2的执行过程" class="headerlink" title="a&#x3D;1+2的执行过程"></a>a&#x3D;1+2的执行过程</h3><p>程序编译过程中，编译器通过分析代码，发现 1 和 2 是数据，于是程序运行时，内存会有个专门的区域来存放这些数据，这个区域就是「数据段」。如下图，数据 1 和 2 的区域位置：（0X表示这是个16进制数）<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1658128501282-be50495c-ffc4-492d-a969-17270459cc49.png#averageHue=%2382724c&clientId=u78fc5d54-4d3a-4&from=paste&id=ud26be429&originHeight=346&originWidth=371&originalType=url&ratio=1&rotation=0&showTitle=false&size=93510&status=done&style=none&taskId=uc09f41ab-c670-431f-a1e0-405f6f2c51c&title=" alt="image.png"></p>
<ul>
<li>数据 1 被存放到 0x100 位置；</li>
<li>数据 2 被存放到 0x104 位置；</li>
</ul>
<p>注意，数据和指令是分开区域存放的，存放指令区域的地方称为「正文段」。<br>编译器会把 a &#x3D; 1 + 2 翻译成 4 条指令，存放到正文段中，这 4 条指令被存放到了 0x200 ~ 0x20c 的区域中：<br>● 0x200 的内容是 load 指令将 0x100 地址中的数据 1 装入到寄存器 R0；<br>● 0x204 的内容是 load 指令将 0x104 地址中的数据 2 装入到寄存器 R1；<br>● 0x208 的内容是 add 指令将寄存器 R0 和 R1 的数据相加，并把结果存放到寄存器 R2；<br>● 0x20c 的内容是 store 指令将寄存器 R2 中的数据存回数据段中的 0x108 地址中，这个地址也就是变量 a 内存中的地址<br>编译完成后，具体执行程序的时候，程序计数器会被设置为 0x200 地址，然后依次执行这 4 条指令。<br>上面的例子中，由于是在 32 位 CPU 执行的，因此一条指令是占 32 位大小，所以你会发现每条指令间隔 4 个字节（地址每1代表一个字节 、8个bit 、一个bit存放一个二进制数 8bit也就是8位二进制数表示的数的范围为255）。<br>而数据的大小是根据你在程序中指定的变量类型，比如 int 类型的数据则占 4 个字节，char 类型的数据则占 1 个字节。</p>
<h3 id="指令的执行速度"><a href="#指令的执行速度" class="headerlink" title="指令的执行速度"></a>指令的执行速度</h3><p>CPU 的硬件参数都会有 GHz 这个参数，比如一个 1 GHz 的 CPU，指的是时钟频率是 1 G，代表着 1 秒会产生 1G 次数的脉冲信号，<strong>每一次脉冲信号高低电平的转换就是一个周期，称为时钟周期</strong>  <strong>,1GHz的时间周期时间为1&#x2F;1G。</strong><br>对于 CPU 来说，在一个时钟周期内，CPU 仅能完成一个最基本的动作，时钟频率越高，时钟周期就越短，工作速度也就越快。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1658132149435-c0468dc9-efda-43f0-afd2-d40a78274d58.png#averageHue=%23e6d08e&clientId=u08cee8eb-da17-4&from=paste&id=uddcc0f3f&originHeight=92&originWidth=662&originalType=url&ratio=1&rotation=0&showTitle=false&size=49782&status=done&style=none&taskId=u6f01201f-5cb5-4903-ab4f-35bf403c74e&title=" alt="image.png"><br>而时间周期时间就是CPU主频，如今CPU主频提升已经到了瓶颈，所以可以通过减少** CPU 时钟周期数量**，一样也是能提升程序的性能的。<br>**CPU 时钟周期数量 &#x3D; **指令数 x 每条指令的平均时钟周期数(CPI)<br><code>CPI：表示一条指令需要多少个时钟周期数，现代大多数 CPU 通过流水线技术（Pipeline），让一条指令需要的 CPU 时钟周期数尽可能的少；</code></p>
<h2 id="CPU数据存储器"><a href="#CPU数据存储器" class="headerlink" title="CPU数据存储器"></a>CPU数据存储器</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1658130411449-4c14a0b5-8896-476d-9f7e-31e4f4dd8c7e.png#averageHue=%23f0f1f4&clientId=u08cee8eb-da17-4&from=paste&id=u399da666&originHeight=747&originWidth=1413&originalType=url&ratio=1&rotation=0&showTitle=false&size=102006&status=done&style=none&taskId=ue09581f3-a49d-4759-8b25-8d89e0bdcd0&title=" alt="image.png"></p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>最靠近 CPU 的控制单元和逻辑计算单元的存储器，就是寄存器了，它使用的材料速度也是最快的，因此价格也是最贵的，那么数量不能很多。<br>寄存器的访问速度非常快，一般要求在半个 CPU 时钟周期内完成读写，CPU 时钟周期跟 CPU 主频息息相关，比如 2 GHz 主频的 CPU，那么它的时钟周期就是 1&#x2F;2G，也就是 0.5ns（纳秒）</p>
<h3 id="CPU-Cache"><a href="#CPU-Cache" class="headerlink" title="CPU Cache"></a>CPU Cache</h3><p>CPU Cache 用的是一种叫 SRAM（Static Random-Access Memory，静态随机存储器） 的芯片。<br>SRAM 之所以叫「静态」存储器，是因为只要有电，数据就可以保持存在，而一旦断电，数据就会丢失了。<br>CPU 的高速缓存，通常可以分为 L1、L2、L3 这样的三层高速缓存，也称为一级缓存、二级缓存、三级缓存。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1658134018373-106a51d6-310a-4217-b148-fb75720c4d72.png#averageHue=%23fae0c2&clientId=u08cee8eb-da17-4&from=paste&id=u9dbcafbe&originHeight=881&originWidth=1325&originalType=url&ratio=1&rotation=0&showTitle=false&size=159302&status=done&style=none&taskId=u40e9798e-70e3-470e-8c0a-d703d4b4705&title=" alt="image.png"></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>L1 高速缓存<br>L1 高速缓存的访问速度几乎和寄存器一样快，通常只需要 2~4 个时钟周期，而大小在几十 KB 到几百 KB 不等。<br><strong>每个 CPU 核心都有一块属于自己的 L1 高速缓存</strong>，指令和数据在 L1 是分开存放的，所以 L1 高速缓存通常分成<strong>指令缓存</strong>和<strong>数据缓存</strong>。</p>
<h4 id="L2-高速缓存"><a href="#L2-高速缓存" class="headerlink" title="L2 高速缓存"></a>L2 高速缓存</h4><p><strong>L2 高速缓存同样每个 CPU 核心都有</strong>，但是 L2 高速缓存位置比 L1 高速缓存距离 CPU 核心 更远，它大小比 L1 高速缓存更大，CPU 型号不同大小也就不同，通常大小在几百 KB 到几 MB 不等，访问速度则更慢，速度在 10~20 个时钟周期。</p>
<h4 id="L3-高速缓存"><a href="#L3-高速缓存" class="headerlink" title="L3 高速缓存"></a>L3 高速缓存</h4><p><strong>L3 高速缓存通常是多个 CPU 核心共用的</strong>，位置比 L2 高速缓存距离 CPU 核心 更远，大小也会更大些，通常大小在几 MB 到几十 MB 不等，具体值根据 CPU 型号而定。<br>访问速度相对也比较慢一些，访问速度在 20~60个时钟周期。</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存用的芯片和 CPU Cache 有所不同，它使用的是一种叫作 <strong>DRAM</strong> （Dynamic Random Access Memory，动态随机存取存储器） 的芯片。<br>DRAM 的数据访问电路和刷新电路都比 SRAM 更复杂，所以访问的速度会更慢，内存速度大概在 200~300 个 时钟周期之间。</p>
<h3 id="SSD-x2F-HDD-硬盘"><a href="#SSD-x2F-HDD-硬盘" class="headerlink" title="SSD&#x2F;HDD 硬盘"></a>SSD&#x2F;HDD 硬盘</h3><p>SSD（Solid-state disk） 就是我们常说的固体硬盘，结构和内存类似，但是它相比内存的优点是断电后数据还是存在的，而内存、寄存器、高速缓存断电后数据都会丢失。内存的读写速度比 SSD 大概快 10~1000 倍。<br>当然，还有一款传统的硬盘，也就是机械硬盘（Hard Disk Drive, HDD），它是通过物理读写的方式来访问数据的，因此它访问速度是非常慢的，它的速度比内存慢 10W 倍左右。<br>由于 SSD 的价格快接近机械硬盘了，因此机械硬盘已经逐渐被 SSD 替代了。</p>
<h3 id="存储器的层次关系"><a href="#存储器的层次关系" class="headerlink" title="存储器的层次关系"></a>存储器的层次关系</h3><p>CPU 并不会直接和每一种存储器设备直接打交道，而是每一种存储器设备只和它相邻的存储器设备打交道。<br>比如，CPU Cache 的数据是从内存加载过来的，写回数据的时候也只写回到内存，CPU Cache 不会直接把数据写到硬盘，也不会直接从硬盘加载数据，而是先加载到内存，再从内存加载到 CPU Cache 中。</p>
<p>当 CPU 需要访问内存中某个数据的时候，如果寄存器有这个数据，CPU 就直接从寄存器取数据即可，如果寄存器没有这个数据，CPU 就会查询 L1 高速缓存，如果 L1 没有，则查询 L2 高速缓存，L2 还是没有的话就查询 L3 高速缓存，L3 依然没有的话，才去内存中取数据。</p>
<p>程序执行时，会先将内存中的数据加载到共享的 L3 Cache 中，再加载到每个核心独有的 L2 Cache，最后进入到最快的 L1 Cache，之后才会被 CPU 读取。它们之间的层级关系，如下图<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1658193473149-a87e0d40-38f5-4dcc-8981-5b0e6aff8250.png#averageHue=%23fae0c2&clientId=uce291bc7-fd85-4&from=paste&id=ue2cb7727&originHeight=881&originWidth=1325&originalType=url&ratio=1&rotation=0&showTitle=false&size=159302&status=done&style=none&taskId=u554d99b6-58ba-4b30-81e4-9ab901797fd&title=" alt="image.png"></p>
<h3 id="cpu数据读取"><a href="#cpu数据读取" class="headerlink" title="cpu数据读取"></a>cpu数据读取</h3><p>CPU Cache 是由很多个 Cache Line 组成的，Cache Line 是 CPU 从内存读取数据的基本单位，而 Cache Line 是由各种标志（Tag）+ 数据块（Data Block）组成。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1660283943514-81d677a4-68d1-4502-8fc5-b4332c1ac516.png#averageHue=%23e1ecbd&clientId=ua1b0c207-8061-4&from=paste&id=u7d7dc3ef&originHeight=542&originWidth=662&originalType=url&ratio=1&rotation=0&showTitle=false&size=164555&status=done&style=none&taskId=u61356c25-b86a-45f7-8fd6-41c4238cff0&title=" alt="image.png"></p>
<p>CPU Cache 的数据是从内存中读取过来的，它是以一小块一小块读取数据的，而不是按照单个数组元素来读取数据的，在 CPU Cache 中的，这样一小块一小块的数据，称为** Cache Line**（缓存块）。<br><code>比如，有一个 int array[100] 的数组，当载入 array[0] 时，由于这个数组元素的大小在内存只占 4 字节，不足 64 字节，CPU 就会**顺序加载**数组元素到 array[15]，意味着 array[0]~array[15] 数组元素都会被缓存在 CPU Cache 中了，因此当下次访问这些数组元素时，会直接从 CPU Cache 读取，而不用再从内存中读取，大大提高了 CPU 读取数据的性能。</code></p>
<p><strong>那 CPU 怎么知道要访问的内存数据，是否在 Cache 里？如果在的话，如何找到 Cache 对应的数据呢？</strong><br>CPU 访问内存数据时，是一小块一小块数据读取的，具体这一小块数据的大小，取决于 coherency_line_size 的值，一般 64 字节。在内存中，这一块的数据我们称为内存块（Block），读取的时候我们要拿到数据所在内存块的地址。<br>内存块的地址和cpu line(缓存块)的地址有一个映射关系，<strong>取模</strong>，比如总共Cpu cache中总共由8个cpu line,当需要访问15号内存块的时候通过15%8&#x3D;7得出 需要的数据在可能在7号Cpu line中。</p>
<p>但是取模算法显然是有缺陷的，可能会出现重复，比如7 2 3内存块的映射cpu line都一样。</p>
<p>因此，为了区别不同的内存块，在对应的 CPU Line 中我们还会存储一个<strong>组标记（Tag）</strong>。这个组标记会记录当前 CPU Line 中存储的数据对应的内存块，我们可以用这个组标记来区分不同的内存块。</p>
<p>除了组标记信息外，CPU Line 还有两个信息：</p>
<ul>
<li>一个是，从内存加载过来的实际存放数据（Data）。</li>
<li>另一个是，有效位（Valid bit），它是用来标记对应的 CPU Line 中的数据是否是有效的，如果有效位是 0，无论 CPU Line 中是否有数据，CPU 都会直接访问内存，重新加载数据。</li>
</ul>
<p>CPU 在从 CPU Cache 读取数据的时候，并不是读取 CPU Line 中的整个数据块，而是读取 CPU 所需要的一个数据片段，这样的数据统称为一个<strong>字（Word）</strong>。那怎么在对应的 CPU Line 中数据块中找到所需的字呢？答案是，需要一个<strong>偏移量（Offset</strong>）。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1658298145573-904b801f-6e1f-44ee-b59b-b53f4f63bc48.png#averageHue=%23f9f7f6&clientId=ubfdf34e8-a15a-4&from=paste&id=ud610a3c5&originHeight=827&originWidth=1209&originalType=url&ratio=1&rotation=0&showTitle=false&size=279568&status=done&style=none&taskId=u746e556f-eef0-4903-ac23-37d5265c3af&title=" alt="image.png"></p>
<p>因此，一个内存的访问地址，包括<strong>组标记、CPU Cache Line 索引、偏移量</strong>这三种信息，于是 CPU 就能通过这些信息，在 CPU Cache 中找到缓存的数据。而对于 CPU Cache 里的数据结构，则是由<strong>索引 + 有效位 + 组标记 + 数据块</strong>组成。</p>
<h4 id="读取步骤"><a href="#读取步骤" class="headerlink" title="读取步骤"></a>读取步骤</h4><ol>
<li>根据内存地址中索引信息，计算在 CPU Cahe 中的索引，也就是找出对应的 CPU Cache Line 的地址；</li>
<li>找到对应 CPU Cache Line 后，判断 CPU Cache Line 中的有效位，确认 CPU Cache Line 中数据是否是有效的，如果是无效的，CPU 就会直接访问内存，并重新加载数据，如果数据有效，则往下执行；</li>
<li>对比内存地址中组标记和 CPU Cache Line 中的组标记，确认 CPU Cache Line 中的数据是我们要访问的内存数据，如果不是的话，CPU 就会直接访问内存，并重新加载数据，如果是的话，则往下执行；</li>
<li>根据内存地址中偏移量信息，从 CPU Cache Line 的数据块中，读取对应的字。</li>
</ol>
<p><strong>由于cpu cache的速度远大于内存，所以我们如果提升cpu cache的命中率，自然也就会加快代码的执行效率。</strong></p>
<h3 id="cpu数据写入"><a href="#cpu数据写入" class="headerlink" title="cpu数据写入"></a>cpu数据写入</h3><p>数据不光是只有读操作，还有写操作，那么如果数据写入 Cache 之后，内存与 Cache 相对应的数据将会不同，问题来了，那在什么时机才把 Cache 中的数据写回到内存呢？</p>
<p><strong>写直达:</strong><br>保持内存与 Cache 一致性最简单的方式是，把数据同时写入内存和 Cache 中，这种方法称为写直达,但是这样写操作将会花费大量的时间，无疑性能会受到很大的影响。</p>
<p><strong>写回:</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1658308476019-c4ccab4d-cf1d-4d11-abe3-cdb75735ade9.png#averageHue=%23dee9b8&clientId=ubfdf34e8-a15a-4&from=paste&height=465&id=uaa97b55d&originHeight=697&originWidth=1037&originalType=binary&ratio=1&rotation=0&showTitle=false&size=236916&status=done&style=none&taskId=u4c7a2722-0e9b-4c52-93f1-703a09ff674&title=&width=691.3333333333334" alt="image.png"><br>在写回机制中，当发生写操作时，新的数据仅仅被写入 Cache Block 里，只有当修改过的 Cache Block「被替换」时才需要写到内存中，减少了数据写回内存的频率，这样便可以提高系统的性能。<br><code>意思就是一般情况数据只写入cacheBlock，并把数据标记为脏，(表示和内存不一致)，但是当需要写入的数据不在cpu cache里面，就需要定位到需要写入的数据的Cache block(数据块)位置，如果位置上已有其他数据，就需要判断数据是否为脏的，如果为脏的就要先将该数据写回内存，然后在将要新写入的数据写入到cache block，并且标记为脏。</code></p>
<h3 id="cpu缓存一致性"><a href="#cpu缓存一致性" class="headerlink" title="cpu缓存一致性"></a>cpu缓存一致性</h3><p>cpu多核的情况，	L1 L2 cache是各个核心独有的，那么会带来多核心的缓存一致性（Cache Coherence） 的问题<br>当不同核心操作同一个数据时，如果使用的写回策略，就有可能核心之间数据不一致</p>
<p>举例，两个核心A、B操作内存中数字i&#x3D;0  A核心执行了i++，如果使用了写回策略，此时只有A核心L1&#x2F;L2 cache中的数据为1 并标记为脏。B核心读取的时候 读到的将会是错误的值。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>第一点，某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为写传播（Write Propagation）；<br>第二点，某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为事务的串行化（Transaction Serialization）。<br>要实现事务串行化，要做到 2 点：</p>
<ul>
<li>CPU 核心对于 Cache 中数据的操作，需要同步给其他 CPU 核心；</li>
<li>要引入「锁」的概念，如果两个 CPU 核心里有相同数据的 Cache，那么对于这个 Cache 数据的更新，只有拿到了「锁」，才能进行对应的数据更新。</li>
</ul>
<h5 id="总线嗅探"><a href="#总线嗅探" class="headerlink" title="总线嗅探"></a>总线嗅探</h5><p>当 A 号 CPU 核心修改了 L1 Cache 中 i 变量的值，通过总线把这个事件广播通知给其他所有的核心，然后每个 CPU 核心都会监听总线上的广播事件，并检查是否有相同的数据在自己的 L1 Cache 里面，如果 B 号 CPU 核心的 L1 Cache 中有该数据，那么也需要把该数据更新到自己的 L1 Cache。<br>可以发现，总线嗅探方法很简单， CPU 需要每时每刻监听总线上的一切活动，但是不管别的核心的 Cache 是否缓存相同的数据，都需要发出一个广播事件，这无疑会加重总线的负载。<br>另外，总线嗅探只是保证了某个 CPU 核心的 Cache 更新数据这个事件能被其他 CPU 核心知道，但是并不能保证事务串行化。<br>于是，有一个协议基于总线嗅探机制实现了事务串行化，也用状态机机制降低了总线带宽压力，这个协议就是 MESI 协议，这个协议就做到了 CPU 缓存一致性。</p>
<h5 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h5><p>MESI 协议其实是 4 个状态单词的开头字母缩写，分别是：<br><strong>Modified</strong>，已修改<br><strong>Exclusive</strong>，独占<br><strong>Shared</strong>，共享<br><strong>Invalidated</strong>，已失效</p>
<p>我们举个具体的例子来看看这四个状态的转换：</p>
<ol>
<li>当 A 号 CPU 核心从内存读取变量 i 的值，数据被缓存在 A 号 CPU 核心自己的 Cache 里面，此时其他 CPU 核心的 Cache 没有缓存该数据，于是标记 Cache Line 状态为「独占」，此时其 Cache 中的数据与内存是一致的；</li>
<li>然后 B 号 CPU 核心也从内存读取了变量 i 的值，此时会发送消息给其他 CPU 核心，由于 A 号 CPU 核心已经缓存了该数据，所以会把数据返回给 B 号 CPU 核心。在这个时候， A 和 B 核心缓存了相同的数据，Cache Line 的状态就会变成「共享」，并且其 Cache 中的数据与内存也是一致的；</li>
<li>当 A 号 CPU 核心要修改 Cache 中 i 变量的值，发现数据对应的 Cache Line 的状态是共享状态，则要向所有的其他 CPU 核心广播一个请求，要求先把其他核心的 Cache 中对应的 Cache Line 标记为「无效」状态，然后 A 号 CPU 核心才更新 Cache 里面的数据，同时标记 Cache Line 为「已修改」状态，此时 Cache 中的数据就与内存不一致了。</li>
<li>如果 A 号 CPU 核心「继续」修改 Cache 中 i 变量的值，由于此时的 Cache Line 是「已修改」状态，因此不需要给其他 CPU 核心发送消息，直接更新数据即可。</li>
<li>如果 A 号 CPU 核心的 Cache 里的 i 变量对应的 Cache Line 要被「替换」，发现 Cache Line 状态是「已修改」状态，就会在替换前先把数据同步到内存。</li>
</ol>
<p>所以，可以发现当 Cache Line 状态是「已修改」或者「独占」状态时，修改更新其数据不需要发送广播给其他 CPU 核心，这在一定程度上减少了总线带宽压力。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1660720641311-25f33404-4b50-4eca-bf25-04a66dc682bb.png#averageHue=%23ecd9bc&clientId=u6937f787-0bc4-4&from=paste&id=uce9f7eec&originHeight=1697&originWidth=872&originalType=url&ratio=1&rotation=0&showTitle=false&size=1084042&status=done&style=none&taskId=uab5b8a5e-0cda-479f-a122-764a41ffdf5&title=" alt="image.png"></p>
<h3 id="CPU伪共享问题"><a href="#CPU伪共享问题" class="headerlink" title="CPU伪共享问题"></a>CPU伪共享问题</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1660720851351-d9310ac5-d4c7-4d71-830c-6ebad8a4a136.png#averageHue=%23f7f7f1&clientId=u6937f787-0bc4-4&from=paste&id=u6246a0be&originHeight=669&originWidth=1037&originalType=url&ratio=1&rotation=0&showTitle=false&size=124882&status=done&style=none&taskId=uc22f8e9c-5b8c-4727-94fb-31b47cb7076&title=" alt="image.png"><br>现在假设有一个双核心的 CPU，这两个 CPU 核心并行运行着两个不同的线程，它们同时从内存中读取两个不同的数据，分别是类型为 long 的变量 A 和 B，这个两个数据的地址在物理内存上是连续的，如果 Cahce Line 的大小是 64 字节，并且变量 A 在 Cahce Line 的开头位置，那么这两个数据是位于同一个 Cache Line 中，又因为 CPU Line 是 CPU 从内存读取数据到 Cache 的单位，所以这两个数据会被同时读入到了两个 CPU 核心中各自 Cache 中。<br>假设 1 号核心绑定了线程 A，2 号核心绑定了线程 B，线程 A 只会读写变量 A，线程 B 只会读写变量 B。</p>
<p>1 号核心读取变量 A，由于 CPU 从内存读取数据到 Cache 的单位是 Cache Line，也正好变量 A 和 变量 B 的数据归属于同一个 Cache Line，所以 A 和 B 的数据都会被加载到 Cache，并将此 Cache Line 标记为「独占」状态。</p>
<p>接着，2 号核心开始从内存里读取变量 B，同样的也是读取 Cache Line 大小的数据到 Cache 中，此 Cache Line 中的数据也包含了变量 A 和 变量 B，此时 1 号和 2 号核心的 Cache Line 状态变为「共享」状态。</p>
<p>1 号核心需要修改变量 A，发现此 Cache Line 的状态是「共享」状态，所以先需要通过总线发送消息给 2 号核心，通知 2 号核心把 Cache 中对应的 Cache Line 标记为「已失效」状态，然后 1 号核心对应的 Cache Line 状态变成「已修改」状态，并且修改变量 A。</p>
<p>之后，2 号核心需要修改变量 B，此时 2 号核心的 Cache 中对应的 Cache Line 是已失效状态，另外由于 1 号核心的 Cache 也有此相同的数据，且状态为「已修改」状态，所以要先把 1 号核心的 Cache 对应的 Cache Line 写回到内存，然后 2 号核心再从内存读取 Cache Line 大小的数据到 Cache 中，最后把变量 B 修改到 2 号核心的 Cache 中，并将状态标记为「已修改」状态。</p>
<p>所以，可以发现如果 1 号和 2 号 CPU 核心这样持续交替的分别修改变量 A 和 B，就会重复最后两个步骤，Cache 并没有起到缓存的效果，虽然变量 A 和 B 之间其实并没有任何的关系，但是因为同时归属于一个 Cache Line ，这个 Cache Line 中的任意数据被修改后，都会相互影响，从而出现一直重复最后两个步骤。<br>因此，这种因为多个线程同时读写同一个 Cache Line 的不同变量时，而导致 CPU Cache 失效的现象称为伪共享（False Sharing）。</p>
<h3 id="CPU如何选择线程"><a href="#CPU如何选择线程" class="headerlink" title="CPU如何选择线程"></a>CPU如何选择线程</h3><h3 id="CPU密集型和IO密集型"><a href="#CPU密集型和IO密集型" class="headerlink" title="CPU密集型和IO密集型"></a>CPU密集型和IO密集型</h3><p><strong>为什么有时候线程数超过CPU内核数会更快呢？</strong><br>**CPU密集型 **<br>       CPU密集型会消耗掉大量的CPU资源，例如需要大量的计算，一些复杂运算，逻辑处理之类的。这个时候CPU就卯足了劲在运行，这个时候切换线程，反而浪费了切换的时间，效率不高。<br>       就像你的大脑是CPU，你本来就在一本心思地写作业，多线程这时候就是要你写会作业，然后立刻敲一会代码，然后在P个图，然后在看个视频，然后再切换回作业。emmmm，过程中你还需要切换（收起来作业，拿出电脑，打开VS…）那你的作业怕是要写到挂科。。。这个时候不太适合使用多线程，你就该一门心思地写作业~</p>
<p><strong>IO密集型</strong><br>    涉及到网络、磁盘IO的都是IO密集型，这个时候CPU利用率并不高，这个时候适合使用多线程。<br>    同样以你的大脑为例，IO密集型就是“不烧脑”的工作。例如你需要陪小姐姐或者小哥哥聊天，还需要下载一个VS，还需要看我（黑哥）的博客。这个时候如果使用多线程的话会怎么做？<br>     咦？小哥哥（小姐姐）给你发消息了，回一下TA，然后呢？TA给你回消息肯定需要时间，这个时候你就可以搜索VS的网站，先下安装包，然后一看，哎呦，TA还没给你回消息，然后看会你黑哥的博客。小哥哥（小姐姐）终于回你了，你回一下TA，接着看我的博客，这就是类似于IO密集型。你可以在不同的“不烧脑”的工作之间切换，来达到更高的效率。而不是小姐姐不回我的信息，我就干等，啥都不干，就等，这个效率可想而知，也许，小姐姐（小哥哥）根本就不会回复你~</p>
<p>高并发、任务执行时间短的业务，CPU密集型的，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换。</p>
<p>并发不高、任务执行时间长的业务这就需要区分开看了：<br>a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以适当加大线程池中的线程数目，让CPU处理更多的业务<br>b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换<br>（其实从一二可以看出无论并发高不高，对于业务中是否是cou密集还是I&#x2F;O密集的判断都是需要的当前前提是你需要优化性能的前提下）</p>
<p>3：并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，可以引入三方中间件进行异步操作。</p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><h3 id="中断是什么"><a href="#中断是什么" class="headerlink" title="中断是什么"></a>中断是什么</h3><p>中断是一种异步的事件处理机制，可以提高系统的并发处理能力。<br>操作系统收到了中断请求，会打断其他进程的运行，<strong>所以中断请求的响应程序，也就是中断处理程序，要尽可能快的执行完，这样可以减少对正常进程运行调度地影响</strong>。<br><code>打游戏点了个外卖，外卖员电话来，对应着中断请求，接电话表示中断响应程序。</code><a target="_blank" rel="noopener" href="https://blog.csdn.net/S1amDuncan/article/details/95788892">
</a><br>而且，中断处理程序在响应中断时，可能还会「<strong>临时关闭中断</strong>」，这意味着，如果当前中断处理程序没有执行完之前，系统中其他的中断请求都无法被响应，也就说中断有可能会丢失，所以中断处理程序要短且快。(中断过程中，不会响应其他中断请求)<br><code>如果有两个外卖员，第一个外卖员的电话时间过程，第二个外卖员打过来在通话中，自然无法打通。</code><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012538947/article/details/120838316">
</a></p>
<h3 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h3><p>Linux 系统为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段，分别是「上半部和下半部分」。</p>
<p>上半部用来快速处理中断，一般会暂时关闭中断请求，主要负责处理跟硬件紧密相关或者时间敏感的事情。<br>下半部用来延迟处理上半部未完成的工作，一般以「内核线程」的方式运行。<br><code>第一个配送员长时间跟我通话，则导致第二位配送员无法拨通我的电话，其实当我接到第一位配送员的电话，可以告诉配送员说我现在下楼，剩下的事情，等我们见面再说（上半部），然后就可以挂断电话，到楼下后，在拿外卖，以及跟配送员说其他的事情（下半部）</code></p>
<p>比如网卡接受网络包，网卡收到网络包后，会通过硬件中断通知内核有新的数据到了，于是内核就会调用对应的中断处理程序来响应该事件，这个事件的处理也是会分成上半部和下半部。<br>上部分要做到快速处理，所以只要把网卡的数据读到内存中，然后更新一下硬件寄存器的状态，比如把状态更新为表示数据已经读到内存中的状态值。<br>接着，内核会触发一个软中断，把一些处理比较耗时且复杂的事情，交给「软中断处理程序」去做，也就是中断的下半部，其主要是需要从内存中找到网络数据，再按照网络协议栈，对网络数据进行逐层解析和处理，最后把数据送给应用程序。</p>
<ul>
<li><strong>上半部直接处理硬件请求，也就是硬中断</strong>，主要是负责耗时短的工作，特点是快速执行；</li>
<li><strong>下半部是由内核触发，也就说软中断</strong>，主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行；</li>
</ul>
<h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012637358/article/details/87792272">https://blog.csdn.net/u012637358/article/details/87792272</a>	<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Abner_G/article/details/120523234?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-120523234-blog-121526526.pc_relevant_multi_platform_whitelistv3&spm=1001.2101.3001.4242.1&utm_relevant_index=3">https://blog.csdn.net/Abner_G&#x2F;article&#x2F;details&#x2F;120523234?utm_medium&#x3D;distribute.pc_relevant.none-task-blog-2<del>default</del>baidujs_baidulandingword~default-0-120523234-blog-121526526.pc_relevant_multi_platform_whitelistv3&amp;spm&#x3D;1001.2101.3001.4242.1&amp;utm_relevant_index&#x3D;3</a></p>
<h1 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h1><h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1660747005578-8d3dd2f5-0664-44df-bab3-b46bb3c3dca2.png#averageHue=%2368f0ac&clientId=uf26dec86-65d0-4&from=paste&id=ub8c4f098&originHeight=1011&originWidth=1280&originalType=url&ratio=1&rotation=0&showTitle=false&size=200108&status=done&style=none&taskId=ub268530e-d7fb-49a0-bce0-f6b7c4525be&title=" alt="image.png">计算机是由各种外部硬件设备组成的，比如内存、cpu、硬盘等，如果每个应用都要和这些硬件设备对接通信协议，那这样太累了，所以这个中间人就由内核来负责，让内核作为应用连接硬件设备的桥梁，应用程序只需关心与内核交互，不用关心硬件的细节。</p>
<p>现代操作系统，内核一般会提供 4 个基本能力：</p>
<ul>
<li>管理进程、线程，决定哪个进程、线程使用 CPU，也就是进程调度的能力；</li>
<li>管理内存，决定内存的分配和回收，也就是内存管理的能力；</li>
<li>管理硬件设备，为进程与硬件设备之间提供通信能力，也就是硬件通信能力；</li>
<li>提供系统调用，如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口。</li>
</ul>
<p>内核具有很高的权限，可以控制 cpu、内存、硬盘等硬件，而应用程序具有的权限很小，因此大多数操作系统，把内存分成了两个区域：<br>内核空间，这个内存空间只有内核程序可以访问；<br>用户空间，这个内存空间专门给应用程序使用；、</p>
<p>用户空间的代码只能访问一个局部的内存空间，而内核空间的代码可以访问所有内存空间。因此，当程序使用用户空间时，我们常说该程序在<strong>用户态</strong>执行，而当程序使内核空间时，程序则在<strong>内核态</strong>执行。</p>
<p>应用程序如果需要进入内核空间，就需要通过系统调用，下面来看看系统调用的过程：<img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1660748894106-bfc6fe82-53ca-4a90-a90e-f1edf5fee770.png#averageHue=%23fcfbfb&clientId=uf26dec86-65d0-4&from=paste&id=u87b02586&originHeight=332&originWidth=1053&originalType=url&ratio=1&rotation=0&showTitle=false&size=99668&status=done&style=none&taskId=ufd44be13-bfc4-49fb-afcd-9530fc89a4c&title=" alt="image.png"></p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>如果两个程序都直接使用物理地址，第一个程序在 2000 的位置写入一个新的值，将会擦掉第二个程序存放在相同位置上的所有内容，所以同时运行两个程序是根本行不通的，这两个程序会立刻崩溃。<br>所以需要避免直接使用物理地址，即让操作系统为每个进程分配独立的一套「虚拟地址」，人人都有，大家自己玩自己的地址就行，互不干涉。但是有个前提每个进程都不能访问物理地址，至于虚拟地址最终怎么落到物理内存里，对进程来说是透明的，操作系统已经把这些都安排的明明白白了。</p>
<p><strong>我们程序所使用的内存地址叫做虚拟内存地址（Virtual Memory Address）</strong><br><strong>实际存在硬件里面的空间地址叫物理内存地址（Physical Memory Address）</strong></p>
<p>进程持有的虚拟地址会通过 CPU 芯片中的<strong>内存管理单元（MMU</strong>）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661266836460-57292f63-aef0-4797-9313-5bc573ac2f2a.png#averageHue=%23f9f6ee&clientId=uc2fcb605-deac-4&from=paste&id=u2729d287&originHeight=539&originWidth=831&originalType=url&ratio=1&rotation=0&showTitle=false&size=45087&status=done&style=none&taskId=u3e602bb8-6d8c-4355-a4bc-4e44db23c2d&title=" alt="image.png"><br>主要通过内存分段和内存分页两种方式来转换物理地址。</p>
<h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661266907308-38c2ea49-41f8-4490-8ace-cf07effc459c.png#averageHue=%23f8e3aa&clientId=uc2fcb605-deac-4&from=paste&id=u3c2b48f3&originHeight=1004&originWidth=1382&originalType=url&ratio=1&rotation=0&showTitle=false&size=100068&status=done&style=none&taskId=u06e15ff3-97a0-432a-bbbc-164048024da&title=" alt="image.png"><br>虚拟地址由两部分组成，<strong>段选择因子和段内偏移量</strong>。</p>
<p>段号即为段表的索引，通过段号确定段表中对应的的位置。<br>段内偏移量位于0到段界限之间。如果段内偏移量是合法的，就将<strong>段基地址加上段内偏移量</strong>得到物理内存地址。</p>
<p>分段机制会把程序的虚拟地址分成4个段，每个段都对应了段表中的一个项，从而可以找到物理地址。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661267194343-ea2bfb69-d05a-4c3a-a577-7d2be3e9cff4.png#averageHue=%23f7ede3&clientId=uc2fcb605-deac-4&from=paste&id=ud65df96a&originHeight=651&originWidth=1055&originalType=url&ratio=1&rotation=0&showTitle=false&size=91801&status=done&style=none&taskId=uf33e17f5-0d50-46e6-b4cb-77257143b50&title=" alt="image.png">如果要访问段 3 中偏移量 500 的虚拟地址，我们可以计算出物理地址为，段 3 基地址 7000 + 偏移量 500 &#x3D; 7500</p>
<p><strong>缺点</strong><br>第一个就是<strong>内存碎片</strong>的问题。<br>第二个就是<strong>内存交换的效率低</strong>的问题。</p>
<h4 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h4><p>内存碎片主要分为，内部内存碎片和外部内存碎片。<br>内存分段管理可以做到段根据实际需求分配内存，所以有多少需求就分配多大的段，所以<strong>不会出现内部内存碎片（分配的内存没有用完）</strong>。</p>
<p>但是由于每个段的长度不固定，所以多个段未必能恰好使用所有的内存空间，会产生了多个不连续的小物理内存，导致新的程序无法被装载，所以会出现<strong>外部内存碎片</strong>的问题。</p>
<p>我们来看看这样一个例子。假设有 1G 的物理内存，用户执行了多个程序，其中：<br>游戏占用了 512MB 内存<br>浏览器占用了 128MB 内存<br>音乐占用了 256 MB 内存。<br>这个时候，如果我们关闭了浏览器，则空闲内存还有 1024 - 512 - 256 &#x3D; 256MB。<br>如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661267331680-742ae639-9027-4061-a3ea-88745550bc1a.png#averageHue=%23f7f3ee&clientId=uc2fcb605-deac-4&from=paste&id=u5b4cb3cc&originHeight=806&originWidth=1518&originalType=url&ratio=1&rotation=0&showTitle=false&size=256996&status=done&style=none&taskId=u3c618a8a-6443-4be0-91a2-f9ddc6de788&title=" alt="image.png"></p>
<p><strong>解决方案：</strong><br><strong>内存交换：</strong><br>可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。</p>
<p>因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。<br>所以，如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。<br>为了解决内存分段的「外部内存碎片和内存交换效率低」的问题，就出现了内存分页。</p>
<h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><p>虚拟地址（比如 16 位地址 8196&#x3D;0010 000000000100）分为两部分：<strong>虚拟页号</strong>（Virtual Page Number，简称 VPN，这里是<strong>高 4 位</strong>部分）和<strong>偏移量</strong>（Virtual Page Offset，简称 VPO，这里是<strong>低 12 位</strong>部分），虚拟地址转换成物理地址是通过<strong>页表（page table</strong>）来实现的。页表由多个<strong>页表项（Page Table Entry, 简称 PTE）</strong>组成，一般页表项中都会存储物理<strong>页框号、修改位、访问位、保护位和 “在&#x2F;不在” 位（有效位）等</strong>信息。</p>
<p>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，这就是页（Page）。在 Linux 下，每一页的大小为 4KB。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661267823290-269606a3-79f9-48b3-b777-ce445feb3393.png#averageHue=%23a6a896&clientId=uc2fcb605-deac-4&from=paste&id=uec7f2852&originHeight=561&originWidth=935&originalType=url&ratio=1&rotation=0&showTitle=false&size=67937&status=done&style=none&taskId=u67018518-9ee7-4429-89a5-5dad70ffd54&title=" alt="image.png"></p>
<p>页表是存储在内存里的<strong>，内存管理单元 （MMU</strong>）就做将虚拟内存地址转换成物理地址的工作<br><strong>转换过程：</strong></p>
<ul>
<li><strong>第 1 步</strong>：处理器生成一个虚拟地址 VA，通过总线发送到 MMU；</li>
<li><strong>第 2 步</strong>：MMU 通过虚拟页号得到页表项的地址 PTEA，通过内存总线从 CPU 高速缓存&#x2F;主存读取这个页表项 PTE；</li>
<li><strong>第 3 步</strong>：CPU 高速缓存或者主存通过内存总线向 MMU 返回页表项 PTE；</li>
<li><strong>第 4 步</strong>：MMU 先把页表项中的物理页框号 PPN 复制到寄存器的高三位中，接着把 12 位的偏移量 VPO 复制到寄存器的末 12 位构成 15 位的物理地址，即可以把该寄存器存储的物理内存地址 PA 发送到内存总线，访问高速缓存&#x2F;主存；</li>
<li><strong>第 5 步</strong>：CPU 高速缓存&#x2F;主存返回该物理地址对应的数据给处理器。</li>
</ul>
<p>在 MMU 进行地址转换时，如果页表项的有效位是 0，则表示该页面并没有映射到真实的物理页框号 PPN，则会引发一个<strong>缺页中断。</strong>此时进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p>
<p>操作系统会通过<strong>页面置换算法</strong>选择一个页面将其<strong>换出</strong> (swap)，以便为即将调入的新页面腾出位置，如果要换出的页面的页表项里的修改位已经被设置过，也就是被更新过，则这是一个<strong>脏页</strong> (Dirty Page)，需要写回磁盘更新该页面在磁盘上的副本，如果该页面是”干净”的，也就是没有被修改过，则直接用调入的新页面覆盖掉被换出的旧页面即可。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。</p>
<p>因为采用了分页，页与页之间是紧密排列的，所以不会有外部碎片。</p>
<p>因为内存分页机制分配内存的最小单位是一页，即使程序不足一页大小，我们最少只能分配一个页，所以页内会出现内存浪费，所以针对内存分页机制会有内部内存碎片的现象。</p>
<p>在分页机制下，虚拟地址分为两部分，<strong>页号和页内偏移。</strong>页号作为页表的索引，<strong>页表包含物理页每页所在物理内存的基地址</strong>，这个基地址与页内偏移的组合就形成了物理内存地址，见下图。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661268723377-9aed58b5-03cf-4282-9637-95cb265b6062.png#averageHue=%23faf8f4&clientId=uc2fcb605-deac-4&from=paste&id=ua7b8e6f4&originHeight=797&originWidth=1067&originalType=url&ratio=1&rotation=0&showTitle=false&size=65731&status=done&style=none&taskId=u5a6f4374-9698-44b3-b2c8-900aa8afc72&title=" alt="image.png"><br>总结一下，对于一个内存地址转换，其实就是这样三个步骤：</p>
<ul>
<li>把虚拟内存地址，切分成页号和偏移量；</li>
<li>根据页号，从页表里面，查询对应的物理页号；</li>
<li>直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。</li>
</ul>
<p><code>通常来说，大多数系统都会选择利用物理内存地址去访问高速缓存，因为高速缓存相比于主存要小得多，所以使用物理寻址也不会太复杂；另外也因为高速缓存容量很小，所以系统需要尽量在多个进程之间共享数据块，而使用物理地址能够使得多进程同时在高速缓存中存储数据块以及共享来自相同虚拟内存页的数据块变得更加直观。</code></p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>因为操作系统是可以同时运行非常多的进程的，那这不就意味着页表会非常的庞大。<br>在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 4MB 的内存来存储页表。<br>这 4MB 大小的页表，看起来也不是很大。但是要知道每个进程都是有自己的虚拟地址空间的，也就说都有自己的页表。<br>那么，100 个进程的话，就需要 400MB 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了</p>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>我们把这个 100 多万个「页表项」的单级页表再分页，将页表（一级页表）分为 1024 个页表（二级页表），每个表（二级页表）中包含 1024 个「页表项」，形成二级分页。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661269765882-fb61b2ae-cc13-4a78-9d4b-bf29a7ddfa2c.png#averageHue=%23f7f3f1&clientId=uc2fcb605-deac-4&from=paste&id=ufef493e6&originHeight=1146&originWidth=1686&originalType=url&ratio=1&rotation=0&showTitle=false&size=218062&status=done&style=none&taskId=u183f9759-4ecb-47a4-a9a4-7aeab8c3336&title=" alt="image.png"><br>一级页号找到一级页表上的页号，对应到二级页表的地址，通过二级页号，找到该二级页表上最终的物理页号，加上偏移量得到最终的物理地址。</p>
<p>似乎页表项并没有减少，而且还多了4kb的一级页表。<br>当然如果 4GB 的虚拟地址全部都映射到了物理内存上的话，二级分页占用空间确实是更大了，但是，我们往往不会为一个进程分配那么多内存。</p>
<p>每个进程都有 4GB 的虚拟地址空间，而显然对于大多数程序来说，其使用到的空间远未达到 4GB，因为会存在部分对应的页表项都是空的，根本没有分配，对于已分配的页表项，如果存在最近一定时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，也就是说不会占用物理内存。</p>
<p>如果使用了二级分页，一级页表就可以覆盖整个 4GB 虚拟地址空间，<strong>但如果某个一级页表的页表项没有被用到</strong>，<strong>也就不需要创建这个页表项对应的二级页表	了</strong>，即可以在需要时才创建二级页表。做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 <strong>4KB（一级页表） + 20% * 4MB（二级页表）&#x3D; 0.804MB</strong>，这对比单级页表的 4MB 是不是一个巨大的节约？</p>
<p>因为每个虚拟地址都必须在页表中找到对应的页表项才行，不分级的页表是必须一开始就创建好整个页表的，才能全部对应上，而分级页表的一级页表，1024个页表项就覆盖了整个虚拟地址，需要的时候才会创建二级页表。</p>
<p>我们把二级分页再推广到多级页表，就会发现页表占用的内存空间更少了。</p>
<p>对于 64 位的系统，两级分页肯定不够了，就变成了四级目录，分别是：</p>
<ul>
<li>全局页目录项 PGD（Page Global Directory）；</li>
<li>上层页目录项 PUD（Page Upper Directory）；</li>
<li>中间页目录项 PMD（Page Middle Directory）；</li>
<li>页表项 PTE（Page Table Entry）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661270315954-971fbc12-a035-41fe-97dd-355e8889172a.png#averageHue=%23fcfaf7&clientId=uc2fcb605-deac-4&from=paste&id=ue7f84328&originHeight=1427&originWidth=1931&originalType=url&ratio=1&rotation=0&showTitle=false&size=304099&status=done&style=none&taskId=u778774b7-af29-4176-be8a-23e6e7a9623&title=" alt="image.png"></p>
<h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><p>多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了时间上的开销。<br>程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。<br><strong>我们就可以利用这一特性，把最常访问的几个页表项存储到访问速度更快的硬件。</strong>TLB 可以简单地理解成页表的高速缓存。</p>
<p>所以就出现了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB,通常称为页表缓存、<strong>快表。</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661270506591-c69dcacb-2495-46d8-9404-f61eef7a6adc.png#averageHue=%23f8f5ea&clientId=uc2fcb605-deac-4&from=paste&id=u5452a73f&originHeight=509&originWidth=1008&originalType=url&ratio=1&rotation=0&showTitle=false&size=45194&status=done&style=none&taskId=u2717e7cf-90ea-4885-841a-202db92b3e3&title=" alt="image.png"><br>有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。</p>
<h3 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h3><p>内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为<strong>段页式内存管理</strong>。</p>
<p>段页式内存管理实现的方式：</p>
<ul>
<li>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；</li>
<li>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；</li>
</ul>
<p>这样，地址结构就由<strong>段号、段内页号和页内位移</strong>三部分组成。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661270804782-56609b02-6bf5-4417-a61c-d1e4172a0889.png#averageHue=%23f5eddc&clientId=uc2fcb605-deac-4&from=paste&id=ubdf18997&originHeight=699&originWidth=1452&originalType=url&ratio=1&rotation=0&showTitle=true&size=120443&status=done&style=none&taskId=u8e3ecc75-b344-4b05-a89c-72400a9a256&title=%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%AF%B9%E5%BA%94%E4%B8%80%E4%B8%AA%E6%AE%B5%E8%A1%A8" alt="一个程序对应一个段表" title="一个程序对应一个段表"></p>
<p>段页式地址变换中要得到物理地址须经过三次内存访问：</p>
<ol>
<li>第一次访问段表，得到页表起始地址；</li>
<li>第二次访问页表，得到物理页号；</li>
<li>第三次将物理页号与页内位移组合，得到物理地址。</li>
</ol>
<h3 id="CPU数据读取流程总结"><a href="#CPU数据读取流程总结" class="headerlink" title="CPU数据读取流程总结"></a>CPU数据读取流程总结</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1662022764354-e7684e53-bbfe-414d-bd27-2169f29e9e69.png#averageHue=%23f8f7f6&clientId=ub403381c-2d8f-4&from=paste&id=ucfa33393&originHeight=507&originWidth=738&originalType=url&ratio=1&rotation=0&showTitle=false&size=51720&status=done&style=none&taskId=uc5e528e9-2cd0-4350-95e3-8abb51a0a92&title=" alt="image.png"></p>
<ol>
<li><p>CPU要根据用户进程提供的虚拟地址来获取真实数据，但是它并不自己做而是交给了MMU。</p>
</li>
<li><p>MMU也是个聪明的家伙，集成了TLB来存储CPU最近常用的页表项来加速寻址，TLB找不到再去全量页表寻址，可以认为TLB是MMU的缓存。</p>
</li>
<li><p>TLB的容量毕竟有限，为此必须依靠Page Table一起完成TLB Miss情况的查询，并且更新到TLB建立新映射关系</p>
</li>
</ol>
<h2 id="惰性分配"><a href="#惰性分配" class="headerlink" title="惰性分配"></a>惰性分配</h2><h3 id="程序的局部性原理"><a href="#程序的局部性原理" class="headerlink" title="程序的局部性原理"></a>程序的局部性原理</h3><p>程序的局部性原理是指程序在执行时呈现出局部性规律，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。<br>局部性原理又表现为：时间局部性和空间局部性。时间局部性是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问。空间局部性是指一旦程序访问了某个存储单元，则不久之后，其附近的存储单元也将被访问。</p>
<p>以32位的Linux系统为例，每个进程独立拥有4GB的虚拟地址空间，根据局部性原理没有必要也不可能为每个进程分配4GB的物理地址空间。</p>
<p>所以实际上操作系统分配虚拟内存时，虚拟内存如果没有被访问的话，虚拟内存是不会映射到物理内存的，只有程序运行时用到了才去内存中寻找虚拟地址对应的页帧，找不到才可能进行分配，这就是内存的惰性(延时)分配机制(会触发缺页异常）。</p>
<p>对于一个运行中的进程来说，不是所有的虚拟地址在物理内存中都有对应的页。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1662022234073-57c97716-ad91-4abb-86bf-ce1210d3c755.png#averageHue=%23f8f5f2&clientId=ub403381c-2d8f-4&from=paste&id=u2acd9bdf&originHeight=718&originWidth=656&originalType=url&ratio=1&rotation=0&showTitle=false&size=72347&status=done&style=none&taskId=u735c70bd-4783-4a55-9172-f8684c065db&title=" alt="image.png"></p>
<h2 id="缺页中断-PageFault"><a href="#缺页中断-PageFault" class="headerlink" title="缺页中断 PageFault"></a>缺页中断 PageFault</h2><p>假如目标内存页在物理内存中没有对应的页帧或者存在但无对应权限，CPU 就无法获取数据，这种情况下CPU就会报告一个缺页错误。<br>由于CPU没有数据就无法进行计算，CPU罢工了用户进程也就出现了缺页中断，进程会从用户态切换到内核态，并将缺页中断交给内核的 Page Fault Handler 处理。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1662022440871-22a7000c-431b-494a-a467-4fb89b4990b7.png#averageHue=%23e79545&clientId=ub403381c-2d8f-4&from=paste&id=u1bb42a54&originHeight=491&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&size=77498&status=done&style=none&taskId=ufa7a9f66-8426-4141-bff5-1882aa0cc48&title=" alt="image.png"></p>
<p>缺页中断会交给PageFaultHandler处理，其根据缺页中断的不同类型会进行不同的处理：</p>
<ul>
<li>Hard Page Fault 也被称为Major Page Fault，翻译为硬缺页错误&#x2F;主要缺页错误，这时<strong>物理内存中没有对应的页帧</strong>，**需要CPU打开磁盘设备读取到物理内存中，再让MMU建立VA和PA的映射(Swap)**。</li>
<li>Soft Page Fault 也被称为Minor Page Fault，翻译为软缺页错误&#x2F;次要缺页错误，这时<strong>物理内存中是存在对应页帧的</strong>，只不过可能是其他进程调入的，发出缺页异常的进程不知道而已，此时<strong>MMU只需要建立映射</strong>即可，无需从磁盘读取写入内存，一般出现在多进程共享内存区域。</li>
<li>Invalid Page Fault 翻译为<strong>无效缺页</strong>错误，比如进程访问的内存地址越界访问，又比如对空指针解引用内核就会报segment fault错误中断进程直接挂掉。</li>
</ul>
<p>触发Page Fault的原因可能有很多，归根到底也只有几种大类：</p>
<ol>
<li>如使用共享内存区域，没有存储VA-&gt;PA的映射但是存在物理页帧的软缺页错误，在Page Table&#x2F;TLB中建立映射关系即可。</li>
<li>访问的地址在物理内存中确实不存在，需要从磁盘&#x2F;swap分区读入才能使用，这种性能影响会比较大，因为磁盘太慢了，尽量使用高性能的SSD来降低延时。</li>
<li>访问的地址内存非法，缺页错误会升级触发SIGSEGV信号结束进程，这种属于可以导致进程挂掉的一种缺页错误。</li>
</ol>
<h2 id="swap分区"><a href="#swap分区" class="headerlink" title="swap分区"></a>swap分区</h2><p>当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到<strong>Swap空间</strong>中，等到那些程序要运行时，再从Swap中恢复保存的数据到内存中。这样，系统总是在物理内存不够时，才进行<strong>Swap交换</strong>。<br>实际上，并不是等所有的物理内存都消耗完毕之后，才去使用swap的空间，什么时候使用是由<strong>swappiness</strong> 参数值控制。</p>
<p><strong>Swap 其实就是把一块磁盘空间当成内存来用</strong>。它可以把进程暂时不用的数据存储到磁盘中（这个过程称为换出，swapout），当进程访问这些内存时，再从磁盘读取这些数据到内存中（这个过程称为换入，swapin），那怎么判定内存的哪些数据是不常用数据需要换出呢，LRU,LFU等都是常用的算法。当物理内存紧张的情况下，当进程访自己已申请的内存地址时，操作系统发现这段内存地址并不在物理内存里，此时就会发生缺页中断，根据内存置换算法选出指定页swapout到磁盘，再将马上要使用到的页swapin到内存，完成了页面的swapin和swapout。</p>
<p><strong>swap分区的大小该怎么设计呢？</strong><br>内存和swap分区的大小1：1是个不会太错的选择，比如4G的物理内存可以考虑配备4G的swap分区。</p>
<p><strong>如果物理内存远小于swap分区大小会有什么后果？</strong>这样的配备首先说明物理内存已经远不能处理进程的数据了，需要通过大量借助磁盘来扩展内存才能满足进程需求。这本来就是一个不合理的配比，这会导致内存数据块频繁地被置换到磁盘，产生大量的磁盘IO，导致系统很卡（系统性能都全消耗在缺页中断产生的磁盘IO），上面跑的进程很难得到有效调度。</p>
<p><strong>但反过来，物理内存远大于swap分区并无副作用</strong>，比如我们线上 的服务器，物理内存256G，平时活动高峰期内存也完全足够，但为了稳妥起见，我们也还是配了16G的swap分区，作为系统内存异常时的一个最后保障。一些线上服务为了保持高性能一般都会把swap关掉，比如redis。</p>
<p>swappiness的值的大小对如何使用swap分区是有着很大的联系的。swappiness&#x3D;0的时候表示最大限度使用物理内存，然后才是swap空间，swappiness＝100的时候表示积极的使用swap分区，并且把内存上的数据及时的搬运到swap空间里面。linux的基本默认设置为60。当swappines设置得比较大时，你会发现即使系统物理内存还剩余很多，但系统还是倾向于大量使用很慢的swap分区，这就导致系统很卡。但值得注意的是swappiness&#x3D;0并不表示禁用交换分区，而是指尽可能不使用交换分区，但当内存已经耗尽时也会选择使用交换分区，如果不想使用交换分区，那就不要启用swap。</p>
<p>所以一个重要的性能优化经验就是：最好禁用swap。swap应该是针对以前内存小的一种优化,如果是高性能服务，最好禁止 Swap，比如redis，mysql等服务，都是推荐禁用swap的。如果必须开启 Swap，那需要降低 swappiness 的值，减少内存回收时 Swap 的使用倾向。</p>
<h2 id="overcommit"><a href="#overcommit" class="headerlink" title="overcommit"></a>overcommit</h2><p>惰性分配会引入一个新问题：开空头支票带来的副作用，当进程真正要使用早期申请的这块内存时，系统发现系统的总的<strong>可利用的内存（物理内存+swap）</strong>已经用完了，没法兑现早期的承诺了，这就是操作系统的<strong>overcommit;</strong></p>
<p>overcommit是有参数可以调整的，overcommit对应的参数是<strong>overcommit_memory</strong>。<br>overcommit_memory是一个内核对内存分配的一种策略,它有三个可选值:0、1、2</p>
<ul>
<li>0- Heuristic overcommit handling： 这是缺省值，它允许overcommit，但<strong>过于明目张胆的overcommit会被拒绝</strong>，比如malloc一次性申请的内存大小就超过了系统总内存。Heuristic的意思是“试探式的”，内核利用某种算法猜测你的内存申请是否合理，它认为不合理就会拒绝overcommit，并把错误返回给应用进程。而在Redis中这个错误就会表现为“Cannot allocate memory”，然后触发OOM</li>
<li>1 – Always overcommit：<strong>表示内核允许超量使用内存直到用完为止</strong>，当实在是无法处理时就使用<strong>OOM killer</strong>杀进程释放内存。</li>
<li>2：<strong>在早期分配内存时,内核检查,坚决不超量使用内</strong>存，即系统整个内存空间不能超过swap+50%的RAM值(<strong>CommitLimit值</strong>)，50%是<strong>overcommit_ratio</strong>默认值，此参数支持修改。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl overcommit_ratio=60</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="OOM-killer"><a href="#OOM-killer" class="headerlink" title="OOM killer:"></a>OOM killer:</h3><p><strong>overcommit_memory设置为0&#x2F;1都会存在超配情况，</strong>当系统中<strong>可利用的内存资源</strong>已经耗尽时，有两种选择，一种是直接panic系统，然后几秒钟后LINUX自动重启,这个行为可以通过kernel.panic_on_oom参数设置<br>另外一种选择就是杀死部分进程，从而释放足够的内存来让内存问题得到解决,这就是<strong>OOM killer</strong>,该机制会杀死分数最高的进程，以求释放内存资源保证系统可以稳定运行。</p>
<p>oom killer通过<strong>oom_badness</strong>函数来找到可以杀掉的候选进程，然后直接干掉这个进程，尽快解决内存不足的问题，<strong>如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。</strong></p>
<p>而这个查找过程中，其主要依据是每个进程的<strong>oom_score</strong>，其选择的算法比较简单，总是选择oom_score比较高，同时优先级比较低的进程去杀。而oom_score在新版本的Linux内核中计算起来十分简单，就是这个进程占用的（物理内存+SWAP）的总和乘以10</p>
<p>在这个函数中，不会返回oom_score为0的进程，因此如果我们把某个进程的oom_score_adj设置为-1000（早期版本的linux oom_score的计算方法不同，因此调整adj的方法略有不同）,那么<strong>这个进程的oom_score就会永远为0，也就是说这个进程永远不会被oom killer杀死</strong>。这也是我们保护某个进程，不让oom killer杀掉的主要方法。</p>
<h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>oom killer是最后的手段，在oom killer之前还有两种回收的方式，<strong>直接内存回收和后台内存回收。</strong></p>
<ul>
<li>后台内存回收（kswapd）：在物理内存紧张的时候，会唤醒** kswapd 内核线程<strong>来回收内存，这个回收内存的过程异步的，</strong>不会阻塞进程的执行**。</li>
<li>直接内存回收（direct reclaim）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是同步的，<strong>会阻塞进程的执行</strong>。</li>
</ul>
<p>如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请，那么内核就会放最后的大招了 ——触发 OOM （Out of Memory）机制。</p>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1662081398461-d8f94216-fa21-4015-898a-f6ff5c97f906.png#averageHue=%23fcf9f7&clientId=uba07c7e4-e8c0-4&from=paste&id=u725aa4e0&originHeight=1307&originWidth=977&originalType=url&ratio=1&rotation=0&showTitle=false&size=100273&status=done&style=none&taskId=ua7c3b5f2-c4f9-495d-b6ae-9a3fa368919&title=" alt="image.png"></h4><h4 id="哪些内容可以被回收呢？"><a href="#哪些内容可以被回收呢？" class="headerlink" title="哪些内容可以被回收呢？"></a>哪些内容可以被回收呢？</h4><p><strong>文件页（File-backed Page）</strong>：内核缓存的磁盘数据（Buffer）和内核缓存的文件数据（Cache）都叫作文件页。大部分文件页，都可以直接释放内存，以后有需要时，再从磁盘重新读取就可以了。而那些被应用程序修改过，并且暂时还没写入磁盘的数据（也就是脏页），就得先写入磁盘，然后才能进行内存释放。所以，回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存。<br><strong>匿名页（Anonymous Page）</strong>：这部分内存没有实际载体，不像文件缓存有硬盘文件这样一个载体，比如堆、栈数据等。这部分内存很可能还要再次被访问，所以不能直接释放内存，它们回收的方式是通过 Linux 的 Swap 机制，Swap 会把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。</p>
<p>文件页和匿名页的回收都是基于 LRU 算法，也就是优先回收不常访问的内存。</p>
<p><strong>LRU 回收算法</strong>，实际上维护着 active 和 inactive 两个双向链表，其中：</p>
<ul>
<li>active_list 活跃内存页链表，这里存放的是最近被访问过（活跃）的内存页；</li>
<li>inactive_list 不活跃内存页链表，这里存放的是很少被访问（非活跃）的内存页；</li>
</ul>
<p>越接近链表尾部，就表示内存页越不常访问。这样，在回收内存时，系统就可以根据活跃程度，优先回收不活跃的内存。</p>
<p><strong>通过调整参数swappiness，可以控制文件页和匿名页的回收倾向</strong>，swappiness 的范围是 0-100，数值越大，越积极使用 Swap，也就是更倾向于回收匿名页；数值越小，越消极使用 Swap，也就是更倾向于回收文件页。</p>
<h2 id="malloc-动态内存分配"><a href="#malloc-动态内存分配" class="headerlink" title="malloc 动态内存分配"></a>malloc 动态内存分配</h2><p>虚拟地址空间的内部又被分为内核空间和用户空间两部分，不同位数的系统，地址空间的范围也不同。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661869911227-bc8d9799-e1a8-4b27-a856-b0b34689f5f2.png#averageHue=%23e8c199&clientId=u3a69160e-ae01-4&from=paste&height=295&id=RY05r&originHeight=442&originWidth=1166&originalType=binary&ratio=1&rotation=0&showTitle=false&size=202295&status=done&style=none&taskId=ud4f0fea1-a00d-4682-b8b4-8fc6e85a23f&title=&width=777.3333333333334" alt="image.png"></p>
<p>进程在用户态时，只能访问用户空间内存；有进入内核态后，才可以访问内核空间的内存；<br>虽然每个进程都各自有独立的虚拟内存，<strong>但是每个虚拟内存中的内核地址，其实关联的都是相同的物理内存</strong>。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661870034714-8401bb6b-b185-45c9-9068-6634b1cf53ee.png#averageHue=%23e4e7e5&clientId=u3a69160e-ae01-4&from=paste&id=rZ5dS&originHeight=426&originWidth=950&originalType=url&ratio=1&rotation=0&showTitle=false&size=166548&status=done&style=none&taskId=uc43dadf4-1067-405d-8200-6031f36756f&title=" alt="image.png"></p>
<p><strong>用户空间的分布情况:</strong></p>
<ul>
<li>程序文件段，包括二进制可执行代码；</li>
<li>已初始化数据段，包括静态常量；</li>
<li>未初始化数据段，包括未初始化的静态变量；</li>
<li>堆段，包括动态分配的内存，从低地址开始向上增长；</li>
<li>文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关 ）；</li>
<li>栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661872346985-6b053849-3975-44ba-b66b-2442e19cea01.png#averageHue=%23f5c18b&clientId=u3a69160e-ae01-4&from=paste&id=uInIy&originHeight=1324&originWidth=894&originalType=url&ratio=1&rotation=0&showTitle=false&size=244505&status=done&style=none&taskId=udb7a77e1-1b85-4830-817b-37f20923b24&title=" alt="image.png"></p>
<p>实际上，malloc() 并不是系统调用，而是 C 库里的函数，用于动态分配内存。</p>
<p><strong>malloc分配的是虚拟内存</strong></p>
<p>malloc 申请内存的时候，会有两种方式向操作系统申请堆内存。</p>
<ul>
<li>方式一：通过 brk() 系统调用从堆分配内存</li>
<li>方式二：通过 mmap() 系统调用在文件映射区域分配内存；</li>
</ul>
<p>方式一实现的方式很简单，就是通过 brk() 函数将「堆顶」指针向高地址移动，获得新的内存空间。如下图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661872564958-dc09a877-197d-44a0-b39f-d8f9ccf48326.png#averageHue=%23f3f3f1&clientId=u3a69160e-ae01-4&from=paste&id=jWZmA&originHeight=837&originWidth=1287&originalType=url&ratio=1&rotation=0&showTitle=false&size=222694&status=done&style=none&taskId=uab02453d-1fe9-45cc-96e5-5b9931466e1&title=" alt="image.png"><br>方式二通过 mmap() 系统调用中「私有匿名映射」的方式，在文件映射区分配一块内存，也就是从文件映射区“偷”了一块内存。如下图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1661872573796-719645b8-7177-46d4-9a56-8d5fd5678ddc.png#averageHue=%23f3f2f1&clientId=u3a69160e-ae01-4&from=paste&id=h4vgS&originHeight=837&originWidth=1337&originalType=url&ratio=1&rotation=0&showTitle=false&size=229560&status=done&style=none&taskId=u9dc6301c-b90f-4c57-a598-a17208b7166&title=" alt="image.png"></p>
<p>malloc() 源码里默认定义了一个阈值：</p>
<ul>
<li>如果用户分配的内存小于 128 KB，则通过 brk() 申请内存；</li>
<li>如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存；</li>
</ul>
<p><strong>malloc 通过 brk() 方式申请的内存，free 释放内存的时候，并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用</strong>；<br><strong>malloc 通过 mmap() 方式申请的内存，free 释放内存的时候，会把内存归还给操作系统，内存得到真正的释放；</strong></p>
<h2 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h2><p>内存的大小是有限的的，不可能无限的缓存数据，对于一些不经常使用的数据会在某些时机淘汰掉。linux中通常使用LRU算法实现。<br>传统的 LRU 算法的实现思路是这样的：</p>
<ul>
<li>当访问的页在内存里，就直接把该页对应的 LRU 链表节点移动到链表的头部。</li>
<li>当访问的页不在内存里，除了要把该页放入到 LRU 链表的头部，还要淘汰 LRU 链表末尾的页。</li>
</ul>
<p>这样还可以保证内存不会满，并且保证常用数据在内存中。</p>
<h2 id="预读失效和缓存污染"><a href="#预读失效和缓存污染" class="headerlink" title="预读失效和缓存污染"></a>预读失效和缓存污染</h2><h3 id="什么是预读？"><a href="#什么是预读？" class="headerlink" title="什么是预读？"></a>什么是预读？</h3><p>应用程序读取一个3kb大小的数据，磁盘的读写单位为一页4kb,此时就会读取一整页的数据，但是操作系统出于空间局部性原理（靠近当前被访问数据的数据，在未来很大概率会被访问到),于是就会将附近3页的数据都加载进内存。这样如果后面需要读取这3页的数据时，就不用从磁盘读取了，减少了磁盘io的次数，提高了io吞吐量。<br>其实mysql innodb存储引擎 buffer pool 也有类似的机制。</p>
<p><strong>如果这些被提前加载进来的页，并没有被访问，相当于这个预读工作是白做了，这个就是预读失效。</strong></p>
<h3 id="如何避免预读失效？"><a href="#如何避免预读失效？" class="headerlink" title="如何避免预读失效？"></a>如何避免预读失效？</h3><p><strong>思路：让预读页和真正被访问的页分开，并且预读页保存时间尽可能短。</strong></p>
<p><strong>linux的解决方案:</strong><br>Linux 操作系统实现两个了 LRU 链表：活跃 LRU 链表（active_list）和非活跃 LRU 链表（inactive_list）；<br><strong>预读页就只需要加入到 inactive list 区域的头部，当页被真正访问的时候，才将页插入 active list 的头部。如果预读的页一直没有被访问，就会从 inactive list 移除，这样就不会影响 active list 中的热点数据。</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1663574637403-65c9e2c3-a804-4444-b396-aac295714103.png#averageHue=%23cee2bf&clientId=uf2374c8c-772d-4&from=paste&id=u7354da57&originHeight=377&originWidth=737&originalType=url&ratio=1&rotation=0&showTitle=false&size=127925&status=done&style=none&taskId=u38ac353c-ae0d-42b8-b169-4fcdc20e318&title=" alt="image.png"></p>
<p><strong>mysql的解决方案：</strong><br><strong>MySQL 的 Innodb 存储引擎是在一个 LRU 链表上划分来 2 个区域，young 区域 和 old 区域。</strong><br>young 区域与 old 区域在 LRU 链表中的占比关系并不是一比一的关系，而是是** 7 比 3 （**默认比例）的关系。<br>划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部。如果预读的页一直没有被访问，就会从 old 区域移除，这样就不会影响 young 区域中的热点数据。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1663574699923-a5354717-fc5a-4b6f-ad75-e90c76fa4613.png#averageHue=%23f4f3ee&clientId=uf2374c8c-772d-4&from=paste&id=u38707ee8&originHeight=212&originWidth=1187&originalType=url&ratio=1&rotation=0&showTitle=false&size=68359&status=done&style=none&taskId=u6d9d5b9c-6fb3-4646-bfa2-63a6acc9b39&title=" alt="image.png"></p>
<h3 id="缓存污染"><a href="#缓存污染" class="headerlink" title="缓存污染"></a>缓存污染</h3><p>当我们批量读取数据时，这样预读时也会读取大量的数据，此时大量的数据都会被加入到活跃的LRU链表中，这样之前缓存的热点数据会全部被淘汰，如果这些大量的数据后续又没有被访问，那么这个活跃的LRU链表就是被缓存污染了。<br>等热点数据访问时，就会产生大量的磁盘io 这时性能就会急剧下降了。</p>
<h3 id="如何解决缓存污染"><a href="#如何解决缓存污染" class="headerlink" title="如何解决缓存污染"></a>如何解决缓存污染</h3><p>思路:提高加入活跃LRU链表的门槛，这样数据就不会轻易进入LRU链表，也就保证了活跃LRU链表里的热点数据不会被轻易替换。</p>
<p>Linux设置在内存页被访问第二次时，才会将页从 inactive list 升级到 active list 里。<br>MySQL Innodb：在内存页被访问第二次的时候，并不会马上将该页从 old 区域升级到 young 区域，因为还要进行停留在 old 区域的时间判断：</p>
<ul>
<li>如果第二次的访问时间与第一次访问的时间在 1 秒内（默认值），那么该页就不会被从 old 区域升级到 young 区域；</li>
<li>如果第二次的访问时间与第一次访问的时间超过 1 秒，那么该页就会从 old 区域升级到 young 区域；</li>
</ul>
<p>此时我们读取批量数据，如果这些数据只被访问一次，那么就会进入到活跃的LRU链表中(young区域)，也就不会淘汰热点数据了。当然在非活跃链表(old区域)中的数据会很快被淘汰。</p>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><strong>运行中的程序就是进程。</strong></p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1663664351303-5c516f90-4f06-4bfd-89e3-d2553ab9d4dd.png#averageHue=%23faf8f4&clientId=uc45b8507-4deb-4&from=paste&id=u6ba45a17&originHeight=722&originWidth=1166&originalType=url&ratio=1&rotation=0&showTitle=false&size=234606&status=done&style=none&taskId=ua15abc8d-2464-4e08-9acf-cbc74102a9c&title=" alt="image.png"></p>
<ul>
<li>运行状态（Running）：该时刻进程占用 CPU；</li>
<li>就绪状态（Ready）：可运行，由于其他进程处于运行状态而暂时停止运行；</li>
<li>阻塞状态（Blocked）：该进程正在等待某一事件发生（如等待输入&#x2F;输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行；</li>
<li>创建状态（new）：进程正在被创建时的状态；</li>
<li>结束状态（Exit）：进程正在从系统中消失时的状态；</li>
<li>阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；</li>
<li>就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行；</li>
</ul>
<h3 id="进程控制块-PCB"><a href="#进程控制块-PCB" class="headerlink" title="进程控制块(PCB)"></a>进程控制块(PCB)</h3><p><strong>PCB 是进程存在的唯一标识</strong>，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会<strong>随之消失。</strong><br><strong>PCB具体包含的信息:</strong></p>
<ul>
<li>进程描述信息：<ul>
<li>进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；</li>
<li>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；</li>
</ul>
</li>
<li>进程控制和管理信息：<ul>
<li>进程当前状态，如 new、ready、running、waiting 或 blocked 等；</li>
<li>进程优先级：进程抢占 CPU 时的优先级；</li>
</ul>
</li>
<li>资源分配清单：<ul>
<li>有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I&#x2F;O 设备信息。</li>
</ul>
</li>
<li>CPU 相关信息：<ul>
<li>CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。</li>
</ul>
</li>
</ul>
<p>相同状态的进程会以链表的形式组织在一起，比如就绪队列、阻塞队列。</p>
<h3 id="进程的操作"><a href="#进程的操作" class="headerlink" title="进程的操作"></a>进程的操作</h3><h4 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h4><p><strong>操作系统允许一个进程创建另一个进程</strong>，而且允许子进程继承父进程所拥有的资源。<br><strong>过程:</strong></p>
<ul>
<li>申请一个空白的 PCB，并向 PCB 中填写一些控制和管理进程的信息，比如进程的唯一标识等；</li>
<li>为该进程分配运行时所必需的资源，比如内存资源；</li>
<li>将 PCB 插入到就绪队列，等待被调度运行；</li>
</ul>
<h4 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h4><p>进程可以有 3 种终止方式：正常结束、异常结束以及外界干预（信号 kill 掉）。<br>当子进程被终止时，其在父进程处继承的资源应当还给父进程。而当父进程被终止时，该父进程的子进程就变为孤儿进程，会被 1 号进程收养，并由 1 号进程对它们完成状态收集工作。</p>
<h4 id="阻塞进程"><a href="#阻塞进程" class="headerlink" title="阻塞进程"></a>阻塞进程</h4><p>当进程需要等待某一事件完成时，它可以调用阻塞语句把自己阻塞等待。而<strong>一旦被阻塞等待，它只能由另一个进程唤醒</strong>。</p>
<h4 id="唤醒进程"><a href="#唤醒进程" class="headerlink" title="唤醒进程"></a>唤醒进程</h4><p>进程由「运行」转变为「阻塞」状态是由于进程必须等待某一事件的完成，所以处于阻塞状态的进程是绝对不可能叫醒自己的。<br>如果某进程正在等待 I&#x2F;O 事件，需由别的进程发消息给它，则只有当该进程所期待的事件出现时，才由发现者进程用唤醒语句叫醒它。</p>
<h3 id="进程的上下文切换"><a href="#进程的上下文切换" class="headerlink" title="进程的上下文切换"></a>进程的上下文切换</h3><p>任务是交给 CPU 运行的，那么在每个任务运行前，CPU 需要知道任务从哪里加载，又从哪里开始运行。<br>寄存器中存储了运行任务所必须依赖的环境，这些环境就叫做 <strong>CPU 上下文</strong>。<br><strong>寄存器上下文</strong>：处理器中各个寄存器的内容被称为寄存器上下文（或硬件上下文）。</p>
<p>任务主要包含进程、线程和中断。所以，可以根据任务的不同，把 CPU 上下文切换分成：进程上下文切换、线程上下文切换和中断上下文切换。</p>
<p><strong>进程是由内核管理和调度的，所以进程的切换只能发生在内核态。</strong></p>
<p>进程上下文是保存在PCB中的，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行</p>
<p>进程上下文分为用户级上下文和系统级上下文:</p>
<ul>
<li><strong>用户级上下文</strong>：由用户的程序块、数据块、运行时的堆和用户栈（统称为用户堆栈）等组成的用户空间信息被称为用户级上下文。</li>
<li><strong>系统级上下文</strong>：由进程标识信息、进程现场信息、进程控制信息（包含进程表、页表、打开文件表等）和系统内核栈等组成的内核空间信息被称为系统级上下文。</li>
<li></li>
</ul>
<p><strong>上下文切换:</strong></p>
<ul>
<li>将当前处理器的寄存器上下文保存到当前进程的系统级上下文的现场信息中；(保存了切换时进程的状态)</li>
<li>将新进程系统级上下文中的现场信息作为新的寄存器上下文恢复到处理器的各个寄存器中；</li>
<li>将控制转移到新进程执行。</li>
</ul>
<p>PC(程序计数器)是寄存器上下文中比较重要的信息之一，当前进程被打断的断点处的PC作为寄存器上下文的一部分被保存在进程现场信息中。<code>当前进程执行到哪个位置的信息是在pc中，然后上下文切换时保存到进程现场信息</code>。<br>这样，下次改进程再被调度到处理器上执行时，就可以从其现场信息中获得断点处的PC，从而能从断点处开始执行。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><strong>线程是进程当中的一条执行流程。</strong></p>
<p><strong>同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。</strong></p>
<h3 id="线程和进程比较"><a href="#线程和进程比较" class="headerlink" title="线程和进程比较"></a>线程和进程比较</h3><ul>
<li>进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；</li>
<li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；</li>
<li>线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；</li>
<li>线程能减少并发执行的时间和空间开销；</li>
<li>线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；</li>
<li>线程的终止时间比进程快，因为线程释放的资源相比进程少很多；</li>
<li>同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；</li>
<li>由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；</li>
</ul>
<h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><ul>
<li>当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；</li>
<li>当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据；</li>
</ul>
<h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>主要有三种线程的实现方式：</p>
<ul>
<li><strong>用户线程</strong>（User Thread）：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；</li>
<li><strong>内核线程</strong>（Kernel Thread）：在内核中实现的线程，是由内核管理的线程；</li>
<li><strong>轻量级进程</strong>（LightWeight Process）：在内核中来支持用户线程</li>
</ul>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>操作系统选择下一个要运行的进程(线程)，称为调度。</p>
<h3 id="调度原则"><a href="#调度原则" class="headerlink" title="调度原则"></a>调度原则</h3><p>原则一(<strong>CPU利用率</strong>)：如果运行的程序，发生了 I&#x2F;O 事件的请求，那 CPU 使用率必然会很低，因为此时进程在阻塞等待硬盘的数据返回。这样的过程，势必会造成 CPU 突然的空闲。所以，为了提高 CPU 利用率，在这种发送 I&#x2F;O 事件致使 CPU 空闲的情况下，调度程序需要从就绪队列中选择一个进程来运行。</p>
<p>原则二(<strong>系统吞吐量</strong>)：有的程序执行某个任务花费的时间会比较长，如果这个程序一直占用着 CPU，会造成系统吞吐量（CPU 在单位时间内完成的进程数量）的降低。所以，要提高系统的吞吐率，调度程序要权衡长任务和短任务进程的运行完成数量。</p>
<p>原则三(<strong>周转时间</strong>)：从进程开始到结束的过程中，实际上是包含两个时间，分别是进程运行时间和进程等待时间，这两个时间总和就称为周转时间。进程的周转时间越小越好，如果进程的等待时间很长而运行时间很短，那周转时间就很长，这不是我们所期望的，调度程序应该避免这种情况发生。</p>
<p>原则四(<strong>等待时间</strong>)：处于就绪队列的进程，也不能等太久，当然希望这个等待的时间越短越好，这样可以使得进程更快的在 CPU 中执行。所以，就绪队列中进程的等待时间也是调度程序所需要考虑的原则。</p>
<p>原则五(<strong>响应时间</strong>)：对于鼠标、键盘这种交互式比较强的应用，我们当然希望它的响应时间越快越好，否则就会影响用户体验了。所以，对于交互式比较强的应用，响应时间也是调度程序需要考虑的原则。</p>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>根据如何处理时钟中断 ，可以把调度算法分为两类：<br>● 非抢占式调度算法 挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情。<br>● 抢占式调度算法 挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便把 CPU 控制返回给调度程序进行调度，也就是常说的时间片机制。</p>
<h4 id="先来先服务（First-Come-First-Serve-FCFS"><a href="#先来先服务（First-Come-First-Serve-FCFS" class="headerlink" title="先来先服务（First Come First Serve, FCFS)"></a>先来先服务（First Come First Serve, FCFS)</h4><p>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。<br>这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。<br>FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I&#x2F;O 繁忙型作业的系统。</p>
<h4 id="最短作业优先（Shortest-Job-First-SJF）"><a href="#最短作业优先（Shortest-Job-First-SJF）" class="headerlink" title="最短作业优先（Shortest Job First, SJF）"></a>最短作业优先（Shortest Job First, SJF）</h4><p>优先选择运行时间最短的进程来运行，这有助于提高系统的吞吐量。<br>显然对长作业不利，很容易造成一种极端现象。</p>
<p>比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。</p>
<h4 id="高响应比优先-（Highest-Response-Ratio-Next-HRRN）"><a href="#高响应比优先-（Highest-Response-Ratio-Next-HRRN）" class="headerlink" title="高响应比优先 （Highest Response Ratio Next, HRRN）"></a>高响应比优先 （Highest Response Ratio Next, HRRN）</h4><p>主要是权衡了短作业和长作业。<br>每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1663836615865-96b97ff4-fe8d-4f5c-866e-2ea847a34a9d.png#averageHue=%23efe3be&clientId=ucc9c2ff3-2f2e-4&from=paste&id=u7fffcdc0&originHeight=173&originWidth=572&originalType=url&ratio=1&rotation=0&showTitle=false&size=49073&status=done&style=none&taskId=uff5ff36e-f36e-44d1-be24-878a348ca07&title=" alt="image.png"></p>
<p>高响应比优先调度算法是「理想型」的调度算法，现实中是实现不了的。</p>
<h4 id="时间片轮转（Round-Robin-RR）"><a href="#时间片轮转（Round-Robin-RR）" class="headerlink" title="时间片轮转（Round Robin, RR）"></a>时间片轮转（Round Robin, RR）</h4><p>每个进程被分配一个时间段，称为时间片（Quantum），即允许该进程在该时间段中运行。</p>
<ul>
<li>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配给另外一个进程；</li>
<li>如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；</li>
<li></li>
</ul>
<p><strong>时间片的长度是一个很关键的点：</strong><br>如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；<br>如果设得太长又可能引起对短作业进程的响应时间变长。<br>一般来说，时间片设为 20ms~50ms 通常是一个比较合理的折中值</p>
<h4 id="最高优先级（Highest-Priority-First，HPF）"><a href="#最高优先级（Highest-Priority-First，HPF）" class="headerlink" title="最高优先级（Highest Priority First，HPF）"></a>最高优先级（Highest Priority First，HPF）</h4><p>它希望调度是有优先级的，即希望调度程序能从就绪队列中选择最高优先级的进程进行运行。<br>进程的优先级可以分为，静态优先级和动态优先级：</p>
<ul>
<li>静态优先级：创建进程时候，就已经确定了优先级了，然后<strong>整个运行时间优先级都不会变化</strong>；</li>
<li>动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是<strong>随着时间的推移增加等待进程的优先级</strong>。</li>
</ul>
<p>该算法也有两种处理优先级高的方法，非抢占式和抢占式：</p>
<ul>
<li>非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。</li>
<li>抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</li>
</ul>
<p>但是依然有缺点，可能会导致低优先级的进程永远不会运行。</p>
<h4 id="多级反馈队列（Multilevel-Feedback-Queue）"><a href="#多级反馈队列（Multilevel-Feedback-Queue）" class="headerlink" title="多级反馈队列（Multilevel Feedback Queue）"></a>多级反馈队列（Multilevel Feedback Queue）</h4><p>这个算法是「时间片轮转算法」和「最高优先级算法」的综合和发展。</p>
<ul>
<li>「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。</li>
<li>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；</li>
</ul>
<p><strong>流程:</strong></p>
<ul>
<li>设置了多个队列，赋予每个队列不同的优先级，每个队列优先级从高到低，同时优先级越高时间片越短；</li>
<li>新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；</li>
<li>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；</li>
<li></li>
</ul>
<p>可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也变更长了，所以该算法很好的兼顾了长短作业，同时有较好的响应时间。</p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1663837898706-a9b7b4fb-9039-4951-8297-cb2cfbbe057a.png#averageHue=%23c1c3c1&clientId=ucc9c2ff3-2f2e-4&from=paste&id=u3b9b88c4&originHeight=426&originWidth=950&originalType=url&ratio=1&rotation=0&showTitle=false&size=113144&status=done&style=none&taskId=ub91374bb-f577-44f5-b8a3-d4ff01fe777&title=" alt="image.png"><br>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核。</p>
<h1 id="网络系统"><a href="#网络系统" class="headerlink" title="网络系统"></a>网络系统</h1><h2 id="DMA技术"><a href="#DMA技术" class="headerlink" title="DMA技术"></a>DMA技术</h2><p>没有DMA技术前,整个I&#x2F;O过程都需要CPU参与，期间CPU干不了其他的事情，如果通过硬盘传输大量数据，CPU肯定忙不过来，于是发明了DMA技术 <code>**直接内存访问（_Direct Memory Access_）** 技术。</code><br><strong>在进行 I&#x2F;O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务。</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22451783/1668412435060-6ae5c0fa-e1ea-4d29-beba-3d86987da793.png#averageHue=%23fafaf9&clientId=u305a72ef-6277-4&from=paste&id=uc631c4ee&originHeight=860&originWidth=1832&originalType=url&ratio=1&rotation=0&showTitle=false&size=335379&status=done&style=none&taskId=u2cc43902-e605-466f-a9f6-50babc39511&title=" alt="image.png"><br>具体过程：</p>
<ul>
<li>用户进程调用 read 方法，向操作系统发出 I&#x2F;O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；</li>
<li>操作系统收到请求后，进一步将 I&#x2F;O 请求发送 DMA，然后让 CPU 执行其他任务；</li>
<li>DMA 进一步将 I&#x2F;O 请求发送给磁盘；</li>
<li>磁盘收到 DMA 的 I&#x2F;O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；</li>
<li>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务；</li>
<li>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；</li>
<li>CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；</li>
</ul>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><h3 id="传统文件传输"><a href="#传统文件传输" class="headerlink" title="传统文件传输"></a>传统文件传输</h3><p>服务端传送文件，一般是从磁盘上读取文件，然后通过网络协议发送给客户端。<br>方法:<br><strong>read(file, tmp_buf, len);</strong><br><strong>write(socket, tmp_buf, len);</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/22451783/1674026566361-c0acd248-9e0e-46a9-b059-dc12c8c6709a.png#averageHue=%23f7f2e6&clientId=uaa416c7c-0376-4&from=paste&id=u3910856a&originHeight=678&originWidth=1100&originalType=url&ratio=1&rotation=0&showTitle=false&size=230228&status=done&style=none&taskId=u8ab3bf6f-355d-46e4-8813-9d439ed537e&title=" alt="image.png"><br><strong>期间共发生了 4 次用户态与内核态的上下文切换，因为发生了两次系统调用，一次是 read() ，一次是 write()，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。</strong></p>
<ul>
<li>第一次拷贝，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。</li>
<li>第二次拷贝，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 <strong>CPU 完成</strong>的。</li>
<li>第三次拷贝，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 <strong>CPU 搬运</strong>的。</li>
<li>第四次拷贝，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</li>
</ul>
<h3 id="零拷贝-1"><a href="#零拷贝-1" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>零拷贝技术实现的方式通常有 2 种：</p>
<ul>
<li>mmap + write</li>
<li>sendfile</li>
</ul>
<h4 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap + write"></a>mmap + write</h4><p>read() 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 mmap() 替换 read() 系统调用函数。<br>mmap() 系统调用函数会直接把内核缓冲区里的数据「映射」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。<br>这样减少了一次数据拷贝 但是远远不够。</p>
<h4 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h4><p>它可以替代前面的 read() 和 write() 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。</p>
<p>如果网卡支持 SG-DMA，我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。</p>
<p>你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ethtool -k eth0 | grep scatter-gather</span></span><br><span class="line">scatter-gather: on</span><br></pre></td></tr></table></figure>
<p>这样sendfile系统调用发生了变化</p>
<ul>
<li>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li>
<li>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/22451783/1674027026494-f25dde8e-a983-422e-a9a7-f3447a6a5469.png#averageHue=%23f0eee1&clientId=uaa416c7c-0376-4&from=paste&id=uda46c372&originHeight=686&originWidth=1160&originalType=url&ratio=1&rotation=0&showTitle=false&size=267137&status=done&style=none&taskId=u9d44cd20-8b12-469b-ae37-3233cff912c&title=" alt="image.png"><br>这就是所谓的零拷贝（Zero-copy）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。<br>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</p>
<h2 id="PageCache"><a href="#PageCache" class="headerlink" title="PageCache"></a>PageCache</h2><p>读取内存的速度比直接读取磁盘的速度要快很多很多，DMA技术便是将磁盘中的数据拷贝到内存中。<br>内核缓冲区实际上就是<strong>PageCache。</strong><br>由于内存空间很小，一次只能从磁盘中拷贝很小一部分数据到内存。通常程序运行具有<strong>局限性</strong>，刚被访问的数据在短时间内再次被访问的概率很高，所以PageCache缓存着最近被访问的数据，当空间不足时淘汰最久未被访问的数据。</p>
<p>PageCache还具有预读功能，read方法一次只会读取32字节，但是内核会多读取后面32字节的内容，如果后32字节再被淘汰之前访问到了就大大降低了成本。</p>
<h2 id="Select-poll-epoll"><a href="#Select-poll-epoll" class="headerlink" title="Select poll epoll"></a>Select poll epoll</h2><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>Socket 的中文名叫作插口,双方要进行网络通信前，各自得创建一个 Socket，这相当于客户端和服务器都开了一个“口子”，双方读取和发送数据的时候，都通过这个“口子”。这样一看，是不是觉得很像弄了一根网线，一头插在客户端，一头插在服务端，然后进行通信。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/22451783/1675666447142-86a6d349-a6dc-40fd-a17e-16a823adae0c.png#averageHue=%23f8f5eb&clientId=u6973ef98-2165-4&from=paste&id=uaf0a3b89&originHeight=722&originWidth=407&originalType=url&ratio=1&rotation=0&showTitle=false&size=76145&status=done&style=none&taskId=u9e268dd3-3e9e-4cda-b7ae-d0066440d36&title=" alt="image.png"><br>服务端首先调用 socket() 函数，创建网络协议为 IPv4，以及传输协议为 TCP 的 Socket ，接着调用 bind() 函数，给这个 Socket 绑定一个 IP 地址和端口。</p>
<p>绑定完 IP 地址和端口后，就可以调用 listen() 函数进行监听，此时对应 TCP 状态图中的 listen，如果我们要判定服务器中一个网络程序有没有启动，可以通过 netstat 命令查看对应的端口号是否有被监听。</p>
<p>服务端进入了监听状态后，通过调用 accept() 函数，来从内核获取客户端的连接，如果没有客户端连接，则会阻塞等待客户端连接的到来。</p>
<p>那客户端是怎么发起连接的呢？客户端在创建好 Socket 后，调用 connect() 函数发起连接，该函数的参数要指明服务端的 IP 地址和端口号，然后万众期待的 TCP 三次握手就开始了。</p>
<p>在 TCP 连接的过程中，服务器的内核实际上为每个 Socket 维护了两个队列：</p>
<ul>
<li>一个是「还没完全建立」连接的队列，称为 TCP 半连接队列，这个队列都是没有完成三次握手的连接，此时服务端处于 syn_rcvd 的状态；</li>
<li>一个是「已经建立」连接的队列，称为 TCP 全连接队列，这个队列都是完成了三次握手的连接，此时服务端处于 established 状态；</li>
</ul>
<p>当 TCP 全连接队列不为空后，服务端的 accept() 函数，就会从内核中的 TCP 全连接队列里拿出一个已经完成连接的 Socket 返回应用程序，后续数据传输都用这个 Socket。</p>
<p>注意，<strong>监听的 Socket</strong> 和真正用来<strong>传数据的 Socket</strong> 是两个：<br>一个叫作监听 Socket；<br>一个叫作已连接 Socket；</p>
<p>基于 Linux 一切皆文件的理念，在内核中 Socket 也是以「文件」的形式存在的，也是有对应的<strong>文件描述符</strong>。</p>
<h3 id="I-x2F-O多路复用"><a href="#I-x2F-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h3><p>为每一个请求分配一个进程&#x2F;线程是不现实的，一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用。</p>
<p>我们熟悉的 select&#x2F;poll&#x2F;epoll 内核提供给用户态的多路复用系统调用，进程可以通过一个系统调用函数从内核中获取多个事件。</p>
<p>select&#x2F;poll&#x2F;epoll 是如何获取网络事件的呢？在获取事件时，先把<strong>所有连接</strong>（文件描述符）传给内核，再由内核返回<strong>产生了事件的连接</strong>，然后在用户态中再处理这些连接对应的请求即可。</p>
<h3 id="select-x2F-poll"><a href="#select-x2F-poll" class="headerlink" title="select&#x2F;poll"></a>select&#x2F;poll</h3><p>select 实现多路复用的方式是，将已连接的 Socket 都放到一个<strong>文件描述符集合</strong>，然后调用 select 函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过遍历文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的 Socket，然后再对其处理。<br><strong>select使用的是数组表示文件描述符集合，以轮询的方式获取产生事件的socket。</strong><br><strong>poll 不再用 数组 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。</strong></p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll 在内核里使用红黑树来跟踪进程<strong>所有待检测的文件描述字。</strong>epoll使用<strong>事件驱动</strong>机制,内核中维护了一个链表记录有事件发生的socket。当某个socket有事件发生了，内核就会通过回调函数将其加入到就绪事件列表中。<br>用户调用 epoll_wait() 函数时，只会返回有事件发生的文件描述符的个数。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/22451783/1675667340595-b293c656-a8bf-468e-897b-3c113c2d901a.png#averageHue=%23eceed2&clientId=u6973ef98-2165-4&from=paste&id=u3ee09042&originHeight=527&originWidth=1142&originalType=url&ratio=1&rotation=0&showTitle=false&size=142018&status=done&style=none&taskId=udfb904a8-17f9-4802-9f0e-3df79f2d836&title=" alt="image.png"></p>
<h2 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h2><p>Reactor 模式也叫 Dispatcher 模式, 即** I&#x2F;O 多路复用监听事件<strong>，收到事件后，</strong>根据事件类型分配（Dispatch）给某个进程 &#x2F; 线程**。<br>Reactor 模式主要由 Reactor 和处理资源池这两个核心部分组成，它俩负责的事情如下：</p>
<ul>
<li>Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件；</li>
<li>处理资源池负责处理事件，如 read -&gt; 业务逻辑 -&gt; send；</li>
</ul>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://example.com/2023/07/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统" target="_blank" rel="external">http://example.com/2023/07/07/操作系统/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/sugarGood" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/a.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/sugarGood" target="_blank"><span class="text-dark">theo</span><small class="ml-1x">Think &amp; Practice</small></a></h3>
        <div>一个大帅比。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    
    <li class="next">
      <a href="/2023/07/07/%E6%B5%85%E6%9E%90nacos%E6%BA%90%E7%A0%81%E4%B8%80%20%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/" title="浅析nacos源码一 服务注册"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn   collapsed  " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">    <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/1688739348343.jpg" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/mm_facetoface_collect_qrcode_1688739355475.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>





</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/sugarGood" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://gitee.com/sugarGood" target="_blank" title="Gitee" data-toggle=tooltip data-placement=top><i class="icon icon-gitee"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: true,
    notify: true,
    appId: 'QEI0gu3ZchE5x4TcybdvG8iL-gzGzoHsz',
    appKey: 'bqHluNWepzDS18qbu1Nk8m7Q',
    placeholder: '留下你的评论o(*￣▽￣*)ブ',
    avatar: 'robohash',
    meta: meta,
    pageSize: '10' || 10,
    visitor: true
  });
  </script>

     



  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





</body>
</html>